"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">content="HTML Tidy for Linux/x86 (vers 1st March 2002), see www.w3.org" />LBase: Semantics for Languages of the Semantic Webcontent="text/html; charset=iso-8859-1" />/**/P.c3 { FONT-STYLE: italic}P.c2 { FONT-STYLE: italic; TEXT-ALIGN: center}P.c1 { TEXT-ALIGN: center}.new { }.newer { }.cream { BACKGROUND-COLOR: #ffff99}.lilac { BACKGROUND-COLOR: #ff99ff}.datatype { FONT-SIZE: small;FONT-FAMILY: monospace;BACKGROUND-COLOR: #99cc99}div.c1 {text-align: center}/*]]>*/href="http://www.w3.org/StyleSheets/TR/W3C-WG-NOTE.css" />alt="W3C" src="http://www.w3.org/Icons/w3c_home" />LBase: Semantics for Languages of the Semantic WebW3C Working Group Note 10 October 2003This version:href="http://www.w3.org/TR/2003/NOTE-lbase-20031010/">http://www.w3.org/TR/2003/NOTE-lbase-20031010/Latest version:href="http://www.w3.org/TR/lbase">http://www.w3.org/TR/lbasePrevious version:http://www.w3.org/TR/2003/NOTE-lbase-20030905Authors:R.V.Guha, IBM, <href="mailto:rguha@us.ibm.com">rguha@us.ibm.com>Patrick Hayes, IHMC<href="mailto:phayes@ihmc.us">phayes@ihmc.us>href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright© 2003title="World Wide Web Consortium">W3C®(title="Massachusetts Institute of Technology">MIT,title="European Research Consortium for Informatics and Mathematics">ERCIM, Keio),All Rights Reserved. W3Chref="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability,href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark,href="http://www.w3.org/Consortium/Legal/copyright-documents">documentuse andhref="http://www.w3.org/Consortium/Legal/copyright-software">softwarelicensing rules apply.AbstractThis document presents a framework for specifying the semanticsfor the languages of the Semantic Web. Some of these languages(notably RDF [RDF-PRIMER] [href="#ref-rdf-schema">RDF-VOCABULARY] [href="#ref-rdf-syntax">RDF-SYNTAX] [href="#ref-rdf-concepts">RDF-CONCEPTS] [href="#ref-rdf-semantics">RDF-SEMANTICS], and OWL [href="#ref-owl">OWL]) are currently in various stages ofdevelopment and we expect others to be developed in the future.This framework is intended to provide a framework for specifyingthe semantics of all of these languages in a uniform and coherentway. The strategy is to translate the various languages into acommon 'base' language thereby providing them with a singlecoherent model theory.We describe a mechanism for providing a precise semantics forthe Semantic Web Languages (referred to as SWELs from now on. Thepurpose of this is to define clearly the consequences and allowedinferences from constructs in these languages.Status of This DocumentThis section describes the status of this document at the time of its publication. Otherdocuments may supersede this document. A list of current W3C publications and the latest revision ofthis technical report can be found in the W3C technical reportsindex at http://www.w3.org/TR/.Publication as a Working Group Note does not imply endorsement by the W3C Membership. This is adraft document and may be updated, replaced or obsoleted by other documents at any time. It isinappropriate to cite this document as other than work in progress.This document results from discussions within thehref="http://www.w3.org/2001/sw/RDFCore/">RDF Core WorkingGroup concerning the formalization of RDF and RDF-basedlanguages. The RDF Core Working Group is part of thehref="http://www.w3.org/2001/sw/Activity">W3C Semantic WebActivity. The group's goals and requirements are discussed inthe RDF CoreWorking Group charter. These include requirements that...The RDF Core group must take into account the variousformalizations of RDF that have been proposed since thepublication of the RDF Model and Syntax Recommendation. The groupis encouraged to make use both of formal techniques andimplementation-led test cases throughout their work.The RDF schema system must provide an extensibilitymechanism to allow future work (for example on Web Ontology andlogic-based Rule languages) to provide richerfacilities.This document is motivated by these two requirements. It doesnot present an RDF Core WG design for Semantic Web layering.Rather, it documents a technique that the RDF Core WG are using inour discussions and in the RDFSemantics specification. The RDF Core WG solicit feedback fromother Working Groups and from the RDF implementor community on thewider applicability of this technique.Note that the use of the abbreviation "SWEL" in Lbase differsfrom the prior use of "SWeLL" in thehref="http://www.w3.org/2000/01/sw/#daml">MIT/LCS DAMLproject.In conformance withhref="http://www.w3.org/Consortium/Process-20010719/#ipr">W3Cpolicy requirements, known patent andtitle="Intellectual Property Rights">IPR constraintsassociated with this Note are detailed on thehref="http://www.w3.org/2001/sw/RDFCore/ipr-statements"rel="disclosure">RDF Core Working Group Patent Disclosurepage.Review comments on this document are invited and should be sentto the public mailing listhref="mailto:www-rdf-comments@w3.org">www-rdf-comments@w3.org.An archive of comments is available athref="http://lists.w3.org/Archives/Public/www-rdf-comments/">http://lists.w3.org/Archives/Public/www-rdf-comments/.Discussion of this document is invited on thehref="mailto:www-rdf-logic@w3.org">www-rdf-logic@w3.org list ofthe RDF InterestGroup (href="http://lists.w3.org/Archives/Public/www-rdf-logic/">publicarchives).Table of Contents1 Model-theoretic semantics2 Outline of Approach2.1 Consistency2.2 Lbase Syntax2.3 Interpretations2.4 Axiom Schemas2.5 Entailment3 Using Lbase3.1 Relation between the two...4 Inadequacies of5 Acknowledgements6 References7 Change Log1. Model-theoretic semanticsA model-theoreticsemantics for a language assumes that the language refers to a'world', and describes the minimal conditions that a world mustsatisfy in order to assign an appropriate meaning for everyexpression in the language. A particular world is called aninterpretation, so that model theory might be better called'interpretation theory'. The idea is to provide a mathematicalaccount of the properties that any such interpretation must have,making as few assumptions as possible about its actual nature orintrinsic structure. Model theory tries to be metaphysically andontologically neutral. It is typically couched in the language ofset theory simply because that is the normal language ofmathematics - for example, this semantics assumes that names denotethings in a set IR called the 'universe' - but the use ofset-theoretic language here is not supposed to imply that thethings in the universe are set-theoretic in nature.The chief utility of such a semantic theory is not to suggestany particular processing model, or to provide any deep analysis ofthe nature of the things being described by the language, butrather to provide a technical tool to analyze the semanticproperties of proposed operations on the language; in particular,to provide a way to determine when they preserve meaning. Anyproposed inference rule, for example, can be checked to see if itis valid with respect to a model theory, i.e. if its conclusionsare always true in any interpretation which makes its antecedentstrue.We note that the word 'model' is often used in a ratherdifferent sense, eg as in 'data model', to refer to a computationalsystem or data structures of some kind. To avoid misunderstanding,we emphasise that the interpretations referred to in a model theoryare not, in general, intended to be thought of as things that canbe computed or manipulated by computers.2. Outline of ApproachThere will be many Semantic Web languages, most of which will bebuilt on top of more basic Semantic Web language(s). It isimportant that this layering be clean and simple, not justfor human understandability, but also to enable the construction ofrobust semantic web agents that use these languages. The emergingcurrent practice is for each of the SWELs to be defined in terms oftheir own model theory, layering it on top of the model theories ofthe languages they are layered upon. While having a model theory isclearly desireable, and even essential, for a SWEL, thisdirect-construction approach has several problems. It produces arange of model theories, each with its own notion of consequenceand entailment. It requires expertise in logic to make sure thatmodel theories align properly, and model-theoretic alignment doesnot always sit naturally with interoperability requirements.Experience to date (particularly with the OWL standard underdevelopment at the time of writing by thehref="http://www.w3.org/2001/sw/WebOnt/">W3C Webont workinggroup) shows that quite difficult problems can arise whenlayering model theories for extensions to the 'basic' RDF layer[RDF] of the semantic web. Moreover, this strategy places a veryhigh burden on the 'basic' layer, since it is difficult toanticipate the semantic demands which will be made by all futurehigher layers, and the expectations of different development anduser communities may conflict. Further, we believe that a melangeof model theories will adversely impact developers building agentsthat implement proof systems for these layers, since the proofsystems will likely be different for each layer, resulting in theneed to micro-manage small semantic variations for various dialectsand sub-languages (cf. the distinctions between various dialects ofOWL).In this document, we use an alternative approach to for definingthe semantics for the different SWELs in a fashion which ensuresinteroperability. We first define a basic language Lbasewhich is expressive enough to state the content of all currentlyproposed web languages, and has a fixed, clear model-theoreticsemantics. Then, the semantics of each SWEL Li isdefined by specifying how expressions in the Li map intoequivalent expressions in Lbase, and by providing axiomswritten in Lbase which constrain the intended meaningsof the SWEL special vocabulary. The Lbase meaning of anyexpression in any SWEL language can then be determined bymapping it into Lbase and adding the appropriatelanguage axioms, if there are any.The intended result is that the model theory of Lbaseis the model theory of all the Semantic Web Languages,even though the languages themselves are different. This makes itpossible to use a single inference mechanism to work on thesedifferent languages. Although it will possible to exploitrestrictions on the languages to provide better performance, theexistence of a reference proof system is likely to be of utility todevelopers. This also allows the meanings of expressions indifferent SWELs to be compared and combined, which is verydifficult when they all have distinct model theories.The idea of providing a semantics for SWELs bytranslating them into logic is not new [see for exampleMarchiolri&Saarela, Fikes&McGuinness] but we plan to adopta somewhat different style than previous 'axiomatic semantics',which have usually operated by mapping all RDF triples to instancesof a single three-place predicate. We propose rather to use thelogical form of the target language as an explication of theintended meaning of the SWEL, rather than simply as an axiomaticdescription of that meaning, so that RDF classes translate to unarypredicates, RDF properties to binary relations, the relationrdf:type translates to application of a predicate to an argument,and list-valued properties in OWL or DAML can be translated inton-ary or variadic relations. The syntax and semantics ofLbase have been designed with this kind of translationin mind. It is our intent that the model theory of Lbasebe used in the spirit of its model theory and not as a programminglanguage, i.e., relations in Li should correspond torelations in Lbase, variables should correspond tovariables and so on.It is important to note that Lbase is notbeing proposed as a SWEL. It is a tool for specifying the semanticsof different SWELs. The syntax of Lbase described hereis not intended to be accessible for machine processing; any suchproposal should be considered to be a proposal for a moreexpressive SWEL.2.1 ConsistencyBy using a well understood logic (i.e., first order logic[Enderton]) as the core of Lbase, and providing formutually consistent mappings of different SWELs intoLbase, we ensure that the content expressed in severalSWELs can be combined consistently, avoiding paradoxes and otherproblems. Mapping type/class language into predicate/applicationlanguage also ensures that set-theoretical paradoxes do not arise.Although the use of this technique does not in itself guaranteethat mappings between the syntax of different SWELs will always beconsistent, it does provide a general framework for detecting andidentifying potential inconsistencies.It is also important that the axioms defining the vocabularyitems introduced by a SWEL are internally consistent. Althoughfirst-order logic (and hence Lbase) is onlysemi-decideable, we are confident that it will be routine toconstruct Lbase interpretations which establish therelevant consistencies for all the SWELs currently contemplated. Inthe general case, future efforts may have to rely on certificationsfrom particular automated theorem provers stating that they weren'table to find an inconsistency with certain stated levels of effort.The availablity of powerful inference engines for first-order logicis of course relevant here.2.1.1 LbaseIn this document, we use a version offirst order logic with equality as Lbase. This imposes afairly strict monotonic discipline on the language, so that itcannot express local default preferences and several othercommonly-used non-monotonic constructs. We expectthat as the Semantic Web grows to encompass more and ourunderstanding of the Semantic Web improves, we will need to replacethis Lbase with more expressive logics. However,we expect that first order logic will be a proper subset of suchsystems and hence we will be able to smoothly transition to moreexpressive Lbase languages in the future. We note thatthe computational advantages claimed for various sublanguages offirst-order logic, such as description logics, logical programminglanguages and frame languages, are irrelevant for the purposes ofusing Lbase as a semantic specification language.We will use First Order Logic with suitable minor changes toaccount for the use of referring expressions (such as URIs) on theWeb, and a few simple extensions to improve utility for theintended purposes.2.1.2 Names and variablesAny first-order logic is based on a set of atomic terms, which are usedas the basic referring expressions in the syntax. These include names,which refer to entities in the domain, special names, and variables.Lbase distinguishes the special class of urirefs, definedto be a URI reference in the sense of [URI]. Urirefs are used to refer to bothindividuals and relations between the individuals. A name may be any stringof unicode characters not starting with the characters ')','(', '\', '?','<'or ''' , and containing no whitespace characters, or any string of unicode charactersenclosed by the symbols '<' and '>'. The <-> enclosed style is providedto allow names which would otherwise violate the Lbase syntacticconventions; in this case it is understood that the actual name is the enclosedstring. For example, the name '<br />' (eight characters, including aspace) can be written in Lbase as <'<br />'>.Lbase allows for various collections of special names with fixedmeanings defined by other specifications (external to the Lbase specification).There is no assumption that these could be defined by collections of Lbaseaxioms, so that imposing the intended meanings on these special names may gobeyond strict first-order expressiveness. (In mathematical terms, we allow thatsome sets of names refer to elements of certain fixed algebras, even when thealgebra has no characteristic first-order description.) Eachsuch set of names has an associated predicate which is true of the things denotedby the names in the set. At present, we assume two categories of suchfixed names: numerals and quoted strings, with associated predicate names 'NatNumber'and 'String' respectively. We expect that other categories of special nameswill be introduced to handle, eg. XML structures.Numerals are defined to be strings of the characters'0123456789', and are interpreted as decimal numerals in the usualway. Since arithmetic is not first-order definable, this is thefirst and most obvious place that Lbase goes beyondfirst-order expressiveness.Quoted strings are arbitrary character sequences enclosed in (single)quotation marks, and are interpreted as denoting the string inside the quotationmarks. To avoid ambiguity, single quote marks in strings are prefixed by a backslashcharacter '\' which acts an escape character, so that '\'A\\'' denotes the string'A\'. Double quote marks have no special interpretation.The associated predicate names NatNumber, Stringand Relation (see below) are considered to be special names.A variable is any non-white-space character string starting withthe character '?'.The characters '(', ',' and ')' are considered to be punctuationsymbols.The categories of punctuation, whitespace, names, special namesand variables are exclusive and each such string can be classifiedby examining its first character. This is not strictly necessarybut is a useful convention.Any Lbase language is defined with respect to avocabulary, which is a set of non-special names. We requirethat every Lbase vocabulary contain all urirefs, butother expressions are allowed. (We will require that everyLbase interpretation provide a meaning for every specialname, but these interpretations are fixed, so special names are notcounted as part of the vocabulary.)There are several aspects of meaning of expressions on thesemantic web which are not yet treated by this semantics; inparticular, it treats URIs as simple names, ignoring aspects ofmeaning encoded in particular URI forms [RFC 2396] and does notprovide any analysis of time-varying data or of changes to URIdenotations. The model theory also has nothing to say about whetheran HTTP uri such as "http://www.w3.org/" denotes the World Wide WebConsortium or the HTML page accessible at that URI or the web siteaccessible via that URI. These complexities may be addressed infuture extensions of Lbase; in general, we expect thatLbase will be extended both notationally and by addingaxioms in order to track future standardization efforts.We do not take any position here on the way that urirefs may becomposed from other expressions, e.g. from relative URIs or Qnames;the model theory simply assumes that such lexical issues have beenresolved in some way that is globally coherent, so that a singleuriref can be taken to have the same meaning wherever itoccurs.Similarly, the model theory given here has no special provisionfor tracking temporal changes. It assumes, implicitly, that urirefshave the same meaning whenever they occur. To provide anadequate semantics which would be sensitive to temporal changes isa research problem which is beyond the scope of this document..2.2 LbaseSyntaxEven though the exact syntax chosen for Lbase is notimportant, we do need a syntax for the specification. We follow thesame general conventions used in most standard presentations offirst-order logic, with one generalization which has proven useful.We will assume that there are three sets of names (not specialnames) which together constitute the vocabulary: individual names,relation names, and function names, and that each function name hasan associated arity, which is a non-negative integer. In aparticular vocabulary these sets may or may not be disjoint.Expressions in Lbase (speaking strictly,Lbase expressions in this particular vocabulary) arethen constructed recursively as follows:A term is either a name or a special name or a variable,or else it has the form f(t1,...,tn) where f is an n-ary functionname and t1,...,tn are terms.A formula is either atomic or boolean or quantified,where:an atomic formula has the form (t1=t2) where t1 and t2 areterms, or else the form R(t1,...,tn) where R is a relation name ora variable and t1,...,tn are terms;a boolean formula has one of the forms(W1 and W2 and ....and Wn)(W1 or W2 or ... or Wn)(W1 implies W2)(W1 iff W2)(not W1)where W1, ...,Wn are formulae; anda quantified formula has one of the forms(forall (?v1 ...?vn) W)(exists (?v1 ... ?vn) W)where ?v1,...,?vn are variables and W is a formula. (Thesubexpression just after the quantifier is the variablelist of the quantifier. Any occurrence of a variable in W issaid to be bound in the quantified formula by thenearest quantifer to the occurrence which includes that variable inits variable list, if there is one; otherwise it is said to befree in the formula.)Finally, an Lbase knowledge base is a set offormulae.Formulae are also called 'wellformed formulae' or 'wffs' orsimply 'expressions'. In general, surplus brackets may be omittedfrom expressions when no syntactic ambiguity would arise.Some comments may be in order. The only parts of this definitionwhich are in any way nonstandard are (1) allowing 'special names',which was discussed earlier; (2) allowing variables to occur inrelation position, which might seem to be at odds with the claimthat Lbase is first-order - we discuss this furtherbelow - and (3) not assigning a fixed arity to relation names. Thislast is a useful generalization which makes no substantial changesto the usual semantic properties of first-order logic, but whicheases the translation process for some SWEL syntactic constructs.(The computational properties of such 'variadic relations' arequite complex, but Lbase is not being proposed as alanguage for computational use.)2.3 Interpretations &SatisfactionThe following definition of an interpretation is couched inmathematical language, but what it amounts to intuitively is thatan interpretation provides just enough information about a possibleway the world might be - a 'possible world' - in order to fix thetruth-value (true or false) of any Lbase well formedformula in that world. It does this by specifying for each uriref,what it is supposed to be a name of; and also, if it is a functionsymbol, what values the function has for each choice of arguments;and further, if it is a relation symbol, which sequences of thingsthe relation holds between. This is just enough information todetermine the truth-values of all atomic formulas; and then this,together with a set of recursive rules, is enough to assign a truthvalue for any Lbase formula.In specifying the following it is convenient to define use somestandard definitions. A relation over a set S is a set of finitesequences (tuples) of members of S. If R is a relation and all theelements of R have the same length n, then R is said to havearity n, or to be a n-ary relation. Not everyrelation need have an arity. If R is an (n+1)-ary relation over Swhich has the property that for any sequence <s1,...,sn> ofmembers of S, there is exactly one element of R of the form <s0,s1, ..., sn>, then R is an n-ary function; and s0 is thevalue of the function for the arguments s1, ...sn. (Notethat an n-ary function is an (n+1)-ary relation, and that, byconvention, the function value is the first argument of therelation, so that for any n-ary function f, f(y,x1,...,xn) meansthe same as y = f(x1,...,xn).)The conventional textbook treatment of first-orderinterpretations assumes that relation symbols denote relations. Wewill modify this slightly to require that relation symbols denoteentities with an associated relation, called the relationalextension, and will sometimes abuse terminology by referring to theentities with relational extensions as relations. This device givesLbase some of the freedom to quantify over relationswhich would be familiar in a higher-order logic, while remainingstrictly a first-order language in its semantic and metatheoreticproperties. We will use the special nameRelation to denote the property of having a relationalextension.Let VV be the set of all variables, and NN be the set of allspecial names.We will assume that there is a globally fixed mapping SN from elementsof NN to a domain ISN (i.e, consisting of character strings and integers). Theexact specification of SN is given for numerals by the usual reading of a decimalnumeral to denote a natural number and for quoted strings by the dequotationrules described earlier.An interpretation I of a vocabulary V is then astructure defined by:a set ID, called the domain or universe of I;a mapping IS from (V union VV) into ID;a mapping IEXT from IR, a subset of ID, into a relation overID+ISN (ie a set of tuples of elements ofID+ISN).which satisfies the following conditions:for any n-ary function symbol f in V, IEXT(I(f)) is an n-aryfunction over ID+ISN.IEXT(I(NatNum)) = {<n>, n a natural number}IEXT(I(String)) = {<s>, s a character string}IEXT(I(Relation)) = IRAn interpretation then specifies the value of any otherLbase expression E according to the following rules:if E is:then I(E) is:a name or a variableIS(E)a special nameSN(E)a term f(t1,...,tn)the value of IEXT(I(f)) for the argumentsI(t1),...,I(tn)an equation (A=B)true if I(A)=I(B), otherwise falsea formula of the form R(t1,...,t2)true if IEXT(I(R)) contains the sequence<I(t1),...,I(tn)>, otherwise false(W1 and ...and Wn)true if I(Wi)=true for i=1 through n,otherwise false(W1 or ...or Wn)false if I(Wi)=false for i=1 through n,otherwise true(W1 <=> W2)true if I(W1)=I(W2), otherwise false(W1 => W2)false if I(W1)=true and I(W2)=false,otherwise truenot Wtrue if I(W)=false, otherwise falseIf B is a mapping from a set W of variables into ID, then define[I+B] to be the interpretation which is like I except that[I+B](?v)=B(?v) for any variable ?v in W.if E is:then I(E) is:(forall (?v1,...,?vn) W)false if [I+B](W)=false for somemapping B from {?v1,...,?vn} into ID, otherwise true(exist (?v1,...,?vn) W)true if [I+B](W)=true for somemapping B from {?v1,...,?vn} into ID, otherwise falseFinally, a knowledge base is considered to be true if and only ifall its elements are true, .i.e. to be a conjunction of itselements.Intuitively, the meaning of an expression containing freevariables is not well specified (it is formally specified, but theinterpretation of the free variables is arbitrary.) To resolve anyconfusion, we impose a familiar convention by which any freevariables in a sentence of a knowledge base are considered to beuniversally quantified at the top level of the expression in whichthey occur. (Equivalently, one could insist that all variables inany knowledge-base expression be bound by a quantifier in thatexpression; this would force the implicit quantification to be madeexplicit.)These definitions are quite conventional. The only unusualfeatures are the incorporation of special-name values into thedomain, the use of an explicit extension mapping, the fact thatrelations are not required to have a fixed arity, and thedescription of functions as a class of relations.The explicit extension mapping is a technical device to allowrelations to be applied to other relations without going outsidefirst-order expressivity. We note that while this allows the samename to be used in both an individual and a relation position, andin a sense gives relations (and hence functions) a 'first-class'status, it does not incorporate any comprehension principles ormake any logical assumptions about what relations are in thedomain. Notice that no special semantic conditions were invoked totreat variables in relation position differently from othervariables. In particular, the language makes no comprehensionassumptions whatever. The resulting language is first-order in allthe usual senses: it is compact and satisfies thedownward Skolem-Lowenheim property, for example, and theusual machine-oriented inference processes still apply, inparticular the unification algorithm. (One can obtain a translationinto a more conventional syntax by re-writing every atomic sentenceusing a rule of the form R(t1,...,tn) => Holds(R, t1,...,tn),where 'Holds' is a 'dummy' relation indicating that the relation Ris true of the remaining arguments. The presentation given hereeliminates the need for this artificial translation, but itsexistence establishes the first-order properties of the language.To translate a conventional first-order syntaxinto the Lbase form, simply qualify all quantifiers torange only over non-Relations. The issue is furtherdiscussed in (Hayes & Menzel ref). )Allowing relations with no fixed arity is a technicalconvenience which allows Lbase to accept more naturaltranslations from some SWELs. It makes no significant difference tothe metatheory of the formalism compared to a fixed-arity sytnaxwhere each relation has a given arity. Treating functions as aparticular kind of relation allows us to use a function symbol in arelation position (albeit with a fixed arity, which is one morethan its arity as a function); this enables some of thetranslations to be specified more efficiently.As noted earlier, incorporating special name interpretations (inparticular, integers) into the domain takes Lbaseoutside strict first-order compliance, but these domains havenatural recursive definitions and are in common use throughoutcomputer science. Mechanical inference systems typically havespecial-purpose reasoners which can effectively test forsatisfiability in these domains. Notice that the incorporation ofthese special domains into an interpretation does not automaticallyincorporate all truths of a full theory of such structures intoLbase; for example, the presence of the integers in thesemantic domain does not in itself require all truths of arithmeticto be valid or provable in Lbase.2.4 Axiom schemesAn axiom scheme stands for an infinite set of Lbasesentences all having a similar 'form'. We will allow schemes whichare like Lbase formulae except that expressions of theform "<exp1>...<expn>", ie twoexpressions of the same syntactic category separated by three dots,can be used, and such a schema is intended to stand for theinfinite knowledge base containing all the Lbaseformulae gotten by substituting some actual sequence of appropriateexpressions (terms or variables or formulae) for the expressionshown, which we call the Lbase instances of thescheme. (We have in fact been using this convention already, butinformally; now we are making it formal.) For example, thefollowing is an Lbase scheme:(forall(?v1...?vn)(R(?v1...?vn) impliesQ(a, ?v2...?vn)))- where the expression after the first quantifierclass="new">is an actual scheme expression, not a conventionalabbreviation - which has the following Lbaseinstances, among others:(forall (?x)(R(?x) implies Q(a, ?x)))(forall (?y,?yy,?z)(R(?y, ?yy, ?z) implies Q(a,?y,?yy,?z)))Axiom schemes do not take the language beyond first-order, sinceall the instances are first-order sentences and the language iscompact, so if any Lbase sentence follows from (theinfinite set of instances of) an axiom scheme, then it must in factbe entailed by some finite set of instances of that scheme.We note that Lbase schemes should be understood onlyas syntactic abbreviations for (infinite) sets of Lbasesentences when stating translation rules and specifying axiom sets.Since all Lbase expressions are required to be finite,one should not think of Lbase schemes as themselvesbeing sentences; for example as making assertions, as beinginstances or subexpressions of Lbase sentences, or asbeing posed as theorems to be proved. Such usages would go beyondthe first-order Lbase framework. (They amount to aconvention for using infinitary logic: see [Hayes& Menzel] fordetails.) This kind of restricted use of 'axiom schemes' isfamiliar in many textbook presentations of logic.2.5 EntailmentFollowing conventionalterminology, we say that I satisfies E if I(E)=true, andthat a set S of expressionsentails E if every interpretation which satisfies everymember of S also satisfies E. If the set S contains schemes,they are understood to stand for the infinite sets of all theirinstances. Entailment is the key idea which connectsmodel-theoretic semantics to real-world applications. As notedearlier, making an assertion amounts to claiming that the world isan interpretation which assigns the value true to the assertion. IfA entails B, then any interpretation that makes A true also makes Btrue, so that an assertion of A already contains the same "meaning"as an assertion of B; we could say that the meaning of B is somehowcontained in, or subsumed by, that of A. If A and B entail eachother, then they both "mean" the same thing, in the sense thatasserting either of them makes the same claim about the world. Theinterest of this observation arises most vividly when A and B aredifferent expressions, since then the relation of entailment isexactly the appropriate semantic licence to justify an applicationinferring or generating one of them from the other. Through thenotions of satisfaction, entailment and validity, formal semanticsgives a rigorous definition to a notion of "meaning" that can berelated directly to computable methods of determining whether ornot meaning is preserved by some transformation on a representationof knowledge.Any process or technique whichconstructs a well formed formula Foutput from some otherFinput is said to be valid if Finputentails Foutput, otherwise invalid. Notethat being an invalid process does not mean that the conclusion isfalse, and being valid does not guarantee truth. However, validityrepresents the best guarantee that any assertional language canoffer: if given true inputs, it will never draw a false conclusionfrom them.3.0 Using Lbase to define semanticsof a SWELImagine we have a Semantic Web Language Li. To provide asemantics for Li using Lbase, we mustprovide:a procedure for translating expressions in Li toexpressions in Lbase. This process will alsoconsequently define the subset of Lbase that is usedby Li.a set of vocabulary items introduced by Lia set of axioms and/or axiom schemas (expressed in Lbase orLbase schema) that capture the intended meanings of the termsin (2).Given a set of expressions G in Li, we apply the procedure aboveto obtain a set of equivalent well formed formulae in Lbase. We thenconjoin these with the axioms associated with the vocabulary introduced by Li(and any other language upon which Li is layered). If there are associatedaxiom schemata, we appropriately instantiate these and conjoin them to theseaxioms. The resulting set, referred to as A(G), is an axiomatic equivalentof G.There are several different 'styles' one could adopt for writing axiomaticequivalents. The most conservative amounts to simply transliterating the basicvocabulary of the SWEL into Lbase syntactic form, then relying onthe axioms to determine their meaning. In cases where the axioms amount to an'iff' definition of the vocabulary item, however, this could be shortened bytranslating the SWEL vocabulary into the defined form directly, resulting ina simpler translation. For example, in giving an axiomatic equivalent for OWL-DL,the meaning of rdfs:subClassOf can be captured adequately by translatingit directly into the form of a logical implication:aaa rdfs:subClassOf bbb =(translates into)=> (forall(?x) (aaa(?x) implies bbb(?x) ))This direct translation removes 'rdfs:subClassOf' from the theaxiomatic equivalent altogether, however, so makes it impossible to expressother RDFS truths about the rdfs:subClassOf property. This wouldbe acceptable if we were concerned only with OWL-DL, which imposes a syntacticrestriction which forbids such propositions; but it is not acceptable when wewish to relate different SWELs to one another, which is the primary goal here.We therefore focus on the 'conservative' style of translation where the burdenof expressing the meaning of the SWEL vocabulary falls largely on the axioms.As an illustrative example, we give in the following table a sketchof the axiomatic equivalent for RDF graphs using the RDF(S) and OWL vocabularies,in the form of a translation from N-triples. Note, this should not bereferred to as an accurate or normative semantic description. RDF expression ELbase expression TR[E]a plain literal "sss"'sss' , with any internal occurrences of ''' prefixed with '\'a plain literal "sss"@tttthe term pair('sss','ttt')a typed literal "sss"^^dddthe term LiteralValueOf('sss',TR[ddd])an RDF container membership property name of the form rdf:_nnnrdf-member(nnn)any other URI reference aaaaaa or <aaa>a blank nodea variable (one distinct variable per blank node)a tripleaaa rdf:type bbb .TR[bbb](TR[aaa]) and rdfs:Class(TR[bbb])any other tripleaaa bbb ccc .TR[bbb](TR[aaa] TR[ccc])and rdf:Property(TR[bbb])an RDF graphThe existential closure of the conjunction of the translations of allthe triples in the graph.a set of RDF graphsThe conjunction of the translations of all the graphs.RDF axiomsrdf:type(?x ?y) implies ?y(?x)rdf:Property(rdf:type)rdf:Property(rdf:subject)rdf:Property(rdf:predicate)rdf:Property(rdf:object)rdf:Property(rdf:first)rdf:Property(rdf:rest)rdf:Property(rdf:value)rdf:List(rdf:nil)NatNumber(?x) implies rdf:Property(rdf-member(?x))pair(?x ?y)=pair(?u ?v) iff (?x=?u and ?y=?v) ;; uniquenessfor pairs, required by graph syntax rules.RDFS axiomsrdfs:Resource(?x) rdfs:Class(?y)implies (?y(?x) iff rdf:type(?x ?y))rdfs:range(?x ?y) implies ( ?x(?u ?v)) implies ?y(?v) )rdfs:domain(?x ?y) implies ( ?x(?u ?v)) implies ?y(?u) )rdfs:subClassOf(?x ?y)implies  (rdfs:Class(?x) and rdfs:Class(?y) and (forall (?u)(?x(?u)implies ?y(?u)))rdfs:Class(?x) implies ( rdfs:subClassOf(?x ?x) and rdfs:subClassOf(?xrdfs:Resource) )( rdfs:subClassOf(?x ?y) and rdfs:subClassOf(?y ?z) ) implies rdfs:subClassOf(?x?z)rdfs:subPropertyOf(?x,?y) implies  (rdf:Property(?x) and rdf:Property(?y) and (forall (?u ?v)(?x(?u?v) implies ?y(?u ?v)))rdf:Property(?x) implies rdfs:subPropertyOf(?x ?x)( rdfs:subPropertyOf(?x ?y) and rdfs:subPropertyOf(?y ?z) ) impliesrdfs:subPropertyOf(?x ?z)rdfs:ContainerMembershipProperty(?x) implies rdfs:subPropertyOf(?xrdfs:member)rdf:XMLLiteral(?x) implies rdfs:Literal(?x)String(?y) implies rdfs:Literal(?y)(String(?x) and LanguageTag(?y)) implies rdfs:Literal(pair(?x,?y))rdfs:Datatype(?x) implies (?x(?y) implies rdfs:Literal(?y) )NatNumber(?x) implies(rdfs:ContainerMembershipProperty(rdf-member(?x)) andrdfs:domain(rdf-member(?x) rdfs:Resource) andrdfs:range(rdf-member(?x) rdfs:Resource) )rdfs:Class(rdfs:Resource)rdfs:Class(rdf:Property)rdfs:Class(rdfs:Class)rdfs:Class(rdfs:Datatype)rdfs:Class(rdf:Seq)rdfs:Class(rdf:Bag)rdfs:Class(rdf:Alt)rdfs:Class(rdfs:Container)rdfs:Class(rdf:List)rdfs:Class(rdfs:ContainerMembershipProperty)rdfs:Class(rdf:Statement)rdf:Property(rdfs:domain)rdf:Property(rdfs:range)rdf:Property(rdfs:subClassOf)rdf:Property(rdfs:subPropertyOf)rdf:Property(rdfs:comment)rdf:Property(rdfs:seeAlso)rdf:Property(rdfs:isDefinedBy)rdf:Property(rdfs:label);; the rest of the axioms are direct transcriptions of theRDFS axiomatic triples,using the RDF to Lbase transcription rules:rdfs:domain(rdf:type rdfs:Resource)rdfs:domain(rdfs:domain rdf:Property)rdfs:domain(rdfs:range rdf:Property)rdfs:domain(rdfs:subPropertyOf,rdf:Property)rdfs:domain(rdfs:subClassOf rdfs:Class)rdfs:domain(rdf:subject rdf:Statement)rdfs:domain(rdf:predicate rdf:Statement)rdfs:domain(rdf:object rdf:Statement)rdfs:domain(rdf:member rdfs:Resource)rdfs:domain(rdf:first rdf:List)rdfs:domain(rdf:rest rdf:List)rdfs:domain(rdfs:seeAlso rdfs:Resource)rdfs:domain(rdfs:isDefinedBy rdfs:Resource)rdfs:domain(rdfs:comment rdfs:Resource)rdfs:domain(rdfs:label rdfs:Resource)rdfs:domain(rdfs:value rdfs:Resource)rdfs:range(rdf:type rdfs:Class)rdfs:range(rdfs:domain rdfs:Class)rdfs:range(rdfs:range rdfs:Class)rdfs:range(rdfs:subPropertyOf rdf:Property)rdfs:range(rdfs:subClassOf rdfs:Class)rdfs:range(rdf:subject rdfs:Resource)rdfs:range(rdf:predicate rdfs:Resource)rdfs:range(rdf:object rdfs:Resource)rdfs:range(rdf:member rdfs:Resource)rdfs:range(rdf:first rdfs:Resource)rdfs:range(rdf:rest rdf:List)rdfs:range(rdfs:seeAlso rdfs:Resource)rdfs:range(rdfs:isDefinedBy rdfs:Resource)rdfs:range(rdfs:comment rdfs:Literal)rdfs:range(rdfs:label rdfs:Literal)rdfs:range(rdfs:value rdfs:Resource)rdfs:subClassOf(rdf:Alt rdfs:Container)rdfs:subClassOf(rdf:Bag rdfs:Container)rdfs:subClassOf(rdf:Seq rdfs:Container)rdfs:subClassOf(rdfs:ContainerMembershipProperty rdf:Property)rdfs:subPropertyOf(rdfs:isDefinedBy rdfs:seeAlso)rdfs:Datatype(rdf:XMLLiteral)rdfs:subClassOf(rdfs:Datatype rdfs:Class)RDF Datatyped Literal axiomsrdfs:Literal(LiteralValueOf(?x ?y)) iff ?y(LiteralValueOf(?x ?y))rdfs:Datatype(?y) implies rdfs:Class(?y)rdfs:Datatype(?y) implies (exists (?x) ?y(?x) )In addition, for each datatype named ddd , one needs a datatype theoryconsisting of all axioms of the following form, or the equivalent:rdfs:Datatype(ddd)ddd(LiteralValueOf('aaa' ddd)) where aaais a legal lexical form for the datatypenot ddd(LiteralValueOf('aaa' ddd)) where aaais any string which is not a legal lexical form for the datatype.If there is some notational framework in (or added to) Lbase whichenables one to write terms denoting the members of the value space of the datatype,then the database theory can also contain all true axioms of the formLiteralValueOf('aaa' ddd) = [L2V(ddd,aaa)]where the square brackets indicate the presence of the appropriate term forthat value. For example, using decimal numerals to denote the integers, thiscould be all equations of the formLiteralValueOf('345' xsd:integer) = 345Such axioms, or equivalents, would be needed in order to connect the translationto other theories which used the more conventional notations.In some cases, a datatype theory can be summarized in a finite number of axioms.For example, the datatype theory for xsd:stringcan be stated by a single axiom:(String(?x) iff xsd:string(?x) ) and (String(?x)implies LiteralValueOf(?x xsd:string) = ?x ) 3.1 Relation between the two kindsof semanticsGiven a SWEL Li, we can provide a semantics for it either by providingit with a model or by mapping it into Lbase and utilizing the modeltheory associated with Lbase. Given a set of expressions G in Li andits axiomatic equivalent in Lbase A(G), any Lbase interpretationof A(G) defines an Li interpetation for G. The natural Li interpretation fromits own model theory will in general be simpler than the Lbase interpretation:for example, interpretations of RDF will not make use of the universal quantification,negation or disjunction rules, and the underlying structures need have no functionalrelations. In general, therefore, the most 'natural' semantics for Liwill be obtained by simply ignoring some aspects of the Lbase interpretationof A(G). (In category-theoretic terms, it will be the result of applying an appropriateforgetful functor to the Lbase structure.) Nevertheless, this extrastructure is harmless, since it does not affect entailment in Li consideredin isolation; and it may be useful, since it provides a natural way to defineconsistency across several SWELs at the same time, and to define entailment fromKBs which express content in different, or even in mixed, SWELs simultaneously.For these reasons we propose to adopt it as a convention that the appropriatenotion of satisfaction for any SWEL expression G is in fact defined relative toan Lbase interpretation of A(G).The following diagram illustrates the relation between Li, Lbase,G and interpretations of G according to the different model theories.width="433" height="385" />The important point to note about the above diagram is that if the Lito Lbase mapping and model theory for Li are done consistently,then the two 'routes' from G to a satisfying interpretation will be equivalent.This is because the Li axioms included in the Lbase equivalentof G should be sufficient to guarantee that any satisfying interpretation inthe Lbase model theory of the Lbase equivalent of G willcontain a substructure which is a satisfying interpretation of G according tothe Li model theory, and vice versa.The utility of this framework for combining assertions inseveral different SWELs is illustrated by the following diagram,which is an 'overlay' of two copies of the previous diagram.alt="Interpreting SWELs in combination" width="535"height="367" />Note that the G1+G2 equivalent in this case contains axioms forboth languages, ensuring (if all is done properly) that anyLbase interpretation will contain appropriatesubstructures for both sentences.If the translations into Lbase are appropriatelydefined at a sufficient level of detail, then even tighter semanticintegration could be achieved, where expressions which 'mix'vocabulary from several SWELs could be given a coherentinterpretation which satisfies the semantic conditions of bothlanguages. This will be possible only when the SWELS have aparticularly close relationship, however. In the particular casewhere one SWEL (the one used by G2) is layered on top of another(the one used by G1), the interpretations of G2 will be a subset ofthose of G14.0 Inadequacies ofLbaseThe Lbase described above has several deficiencies as abase system for the Semantic Web. In particular,It does not capture the social meaning of URIs. It merelytreats them as opaque symbols. A future web logic should gofurther towards capturing this intention.At the moment, Lbase does not provide anyfacilities related to the representation of time and change.However, many existing techniques for temporal representation uselanguages similar to Lbase in expressive power, and weare optimistic that Lbase can provide a usefulframework in which to experiment with temporal ontologies for Webuse.It might turn out that some aspects of what we want torepresent on the the semantic web requires more than can beexpressed using the Lbase described in this document.In particular, Lbase does not provide a mechanism forexpressing propositional attitudes or true second orderconstructs.A future version of Lbase, which includes the aboveLbase as a proper subset, might have to include suchfacilities.5.0 AcknowledgementsWe would like to thank members of the RDF Core working group, Tim Berners-Lee,Richard Fikes, Sandro Hawke, Jim Hendler and Peter Patel-Schneider for commentson various versions of this document.6.0 References[Enderton]A Mathematical Introduction to Logic, H.B.Enderton,2nd edition, 2001, Harcourt/Academic Press.[Fikes & McGuinness]R. Fikes, D. L. McGuinness,href="http://www.ksl.Stanford.EDU/people/dlm/daml-semantics/abstract-axiomatic-semantics.html">An Axiomatic Semantics for RDF, RDF Schema, and DAML+OIL, KSLTechnical Report KSL-01-01, 2001[Hayes & Menzel]P. Hayes, C. Menzel,href="http://reliant.teknowledge.com/IJCAI01/HayesMenzel-SKIF-IJCAI2001.pdf">A Semantics for the Knowledge Interchange Format , 6 August2001 (Proceedings of 2001href="http://reliant.teknowledge.com/IJCAI01/">Workshop on theIEEE Standard Upper Ontology)[OWL]WebOntology Language (OWL) Reference Version 1.0, Mike Dean, DanConnolly, Frank van Harmelen, James Hendler, Ian Horrocks,Deborah L. McGuinness, Peter F. Patel-Schneider, and Lynn AndreaStein. W3C Working Draft 12 November 2002.href="http://www.w3.org/TR/2002/WD-owl-ref-20021112/">Thisversion is http://www.w3.org/TR/2002/WD-owl-ref-20021112/ .Latest version is available athref="http://www.w3.org/TR/owl-ref/">http://www.w3.org/TR/owl-ref/.[Marchiori & Saarela]M. Marchioi, J. Saarela,href="http://www.w3.org/TandS/QL/QL98/pp/metalog.html">Query +Metadata + Logic = Metalog, 1998name="ref-rdf-concepts">[RDF-CONCEPTS]href="http://www.w3.org/TR/2003/WD-rdf-concepts-20031010/">ResourceDescription Framework (RDF): Concepts and AbstractSyntax, Klyne G., Carroll J. (Editors), World Wide WebConsortium Working Draft, 10 October 2003 (work in progress).href="http://www.w3.org/TR/2003/WD-rdf-concepts-20031010/">Thisversion ishttp://www.w3.org/TR/2003/WD-rdf-concepts-20031010/. Thehref="http://www.w3.org/TR/rdf-concepts/">latest version ishttp://www.w3.org/TR/rdf-concepts/name="ref-rdf-syntax">[RDF-SYNTAX]href="http://www.w3.org/TR/2003/WD-rdf-syntax-grammar-20031010/">RDF/XMLSyntax Specification (Revised), Beckett D. (Editor),World Wide Web Consortium Working Draft, 10 October 2003 (work inprogress).href="http://www.w3.org/TR/2003/WD-rdf-syntax-grammar-20031010/">Thisversion ishttp://www.w3.org/TR/2003/WD-rdf-syntax-grammar-20031010/. Thehref="http://www.w3.org/TR/rdf-syntax-grammar/">latestversion is http://www.w3.org/TR/rdf-syntax-grammar/id="ref-rdf-semantics"name="ref-rdf-semantics">[RDF-SEMANTICS]href="http://www.w3.org/TR/2003/WD-rdf-mt-20031010/">RDFSemantics, Hayes P. (Editor), World Wide WebConsortium Working Draft, 10 October 2003 (work in progress).href="http://www.w3.org/TR/2003/WD-rdf-mt-20031010/">Thisversion is http://www.w3.org/TR/2003/WD-rdf-mt-20031010/. Thelatest version ishttp://www.w3.org/TR/rdf-mt/name="ref-rdf-tests">[RDF-TESTS]href="http://www.w3.org/TR/2003/WD-rdf-testcases-20031010/">RDF Test Cases,Grant J., Beckett D. (Editors) World Wide Web Consortium Working Draft, 5September 2003 (work in progress).href="http://www.w3.org/TR/2003/WD-rdf-testcases-20031010/">This versionis http://www.w3.org/TR/2003/WD-rdf-testcases-20031010/. Thehref="http://www.w3.org/TR/rdf-testcases/">latest version is http://www.w3.org/TR/rdf-testcases/.[RDFMS]href="http://www.w3.org/TR/1999/REC-rdf-syntax-19990222/">ResourceDescription Framework (RDF) Model and Syntax, W3CRecommendation, 22 February 1999href="http://www.w3.org/TR/1999/REC-rdf-syntax-19990222/">http://www.w3.org/TR/1999/REC-rdf-syntax-19990222/name="ref-rdf-primer">[RDF-PRIMER]href="http://www.w3.org/TR/2003/WD-rdf-primer-20031010/">RDF Primer,Manola F., Miller E. (Editors), World Wide Web Consortium Working Draft, 5September 2003 (work in progress).href="http://www.w3.org/TR/2003/WD-rdf-primer-20031010/">This versionis http://www.w3.org/TR/2003/WD-rdf-primer-20031010/. The latestversion is http://www.w3.org/TR/rdf-primer/name="RDFSRef" id="RDFSRef">[RDF-VOCABULARY]href="http://www.w3.org/TR/2003/WD-rdf-schema-20031010/">RDF VocabularyDescription Language 1.0: RDF Schema, Brickley D., Guha R.V. (Editors),World Wide Web Consortium, November 2002. Consortium Working Draft, 10 October2003 (work in progress).href="http://www.w3.org/TR/2003/WD-rdf-schema-20031010/">This versionis http://www.w3.org/TR/2003/WD-rdf-schema-20031010/. The latestversion is http://www.w3.org/TR/rdf-schema/[URI]T. Berners-Lee, Fielding and Masinter,href="http://www.isi.edu/in-notes/rfc2396.txt">RFC 2396 - UniformResource Identifiers (URI): Generic Syntax, August 1998.[WebOnt]The Web OntologyWorking Group[XML]T. Bray, J. Paoli, C.M. Sperberg.McQueen, E. Maler.href="http://www.w3.org/TR/REC-xml">Extensible Markup Language(XML) 1.0 (Second Edition), W3C Recommendation 6 October20007. Change LogSince the version of 23 January, the definition of quoted stringshas been modified to simplify character escaping; the syntax allowing namesto be enclosed in < > introduced; and the 'XMLThing' category of specialnames deleted; it was underspecifed and not necessary. Several minor editorialchanges have been made throughout the document (heading numbers corrected, etc.). The example translation of RDF/RDFS has been updated so as to conform to thedescription given in the RDF Semantics document, and the discussion of axiomaticequivalents expanded.Thanks to Peter Patel-Schneider for critical comments on theearlier version.