The ILU Requestor for HTTP serversALT="W3C:" SRC="http://www.w3.org/pub/WWW/Icons/WWW/w3c_home.gif">WD-ilu-requestor-960307The ILU Requester: Object Services in HTTP ServersW3C Informational Draft 07-Mar-96This version:http://www.w3.org/pub/WWW/TR/WD-ilu-requestor-960307Latest version:http://www.w3.org/pub/WWW/TR/WD-ilu-requestorAuthors:Paul Everitt, Digital Creations<paul@digicool.com>Status of this documentThis document provides information for the W3C members and otherinterestedcommunity. This document does not specify a W3C standard of any kind.Feedback should be directed to the author.A list of current W3C documents can be found at:href="http://www.w3.org/pub/WWW/TR">http://www.w3.org/pub/WWW/TRAbstractTheCommon Gateway Interface(CGI) is not scaling to meet the requirementsof today's dynamic, interactive webs. For this reason, multiple vendors haveproposed C callable APIs. These APIs allow authors to alleviate the performancepenalty of CGI, and allow tighter integration of add-in modules. Unfortunately,this comes at the price of complexity and portability.This document describes a new model for extending WWW servers. First, HTTPis captured using aninterfacespecification,which eliminates the ambiguities of interpretating a standards-track document.This interface is then implemented atop a particular httpd's API. Finally,allof this is done using a standard distributed object model calledILU.Digital Creations' work on ourILURequester reflectsthis design and shows its advantages. This paper describes the ILU Requester.Table of ContentsIntroductionRequirements for a Requester architectureDetailed DescriptionCurrent Status of ImplementationExamples of InterfacesPerformance AnalysisOutstanding IssuesFuture PlansAlternativesReferencesAppendicesAuthor's InfoIntroductionApplications deployed over the World-Wide Web often involve an HTTPserver integrated with a legacy information system, or a custom informationsystem. The Common Gateway Interface, or CGI, is the most widely deployedmechanism for integrating HTTP servers with other information systems, butstudies have shown thatits design does not scale to the performance demands of contemporaryapplications.Microsoft states that applications for their API arefive times fasterthanCGI applications.Moreover, CGI applications do not run in the httpd process. In additiontothe performance penalty, this means that CGI applications cannot modifiythebehavior of the httpd's internal operations, such as logging and authorization.Finally, CGI is viewed as asecurity issuebysome server operators, due to its connection to a user-level shell.A current solution is to use an httpd with an API, such asApache 1.x orNetscape.By using the API, you havea performance increase and a load decrease by running your application inthehttpd process, rather than starting a new process for every request. Also,theAPI exposes some of the httpd's own behavior, allowing you to modify itsoperation. In fact, servers like Apache implement large portions of theirfunctionality, such as ISMAP handling and logging, asmodules.Unfortunately, the API benefits come at a price. Running a user-writtenmoduleinside the httpd process leads to possible reliability concerns. For instance,when developing our requesters, early code would regularly lead to core dumpsfromunhandled errors, as well as memory leaks. Also, most current servers useeithermultiple pre-forked subprocesses or separate threads for each new request.Thus,applications which change state, such as a simple counter script, have dataconcurrency issues that are the burden of the programmer to solve.Most importantly, the API route eliminates the casual CGI programmer. Ina recentsurvey, Perl beat C 4 to 1 with 46% of the total votes. It appearsthat the possibilities for language-choice in a C-based API mechanism arerestrictive.Finally, the portability of CGI applications from one httpd implementationto another, would be lost with an API strategy. Since each API has a differentsyntax, authors would be forced to know each API beforehand. Thus, APIscouldbecome instruments used by vendors to ensure market retention.The elimination of scripting by an API strategy is a serious issue. Webservices are usually built using scripting languages such as Perl, Python,Tcl, Visual Basic, Rexx, etc. This seems to be the case because web appsarefrequently:quick and dirtycomplex in their data relationshipsshort-livedwritten by casual programmersIn essence, the genre of CGI applications are usually complex enough to usetoolsgood for rapid prototyping, but which rarely get past the prototype stageandinto C.To address this next generation of server-extending, we developed a mechanismbased on a uniform interface specification for HTTP. This is theHTTP.isl. By basing our extension mechanismona distributed object protocol like ILU, we get the performance and featuresofan API strategy (as shown below), with the portability and simplicity ofCGI.Moreover, it permits the httpd to be extended not only out of its addressspace,but off its machine, and thus into capabilities available only on a remotenode.This is in the true client-server fashion.We call this extension mechanism the ILU Requester.ILU Requester in a NutshellPerformance of APIFeatures of APIPortability of CGISimplicity of CGIBridge into distributed objectsRequirements for a Requester strategyWe have listed the problems with the current CGI/API situation. Andwe have described an ILU Requester architecture. What are its requirements,and what are some preferred possibilities?Requirementsportable across platforms and vendorsbased on well-understood industry standardsinfrastructure uses freely-available, high-quality code baseactive and sustainable developmentwide choice of language (i.e. not language-based)significant performance winscaleable to N clients and N serversnon-blocking on threaded serversPreferencesconfigurable servers (e.g. adding methods to HTTP, and implementingthem yourself to erase bugs)designed for an eventual absorption into the server's code base asa common encapsulationdesigned also for an eventually-encapsulated browser which has an objectruntime available for messagingsome standard interfaces, such as a site catalogue, authorizer, logger,gatherer, brokerDetailed DescriptionWe have implemented the ILU Requester for several platforms, and have extendeddevelopment to include other interested parties. First, we will give somebackground, and then a description.BackgroundIn December of 1994, we were tasked with developing a complex WWW service.This service necessitated a dynamic language, and had state. Yet, we wereforced to use CGI. Thus, we made a first implementation using a long-runningprocess that managed the state using a dynamic language(Python), and asmall "controller" script that would message it on each hit.Over time, we found that we were inventing our own client/server protocol.For this and other reasons, we started looking at using ILU to manageinteractionsbetween processes. Thus, the CGI script got a surrogate reference to anencapsulation of the stateful system.Still, we had the performance penalty of CGI. In April of 1995, we wrotea patch for Apache 0.6.5 that embedded the ILU runtime. With this,we had access to objects via registered URL constructs. This served severalproduction systems into the fall. At this point, we started to refer tothis embedded ILU module as the requester.In August, a version of Apache was released that had an API, so we startedreworking the requester to use it. By October we had a related requesterfor Netsite working on Unix and partially on NT. In December, based on anew draftof the HTTP spec, we consolidated the two feature sets, and wrote an HTTPISL that was comprehensive with respect to the new specification. Also,we started work with ILU 2.0.In January of this year, we started standardizing on a Python "framework"modulefor creating our online services. For this, we developed an ISL for installingobject-based Authorizers and Loggers "into" the httpd.Case Study: BroadcastAlso in January, we released our first major product based on this architecturecalled Broadcast.This isa Web-based chat application that had one primary goal: it should be veryfastunder very highly-loaded conditions. Some design choices were:Perl-based CGIThe product that ours was replacing started in life as a perl-based chat.It becamevery popular, or at least popular enough that many simultaneous users wouldloadthe system up too much. This suffered from the startup cost of an interpreter,thecost of reading the state in from disk, and from design issues for multipleprocesseschanging the state.C-based CGISame as the above, but moved to C. Still faced with the problems of stateand concurrency.CGI-based requester-daemon serviceOne choice for solving the problem of state would be to have a long-runningserver process that managed the state of the chat, and have skinny requestersthatmessage the chat server from CGI over a socket. This design solves the problemofreincarnating state for each request. Also, it provides a DBMS-like functionformodifying the state, since everything goes through one process.However, there is still the cost of starting up a CGI requester on each hit,andthe socket create/teardown issue. Also, you have invented a nice littleclient-serversystem that speaks your protocol, but no other. Plus, this protocol hasto be interpretedon the wire, using your custom parser. Finally, the chat daemon must beequipped with concurrency, or else it becomes a bottleneck.RPC serviceA more elegant version of the chat daemon strategy might be to use RPC tothechat server, either from a CGI requester or an API-based requester. Thiswould replaceyour custom protocol, and would allow an API-based requester to keep connectionsopen.On the other hand, you have produced a system that is procedure-oriented,rather thanobject-oriented.We chose to use an ILU Requester that would make generic calls on publishedobjectsthat represented the chat site's components. This allowed us to have verylow latency(by avoiding startup costs), and expose the OO design of the chat implementation.It appears that the design choice was valid. Performance is fantastic, andload islow. Also, using the requester strategy, we now have many new possibilitesforapplication partitioning. Finally, using our APIScriptinginfrastructure, we are able to add new features in a very coherent fashion.DescriptionAs alluded to above, the entire system is based around ILU. From this,we get language-independence, cross-process communication, andplatform-independence.The goal is to add an abstract object interface to an httpd in a uniformway. For this, we wrote an interface for HTTP that encapsulates the behaviorof the HTTP transaction. We then implement this interface in C by mappingit to the semantics of a particular httpd's API. This implementation iscalled the requester, and gives an httpd a mechanism for passingcertain incoming requests to an ILU published object.This architecture mimics the interaction between the browser and thehttpd using the same concepts as HTTP. For instance, the informationcontained in the request is mapped into a Request type in the interfacespecification. The requested object is a Resource, and the result ofthe operation on the Resource is a Response. Both of the Request andResponse are types defined in the interface.Fortunately, because of the uniform, abstract ISL, the services you writedo not have to know anything about the semantics of the server or its API.In fact, it would be possible to skip the httpd altogether, and communicatedirectly with the published object. The objects could do this: they canhave multiple representations, and can communicate via HTTP requests, ILUrequests, or some other request structure.When writing a service, therefore, all you have to do is publish anobject that is based on the skeleton code generated from the interface.Pretty standard stuff here. Then, if the published object is listed inthe httpd's configuration file, incoming requests matching a certain URIform will be sent to the requester, which will make an ILU call tothe published object.Also, it is possible to map the requester to remotely-published objectsusing ILU's String Binding Handle mechanism. This makes it possible tobridge the httpd into services available on other platforms. Future ILUmechanisms will make this process easier.Current Status of ImplementationAs of this writing, we have solid requesters based on ILU 1.8 and 2.0 forNetsite (Unix) and Apache. They have been tested by others, reviewed foroptimizations, passed through simple memory leak testers, and documented.We are making distributions freely available in source, and some in binaryform.Currently, the requesters are known to work fine on Solaris, Digital Unix,Linux, AIX, and BSDI. Additionally, we have preliminary support for NT.Full support is waiting for us to finish up our work on threading withILU. Finally, ILU has been reported to work on OS/2, and there is work onand Apache implementation for that platform.The threading issue will become increasingly important as we build moresophisticated systems, especially when we might want to have a commonORB. However, for systems such as Netsite and Microsoft's IIS on NT,as well as Spyglass' server, it is required in the requester.This is because these platforms service each incoming request as a thread,rather than passing the request to an isolated process. Thread-safeing therequester is thus becoming a requirement.We have just added support for aliasing multiply-published objectsinside the requester. For instance, you could make a request to info@system,and have "system map" to one of several published objects. This is mainlyfora performance increase in read-only situations. Note that this may besubsumed by the ILU work on multicast.Another area we are working on is making the object systems easierto use. We have just added an HTTP header that gets returned, stating theILUversion and requester version. We are adding support for a discoverableinterface,using a standard 'info@root' that is built in to every requester. This objectwillreturn catalogue information from config file directives, and will attempttocontact the ILU servers listed in the config file and get their 'info@root'information, if implemented.API ScriptingMaking an httpd able to call distributed objects is only half of thesystem: you must have objects that can be called.We have intended for this system to replace CGI as a server-extensionmechanism. To do this, it must be nearly as easy to create services as CGIis currently. For this, we have been working on an infrastructure forpublishing requester-capable objects called API Scripting.For creating services, we are focusing on Python, and building up atoolset to of components. We have made parts of this toolset available,and have released our demonstration programs and load testing modules.Based on this Python toolset and the requester, we are fielding high-performanceInternet services for commercial use.For instance, here is a very simple script in Python that publishes anobject which echoes the contents of a request:#!/usr/local/bin/python"""Every good module deserves docstrings.This is a very simple script that subclasses a Resource, fills in theblanks, and echoes incoming Requests. It then publishes the object andgoes into a main loop."""import iluimport wwworb # our toolsetclass ILUforDummies(wwworb.Resource):def GET(self,request,connect):request = wwworb.Request(request)response = wwworb.Response(`request`)return responsePOST = GET# Create an ILU serverilu.CreateServer('paul.demos')# Now, create an instance of your class, passing it a parameter# for the name of the published object.nitwit = ILUforDummies('dumb')print nitwit.IluSBH()ilu.RunMainLoop()Note that there are really only nine necessary lines in the above. Thisshould put it into the realm of CGI for ease of use.Our next step is to make highly-concurrent systems available in Python. To dothis, we are working with the ILU team to thread the iluPrmodule. This workis related to the work on threading the ILU kernel.For all of these, we have an emerging development group, and an infrastructurefor documentation, tutorials, bug reports, etc.Examples of InterfacesCurrently, we have stabilized ourHTTP interface, and feel that it accuratelyrepresents the interaction between a browser and a client in a way usefulfor published objects behind an httpd. Therefore, we are now focusing onproblem-specific interfaces.First, we would like to have a discoverable interface for online services.For instance, one should be able to go to any requester-enabled site, sendarequest to an info@root published object, and get an inventory ofthatsite. The contents of this inventory might vary, might support a set of minimumoperations, might extend, and might change. All the things that aninterfaceallows you to do over time.This discoverable interface is being worked on. There are other interfacesthat have already rolled out.The Authorizer ISLMost of our "API scripting" services involve persistent Python objectsthat receive requests from the ILU main loop. Some of these services needsome type of Access Control List (ACL) mechanism on them. However, wereally don't want to interface into some external, httpd-controlled,single-filesystem-based password file.The API-based servers have modules already that allow you storeuser authentication information in a SQL table. Yet, we already haveusers defined in our object system. Moreover, we might want to have someinstance-based authorization mechanism.To extend the ACL-capabilities of the httpd, we wrote an Authorizerinterface, and implemented it into the APIs we support. Thus, accesses toprotected URIs are mapped to an object call, which determines if thatoperation is allowed by that identity.The Logger ISLAnother area we wanted to standardize on was an intelligent loggingmechanism. Currently, there is the Common Log File format for writing todisk. However, we wanted something more structured and more dynamic. Thus,we wrote an interface for logging, mapped it into the httpd's API functions,and created an installable logging facility. A smart implementation couldpublish an object which is registered for successful or unsuccessful requeststo document or ILU-based requests. If there is an error, you could decidewhether send a page to someone's beeper. For all requests, you can takethe incoming data structure, and write parts of it into a miniSQL table.We wanted to extend the httpd's logging facilities in new and interestingways. For instance, we wanted to do processing and take special actions ifan error was raised. Also, we wanted to investigate logging from a Unixhttpd into a Windows-based personal DBMS like Microsoft Access.To do this, we made an interface for loggging, and implemented it on theAPIs we support. This mapping forces the httpd to run our object call duringlogging events. The interface is very simple; it justsends the Request object to LoggerObject via an asynchronous method. Onecould then subtype from there to do more interesting, platform-specificthings.The Stanford Digital Library Common Object ServicesThe Stanford Digital Library team has produced interfaces and implementationsfor CORBA-typeCommon Object Services (COS). Common Object Services are objects or groupsofobjects that provide the basic requirements which most objects need in ordertofunction in a distributed environment. These services are designed to begeneric;they do not depend on the type of client object or type of data passed. Note:thisis hard to do in ILU since there is no concept of the Object or Any type.Other InterfacesThere are other good candidates for interfaces. For instance, the Harvestsystem has its own protocol for collecting indexing information, and doingsearches. If an interface was written, it could perhaps be moved into thisarchitecture.We have started on some other standard interfaces, such as a Data Accessinterface and a an OLE interface (via Python). These, though, are not necessarilyrelated to the ILU Requester, and are thus outside the scope of this paper.Performance AnalysisIt should be apparent that the architecture lends itself to good performance.However, we felt that some performance numbers were important, so we cameupwith a performance-testing program, and a regimen to exercise it.To test, I used a Sparc 5 running Solaris 2.4 with 32 Mb as the testing client,and an Alpha with 64 Mb running Digital Unix as the testing server. The testprogram was written in Python, and used the httplib and thread modules tomakeconcurrent requests. The server was running Netsite, using our requesterand ILU 2.0.We had Netsite configured to use up to 32 processes.We then ran through a series or URLs (listed below) in a series of two tests:alatency test and a throughput test. The latency test sent a series of requestson onethread, to test the response time. The throughput test dispatched the samenumber ofrequests on several simultaneous threads, to test concurrent use. Thus, thethroughput test attempted to detail the affects of load, concurrency, andaggregate response time for a batch of requests.For the URIs, the index.html test merely retrieved a very short HTML file.Theothers were:simple.sh---------#!/bin/shecho 'Content-type: text/html\n\n'echo Hello.simple.pl---------#!/usr/local/bin/perlprint "Content-type: text/html\n\n";print "hello.";simple.py---------#!/usr/users/paul/cgipython"""Simple script to echo the dictionary back."""print 'Content-type: text/html\n\n'print 'Hello.'simple1.py----------#!/usr/users/paul/cgipython"""\Simple script to echo the dictionary back."""print 'Content-type: text/html\n\n'import simple_libsimple_lib.py-------------#!/usr/users/paul/cgipython"""\Simple script to echo the dictionary back."""import cgif = cgi.SvFormContentDict()print f.items()dumb.py-------# Note: echo is equivalent to simple.py, and dumb is equivalent to simple1.py"""\The simplest, dumbest API script around.This Python program has one goal: fewest lines for an interactive script.The script reads the form variables, and sends them back, without very muchformatting.Note that we have embedded the HTML into the class, which has added somecharacters. Normally this class would be even shorter, as we would use the"pyhtml" external representation. But, that would be smart, and this one is,well, dumb."""import syssys.path.append('wwworb')sys.path.append('interfaces')import string, ilu, wwworbprint ilu.Version# Make a class derived from the Resource class in wwworb. Remember# that the base class (wwworb.Resource) requires a parameter to be# passed to its __init__ startup call. This parameter is the name# of the published object.class EchoforDummies(wwworb.Resource):def GET(self,request,connect):return wwworb.Response('Hello.')POST = GETclass ILUforDummies(wwworb.Resource):def GET(self,request,connect):request = wwworb.Request(request)response = wwworb.Response(`request`)return responsePOST = GET# Create an ILU serverilu.CreateServer('paul.demos')# Now, create an instance of your class, passing it a parameter# for the name of the published object.nitwit = ILUforDummies('dumb')echo = EchoforDummies('echo')print nitwit.IluSBH()print echo.IluSBH()ilu.RunMainLoop()These scripts were chosen to reflect both the least that could be done witha CGI script (echo back a string) vs. very little that could be done (parsethe incoming request into data structures, and echo it back). The Bourneshell script and the Perl script are thrown in as reference points. It isthe comparison of Python scripts that is relevant.The Python interpreter used for the CGI scripts was very small. I removednearly everything from the Modules setup, and did not link with threads (asource of startup time problems on Digital Unix). I used Python 1.3 for allof these, and ILU 2.0a3.Thus, the comparison is between Python CGI and Python "API Scripting".The two tests are a simple echo of a string, and a slightly-computationalparsing of the incoming information. Obviously, a real-world application,where files have to read, or marshals loaded, or databases connected-to,would tilt the scales towards API scripting, since the state is always inmemory.In the following, HPS refers to hits per second,SPH refers to seconds per hit, and SD refersto standard deviation.Latency testThis test used 10 runs of 1 thread, 20 requests on the thread:URIMinMaxAvg HPSSD (HPS)Avg SPHSD (SPH)/index.html0.1420.5804.7740.13940.20970.0066/cgi-bin/simple.sh0.1710.2214.8140.00740.20770.0003/cgi-bin/simple.pl0.1820.2244.8210.03490.20740.0015/cgi-bin/simple.py0.1760.2224.8250.01330.20730.0006/cgi-bin/simple1.py?x=1&y=2&z=3&z=4&z=50.3820.5662.3150.04360.43210.0083/echo@paul.demos0.1110.8474.6870.40480.21520.0235/dumb@paul.demos0.1820.3514.8240.07030.20730.0031Throughput testThis test used 10 runs of 10 threads, 20 requests apiece. In thiscase, the Min and Max refer to the thread completion times:URIMinMaxAvg HPSSD (HPS)Avg SPHSD (SPH)/index.html0.0601.40220.8530.47360.04800.0011/cgi-bin/simple.sh0.1061.27915.1280.49860.06620.0022/cgi-bin/simple.pl0.1191.35413.6260.31160.07340.0017/cgi-bin/simple.py0.1431.9269.1550.12960.10930.0015/cgi-bin/simple1.py?x=1&y=2&z=3&z=4&z=50.7384.8172.5970.00920.38500.0014/echo@paul.demos0.0931.22120.3620.69960.04920.0017/dumb@paul.demos0.1091.59719.8620.68950.05040.0017Understand that the HPS and SPH numbers on the throughput testreflect the ability of the server to service multiple requestssimultaneously. Thus, each hit effectively is done faster.AnalysisLooking at the latency tests, you see that HTML and the simple CGIscripts are about the same HPS. These simple scripts don't parse theenvironment, and thus do no calculation. The simple1.py script whichdoes parse the environment and imports a module suffers a 50% risein latency. Yet, the API Scripting apps stay at the same level asthe HTML and simple CGI, even though one is parsing the environment.In the throughput test, the reference point -- the index.html file --shows that a 10-thread request gets just over a five-fold bump inthroughput. Certainly not a ten-fold, but a enough to show that it ishandling simultaneous requests well. However, the CGI scripts start toshow less benefit. Yet, the API Scripting applications stay at theURIPercent of single-threaded HPS/index.html437/simple.sh314/simple.pl282/simple.py190/simple1.py??x=1&y=2&z=3&z=4&z=5112/echo@paul434/dumb@paul411If we consider getting an HTML file -- both in single-threaded andten-threaded batches -- to be a baseline, we see the relation of thesetests. Again, we see that getting an HTML file gets a four-fold bumpfrom a ten-thread batch. A simple Bash CGI script yields a three-foldimprovement (317 percent) over single-thread HTML batches. A simpleCGI script that parses the environment, run in ten-threaded batches,achieves only half the aggregate throughput of a single-threadedHTML request. Thus, concurrent CGI is slower than single-request HTML.Again, the API Scripting applications keep pace with the baseline.URI1-thread % of 1-thread HTML10-thread % of 1-thread HTML10-thread % of 10-thread HTML/index.html100437100/simple.sh10131773/simple.pl10128565/simple.py10119244/simple1.py??x=1&y=2&z=3&z=4&z=5495412/echo@paul9842798/dumb@paul10141695In the rightmost column above, which is a throughput measurement, an APIScripting application is over eight times faster than an equivalentCGI application.A conclusion is that, even for simple state applications of reading in theformdata, CGI loses to API Scripting in latency, and loses significantly inconcurrent use. It would appear that the performance win would increase evenmorefor complex applications, especially those that have to initialize somestate, or make a connection to a SQL database. Getting the state setup forthese is more complicated, and the increase in latency and load meanpileups for service.A caveat in the testing must be noted. A more representative sample ofAPI scripting vs. HTML would be to use an ILU C program and an API C program.This would also allow the testing of HTML vs. CGI vs. straight API C appsvs.ILU Requester with objects written in C.Outstanding IssuesAt this time, movement to ILU 2.0 is the biggest issue. First,there are some minor bugs with the current prerelease. The real issue isembracing some new capabilities:poor ILU support for bulk data (e.g. RPC limit)missingdata types(soon to bealleviatedin Python)investigation of Stanford Digital Library's COS (mentioned above)distributed concurrency and threadingperformance of surrogate object referencestrue object inside httpd processFor more on this, seeFuture PlansWe have a number of directions we intend to pursue internally, and asuggested direction for industry adoption.InternalSome of our plans are:discoverable interface for debugging and catalogingbetter performance numbersbetter story on concurrencyIndustrySome requirements:Use of ILUIntegration of the ILU runtime into their productSupport of a basic HTTP ISLUse of standard Resource, Request, and Response mechanismMapping the HTTP spec's error codes into HTTP exceptionsEnsure the safety of concurrent requesters running across threads orforked daemonsSome optional support:Extensions of the base HTTP ISL to expose advanced functionality withinthe ILU type systemSupport for discoverable objectsConnections through native ILU protocolPublishing true objects inside the httpd for high-performance appsAgreement on reference implementation suite for compliance testingand performance testingAlternativesMany ideas have floated around. Press releases have discussed, for instance,embedding Java inside of Web servers as a better fit than APIs. While thisdoesget many of the benefits of this architecture, it is language-based, andthusdoes not have language-independent interfaces. Some, though, view this asa benefit.Another option is HORB,which is a Java-based remote objectoperation environment. From theHORB FAQ:I wanted to have a good language for parallel and distributed computing.For those purposes,however, the classic Java has very poor functionality. I like Java becauseit's simple andeasy. But the basic idea of Java is not far from C++. C++ can also make objects,threads,and sockets. Java has no direct support for distributed object processingas C++ does not.So I decided to make a new framework for parallel and distributed computing.Also in the FAQ, a comparison of HORB to CORBA:CORBA and CORBA2 are desinged for Interoperability between different languagesanddifferent systems. You have to write interface definitions in CORBA IDL languageinaddition to real code. It must be annoying for casual use. CORBA cannot passinstances.It limits programming. CORBA ORB tends to huge to comply the CORBA standard.Since HORBORB for clients is only 20KBytes, modem users can wait for dynamic loading.Current CORBAsystems are very expensive. HORB is free of charge.As stated on ademopage,HORB aims to "replace CGI or socket programming with smart remote objectoperations of HORB".For Windows-based platforms, Microsoft's server-extension solution in theirIIS WWW server is anSDK. One of thesample applications for their API is anOLEinterface.ReferencesCGI spec, ILU, PythonDan's webAPI thread in www-talk archivesOur releases and HTTP.islAppendicesThe HTTP ISLThe interface for HTTP is used to extend the WWW server by mapping thebrowser-server interaction to an object request. We used the latestHTTP specification, as mentioned in the comment.(* $Id: WD-ilu-requestor-960307.html,v 1.6 1996/12/09 03:45:26 jigsaw Exp $ *)(*Proposed HTTP interfaceDigital Creations <info@digicool.com>Reference: http://www.w3.org/pub/WWW/Protocols/HTTP1.0/draft-ietf-http-spec.html*)(*The following is a list of headers guaranteed to be included withthe request, regardless of the requester used. This list is probablyincomplete and will grow as I become more familiar with requestersother than NetSite:In "request.headers":NoneIn "connection":"remote-ip" == the IP address of the remote client"remote-name" == the name of the remote clinet, or the IPaddress if the name cannot be determined*)INTERFACE http;TYPE field-name = ilu.CString;TYPE field-value = ilu.CString;TYPE optional-field-value = OPTIONAL field-value;TYPE RequestURI = ilu.CString;(* Should we handle URI parsing???TYPE RequestURI = RECORDscheme : ilu.CString,net_loc : ilu.CString,path : ilu.CString,params : ilu.CString,query : ilu.CString,fragment : ilu.CStringEND;*)TYPE Header = RECORDname : field-name,value : optional-field-valueEND;TYPE HTTPHeader = Header;TYPE HTTPHeaders = SEQUENCE of HTTPHeader;TYPE EntityBody = SEQUENCE of BYTE;TYPE OptionalEntityBody = OPTIONAL EntityBody;TYPE Request = RECORDURI : RequestURI,headers : HTTPHeaders,body : OptionalEntityBodyEND;TYPE StatusCode = ENUMERATIONOK = 200,Created = 201,Accepted = 202,NoContent = 204,MovedPermanently = 301,MovedTemporarily = 302,NotModified = 304,BadRequest = 400,Unauthorized = 401,Forbidden = 403,NotFound = 404,InternalError = 500,NotImplemented = 501,BadGateway = 502,ServiceUnavailable = 503END;TYPE Response = RECORDstatus : StatusCode,headers : HTTPHeaders,body : OptionalEntityBodyEND;TYPE ConnectionParameter = Header;TYPE Connection = SEQUENCE of ConnectionParameter;TYPE Resource = OBJECTMETHODSGET (request: Request, connection: Connection) : Response,HEAD (request: Request, connection: Connection) : Response,POST (request: Request, connection: Connection) : ResponseEND;TYPE OptionalResource = OPTIONAL Resource;The Logger ISL(* $Id: WD-ilu-requestor-960307.html,v 1.6 1996/12/09 03:45:26 jigsaw Exp $ *)(* I've thought about just eliminating this ISL and using HTTP to dologging, but I'm sticking with this right now to allow logging to beasynchronous. Comments? *)(*The following list is are the name-value pairs that must be containedin the headers (the separate requesters may include their own uniqueheaders, and various clients might send different headers which shouldbe passed along here):"content-length" == the length in bytes of the returned data"content-type" == the mime type of the returned data"method" == the method of the request"remote-ip" == the IP address of the remote client"remote-name" == the name of the remote client, or the IP address if the name cannot be determined"status" == the status code of the response"uri" == the URI of the request*)INTERFACE logger IMPORTS ilu, http END;TYPE LoggerObject = OBJECTMETHODSASYNCHRONOUS LogRequest(params: http.HTTPHeaders)END;The Authorizer ISL(* $Id: WD-ilu-requestor-960307.html,v 1.6 1996/12/09 03:45:26 jigsaw Exp $ *)INTERFACE authorize IMPORTS http END;TYPE NameType = ilu.CString;TYPE GroupList = SEQUENCE OF ilu.CString;EXCEPTION AuthenticationFailed;EXCEPTION Forbidden;EXCEPTION AuthorizationRequired: ilu.CString;TYPE AuthorizationRecord = RECORDname: ilu.CString,groups: GroupListEND;TYPE OptionalAuthorizationRecord = OPTIONAL AuthorizationRecord;TYPE Authenticator = OBJECTMETHODSAuthenticateUser(name: NameType, password: ilu.CString): AuthorizationRecord RAISES AuthenticationFailed ENDEND;TYPE Authorizer = OBJECTMETHODSAuthorizeUser(authorization-record: OptionalAuthorizationRecord) RAISES Forbidden, AuthorizationRequired ENDEND;Author InfoPaul Everitt is Vice President ofDigital Creations. His email addressis paul@digicool.com.