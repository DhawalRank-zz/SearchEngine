PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">XML Schema Datatypes in RDF and OWL*.xpath {background-color: #e8b8b8;}*.derive {background-color: #b8b8e8;}*.todo {color: red;font-style: italic;}*.change {color: #229922;}*.delete {color: #882200;text-decoration: line-through;}XML Schema Datatypes in RDF and OWLW3C Working Group Note 14 March 2006This version:http://www.w3.org/TR/2006/NOTE-swbp-xsch-datatypes-20060314/Latest version:http://www.w3.org/TR/swbp-xsch-datatypes/Previous version:http://www.w3.org/TR/2005/WD-swbp-xsch-datatypes-20050427/Editors:Jeremy J. Carroll, HP LabJeff Z. Pan, University of AberdeenCopyrightÂ©2006 W3CÂ® (MIT, ERCIM,Keio), All Rights Reserved.W3C liability,trademarkand documentuse rules apply.AbstractThe RDF and OWL Recommendations use the simple types from XMLSchema. This document addressesthree questions left unanswered bythese Recommendations: Which URIref should be used to refer to auser defined datatype? Which values of which XML Schema simpletypes are the same? How to use the problematicxsd:duration in RDF and OWL?In addition, we further describe how tointegrate OWL DL with user defined datatypes (in appendix B).Status of this DocumentThis section describes the status of this document at thetime of its publication. Other documents may supersede thisdocument. A list of current W3C publications and the latestrevision of this technical report can be found in the W3C technical reports index athttp://www.w3.org/TR/.This document is a WorkingGroup Note, produced by the SemanticWeb Best Practices and Deployment Working Group, part of theW3C Semantic Web Activity.As of the publication of this Working Group Note the SWBPDWorking Group has completed work on this document. Changesfrom the previous Working Draft are summarized inAppendix C.Comments on this document may be sent topublic-swbp-wg@w3.org,a mailing list with a>public archive. Further discussion on this materialmay be sent to the>Semantic Web Interest Group mailing list,semantic-web@w3.org,also with a>public archive.This document was produced by a group operating under the 5 February 2004 W3C Patent Policy. This document is informative only. W3C has a public list of any patent disclosures made in connection with the deliverables of the group; that page also includes instructions for disclosing a patent.Publication as a Working Group Note does not imply endorsement by theW3C Membership. This is a draft document and may be updated,replaced or obsoleted by other documents at any time. It isinappropriate to cite this document as other than work inprogress.Table ofContents1.Introduction1.1Reading this Document1.2NamespacesUsed in this Document1.3 XML Schema SimpleTypes2. UserDefined Datatypes2.1 ProblemStatement2.2 Component DesignatorsSolution2.3 Using theid Attribute2.4Suggested Practice3. Comparison ofValues3.1 ProblemStatement3.2 All PrimitiveTypes Differ3.3 FormalAnalysis3.4 Examples3.5 Using SPARQL for Equality3.6 Value Approximate Mapping4.Duration5.The Use of Numeric Types6.Acknowledgements7.ReferencesAppendix A:The Semantics ofDatatyping in the Semantic Web RecommendationsA.1 Datatypes inRDFA.2 Datatypes inOWL DLAppendix B: Integrating Description Logics with User-Defined DatatypesAppendix C: Changes sinceWorking Draft of 27 April 20051.IntroductionAn overview of the datatype abstractionused by RDF is found in the [RDFConcepts and Abstract Syntax]; this isshared by the [OWL AbstractSyntax].The semantics of RDF datatyping and OWL datatyping aresummarized in appendix A.RDF and OWL allow the use of typed literal values in thedescription of resources and ontologies. See the [RDF Primer], and the [OWL Guide] for a more introductory treatmentsfor RDFand OWL.Both the [RDF Semantics] and the[OWL Semantics] use thelexical-to-value mapping of the datatype to give the interpretation(the value) of a typed literal, thus the semantics of typedliterals is given by the type system. The type systems are definedexternally to RDF and OWL, most notably by [XML Schema2].Concrete syntaxes for typed literals are found in [RDF Syntax], [N-triples], and [N3].Some questions about XML Schema datatypes in the Semantic Webare not directly answered by the published W3C Recommendations.This document considers four of them:Within RDF and OWL, how to refer to an XML Schema user definedsimple type with a URI.Details of the denotational semantics of the values of theprimitive XML Schema simple types. XML Schema principally gives anoperational semantics. RDF and OWL applications need a denotationalsemantics for interoperable behaviour.A possible solution to the problems concerningxsd:duration, which are reportedin [RDF Semantics].Appropriate use of numeric types for engineering applications.1.1 Reading this DocumentWhile this document can be read from start to finish, many readerswill benefit from skipping sections.The intended reader is informed about RDF and/or OWL,and may be a creator oruser of metadata or ontologies, or may be an implementorof systems that implement the RDF or OWL Recommendations, ormay be the author or editor of related specifications.The reader who is interested in defining their own datatypesshould read section 2and maybeappendix B, which givesa formal treatment,in terms of OWL DL and user defined datatypes, that has not been covered by the [OWL Semantics].The reader who is interested in the correct use of datatypesshould read section 3, concerningwhich values are the same, andsection 5 concerning numerics, particularly,but not exclusively,for engineeringapplications.Implementors probably should read most of the document:appendix A summarizesthe formal treatment of datatyping from the recommendations;section 3 gives an extended discussionabout equality; section 2discusses the mapping from URIs to user defined types.Readers most interested in formal semanticswill find most value inappendix B,concerning user defined datatypes,andsection 3concerning equality. Such readers should start byreviewingappendix A, which should befamiliar.Section 4on durations, is of more limited interest, but is significantto any reader who wishes to use, implementor build on top ofduration datatypes.1.2 NamespacesUsed in this DocumentIn this document we use N3 such as "10"^^xsd:intfollowing the subset used by the [OWL TestCases], with the following namespace prefixes:@prefix dc: <http://purl.org/dc/elements/1.1/> .@prefix eg: <http://www.example.org/> .@prefix egdt: <http://example.org/simpleTypes#> .@prefix xsd: <http://www.example.org/> .@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .@prefix owl: <http://www.w3.org/2002/07/owl#> .@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .1.3 XML Schema SimpleTypes[XML SCHEMA2] defines facilities for defining simple types tobe used in XML Schema as well as other XML specifications.It is influenced by earlier work on datatypes such as[ISO 11404].[Definition:] An XML Schemasimple type d is characterised by a value space, V(d), whichis a non-empty set, a lexical space, L(d), which is a non-empty setof Unicode strings, and a set of facets, F(d), each of whichcharacterizes a value space along independent axes ordimensions.XML Schema simple types are divided into disjoint built-insimple types and derived simple types. Derived datatypes can bedefinedfrom primitive or existing derived datatypesby the following three means:Byrestriction, i.e., by using facets on anexisting type, so as to limit the number of possible values of thederived type.Byunion, i.e., to allow values from a listof simple types.Bylist, i.e., to define the list type ofan existing simple type.Example 1AThe following is the definition of a derived simple type (of thebase datatype xsd:integer) which restricts values to integersgreater than or equal to 0 and less than 150, using the facetsminInclusive and maxExclusive.<xsd:schema ...><xsd:simpleType name="humanAge"><xsd:restriction base="integer"><xsd:minInclusive value="0"><xsd:maxExclusive value="150"></xsd:restriction></xsd:simpleType>...</xsd:schema>2. User DefinedDatatypes[XML Schema2] predefines aboutforty simple types, the ones suitable for RDF and OWL are listed in[RDF Semantics].In addition, XML Schema permits users to refine these builtintypes by taking a restriction including only some of the values orsome of the lexical forms.Example 2AAs a further example, we may wish to talk aboutages of adults in years, where an adult is over 18. This can bedescribed as a restriction on the xsd:integerdatatype.<xsd:schema ...><xsd:simpleType name="adultAge"><xsd:restriction base="integer"><xsd:minInclusive value="18"></xsd:restriction></xsd:simpleType>...</xsd:schema>In a Semantic Web context this may be used with the objects oftriples of an eg:age property, used, for instance,when describing some members of a club which is restricted toadults, e.g. a nightclub or a political party.We will use this example throughout this section, and assume itcan be retrieved fromhttp://example.org/simpleTypes.Within RDF, and RDF reasoning, this additional restriction maybe enough to catch some typos or data entry errors (e.g. putting aninappropriate value of 0 for the eg:ageproperty). Within OWL, and OWL reasoning, this may interact withaxioms in the ontology to significantly restrict the possibleinterpretations, adding to the modelling power of the language.This section only deals with the problem of how to refer to suchdatatypes.Their semantics is treated in the appendices.Appendix Areviews the semantics of datatypes from the RDF and OWLrecommendations.Appendix Bdescribes how to integrate Description Logics (such as theSHOIN DL, which is the underpinning of OWL DL) with userdefined datatypes.We will also consider the topic ofthetarget namespacefrom [XML SCHEMA1].For clarity, we will considertwo variants on this example. The first has no target namespace,the second defines one.Example 2B<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"><xs:simpleType name="adultAge"><xs:restriction base="integer"><xs:minInclusive value="18"></xs:restriction></xs:simpleType>...</xs:schema>Example 2C<xs:schematargetNamespace="http://example.org/ns"elementFormDefault="qualified"xmlns:egn="http://example.org/ns"xmlns:xs="http://www.w3.org/2001/XMLSchema"><xs:simpleType name="adultAge"><xs:restriction base="integer"><xs:minInclusive value="18"></xs:restriction></xs:simpleType>...</xs:schema>The case where the XML Schema has been assembed from multiple schemadocuments lies outside the scope of this document.This case isdiscussed in[XML SCHEMA1]and explicitlynot discussed in[XSCD].2.1 Problem Statement:When describing a resource with RDF or building an ontology withOWL, in which a user defined simple XML Schema datatype, such asadultAge above, what URI should be used to identifythis datatype?2.2 Component DesignatorsSolutionFollowing XML Schema Component Designators [XSCD]Example 2Bhas URI referencehttp://example.org/simpleTypes#xscd(/type::adultAge).A URI reference forExample 2Crequires a choice of prefix for the namespacehttp://example.org/ns.A good choice is to use the prefixused by the schema itself, i.e. egn.The resulting URI reference for the datatypeis thenhttp://example.org/simpleTypes#xmlns(egn=http://example.org/ns)xscd(/type::egn:adultAge)When the schema does not define a prefix for thetarget namespace, perhaps by using the default namespace,then an arbitrary prefix needs to be chosen.As always with namespace prefixes, it is permittedto use any prefix of your choice, even when a conventionalprefix is used in the schema document.XML Schema Component Designators [XSCD]defines an XPointer scheme that navigates the XMLSchema document to identify any of the schema components using afragment. This is very general: fragments are defined that identifymany different aspects of the document, including unnamed simpletypes within complex schema.Ourexample 2B becomes:eg:membersAge rdfs:range <http://example.org/simpleTypes#xscd(/type::adultAge)> ._:aMember eg:name "Jane Doe" ._:aMember eg:membersAge "24"^^<http://example.org/simpleTypes#xscd(/type::adultAge)> .One way of reading the fragment is that it provides fullsemantic clarity about what is being identified: the xscd(.)shows that an XML Schema component is being identified; the /typeindicates that a type is being identified; the ::adultAge shows whichtype is being identified.The above URIrefs cannot be abbreviated as:eg:membersAge rdfs:range egdt:xscd(/type::adultAge) ._:aMember eg:name "Jane Doe" ._:aMember eg:membersAge "24"^^egdt:xscd(/type::adultAge) .because xscd(/type::adultAge) does not matchthe NCName production.Overall, referring to XML Schema Datatypesin the manner proposed by the XML Schema Working Group isa good practice, and will be moreso, when[XSCD]reaches Recommendation status.2.3 Using theid AttributeIn cases where the XML Schema is under the controlof a Semantic Web author, the full generality of[XSCD]is not needed. This section shows how when definingyour own datatype, derived from an XML Schema type,it is possible to use a simpler method, by slightlymodifying the schema defining the datatype.Example 2A becomes:<xsd:schema ...><xsd:simpleType id="adultAge" name="adultAge"><xsd:restriction base="integer"><xsd:minInclusive value="18"></xsd:restriction></xsd:simpleType>...</xsd:schema>The difference is that the datatype we wish to useis not only identified by the @nameattribute, but also by an @id attribute.While it is technically possibly to use different valuesfor these two attributes, it would be confusing.The URI referencehttp://example.org/simpleTypes#adultAge can then be used to referto the datatype.In the terminology of [RFC 3986],the URI http://example.org/simpleTypes#adultAgeidentifies a secondary resource. Whenhttp://example.org/simpleTypes is retrievedas an XML Schema document, with mimetype application/xml,this may be taken asashorthandpointerfrom the [XPointerFramework].This identifies a view on the XML representation of the primary resourcebeing the XML element with the matching @id attribute.When used in RDF (see[RDF Concepts], this URI referencemay be understood with the URIhttp://example.org/simpleTypesas identifying the schema, and the URIhttp://example.org/simpleTypes#adultAgeas identifying the datatype itself, a resource definedor described by the representation identifiedby the application/xml retrieval.It is preferred that no targetNamespaceis given in the schema for this usage.If there is no @id attributewith the given name,the[XPointerFramework]is clear that this is an error:If no element information item is identified by a shorthand pointer'sNCName, the pointer is in error.Our example RDF is:eg:membersAge rdfs:range <http://example.org/simpleTypes#adultAge> ._:aMember eg:name "Jane Doe" ._:aMember eg:membersAge "24"^^<http://example.org/simpleTypes#adultAge> .Or:eg:membersAge rdfs:range egdt:adultAge ._:aMember eg:name "Jane Doe" ._:aMember eg:membersAge "24"^^egdt:adultAge .As a further example, a club which has members of all ages,but wishes to have a class of its adult members, could use an OWL expressionlike the following (in the[OWL Abstract Syntax]:Class(AdultMembersinsersectionOf(MembersRestriction(eg:membersAge, allValuesFrom(egdt:adultAge)) ) )2.4 Suggested PracticeWhen referring to arbitrary user defined datatypesin arbitrary XML Schema, the[XSCD] solution is appropriate.When anRDF or OWL author or toolis writing an XML Schema for use with an RDF/XML document,the @id solution may be preferred.3. Comparison ofValuesTwo different authors publishing the same information on theSemantic Web may make different syntactic choices. They then saythe same thing in different ways. This is seen most clearly whenthe two documents entail one another as determined by the[RDF Semantics] or[OWL Semantics].One aspect of the syntactic choices facing an author is whichdatatypes to use. Even if they use only the built in[XML SCHEMA2] simple types, there are non-trivial choices, anddifferent authors may legitimately choose different datatypes. Thissection addresses the issue of how implementations of[RDF Semantics] and[OWL Semantics] should allow for the different choices ofdatatype made by different authors.3.1Problem StatementWhat is the relationship between the value spaces of the variousXML Schema built-in simple types when used within RDF and OWL?Or in other words, when do two literals, which are written downdifferently, refer to the same value. For example,"10"^^xsd:integer and "010"^^xsd:integerboth denote the integer ten.3.2All Primitive Types DifferThe most appropriate solution isthat allprimitive XML Schema Datatypesare treated as having disjoint value spaces.Thisapproach is both easy to understand,and easy to implement.Formally, in a unary datatype group, value spaces of primitive basedatatypes are required to be defined as disjoint witheach other. For instance, if the value space datatype D1 is a subset of that of thedatatype D2, then D1 and D2 can not be both primitive base datatypesin a unary datatype group.3.3 FormalAnalysisIn discussing the examples, we presented pairs of literals whichdenoted the same value. This relationship of denoting the samevalue forms an equivalence relation, which we will write as~; it is conventionally written as '='and called equality. It is reflexive, symmetric and transitive.In terms of the[RDF Semantics](see appendix A.1)the equivalence relation ~ canbe constructed from the interpretation function IL, in thefollowing way:~ = { <x,y> : IL(x)=IL(y), for any x, y âˆˆ LV }In terms ofDL Semantics -->[OWL Semantics] (see appendix A.2), this can be constructed in terms of theinterpretation function ED as:~ = { <x,y> : ED(x)=ED(y), for any x, y âˆˆ LV }A key term we will use in the following examples, is primitive base datatype in atype system. A recursive definition is:Eachbuilt in primitive datatype is its own primitive basedatatype.The primitive base datatype of a derivedsimple type is the primitive base datatype of its basedatatype.In other words, the primitive base datatype of a type system isfound by walking up therestriction tree until reaching a primitivetype. Note that the concept of primitive base datatypes in a typesystem is slightly different from the concept of primitive basedatatypes in a unary datatype group.This is because it is possible that a primitive base datatype of atype system is not in a datatype map, but its derived datatypesare. For instance, in Example_B,xsd:integer is a primitive base datatype in the unary datatypegroup G1.3.4ExamplesWe give two sets of examples.The first set of examples, depend on comparisons wherethe primitive base datatypeis the same. The second setwhere the primitive base datatype is not. However,the second set are intended to be slightly counter-intuitive,and to illustrate limitations in this approach to comparingtyped literals.Each example is presented in two ways:As a pair of literals which may, or may not, denote the samevalue.As a possible entailment. Technically the intended entailmentis a D-entailment,in terms of[RDF Semantics], or an OWL Full entailment in terms of the[OWL Semantics]. Similar, slightly longer, OWL DL entailments could beconstructed, illustrating the same issues.3.4.1 Easy ExamplesIt is uncontested that in[XML SCHEMA2] a datatype derivedbyrestriction refers to a subset of the values of its basedatatype, and not to different values (see[XML SCHEMA2]).Hence, two typed literals whose type have the same primitivebase datatype, and whose lexical forms are equivalent, areequal.In addition,[RDF Semantics] explicitly sanctions identification of RDFplain literals without language tags with corresponding typedliterals with datatype xsd:string.Derived NumericsAs a first example "15"^^xsd:byte and"15.0"^^xsd:decimal both denote the same value,fifteen. This follows because xsd:byte has primitivebase datatype xsd:decimal.This licenses the following entailment:Example 3Aeg:Jane eg:age "15"^^xsd:byte .entailseg:Jane eg:age "15.0"^^xsd:decimal .The same result holds for two types both of which have primitivebase datatype decimal. For example "15"^^xsd:byte and"15"^^xsd:nonNegativeInteger both denote fifteen, andthe entailment:Example 3Beg:Jane eg:age "15"^^xsd:nonNegativeInteger .entailseg:Jane eg:age "15"^^xsd:byte .Note that xsd:byte is not derived fromxsd:nonNegativeInteger, or vice versa, even withintermediate steps.Derived Stringsxsd:language has primitive base datatypexsd:string. Thus "en-US"^^xsd:languageand "en-US"^^xsd:string denote the same value, and thefollowing entailment holds:Example 3Ceg:doc dc:language "en-US"^^xsd:language .entailseg:doc dc:language "en-US"^^xsd:string .However, despite the language identifier being case insensitiveaccording to[RFC 3066], this case insensitivity is not represented in thedatatype, so that "en-US"^^xsd:language and"en-us"^^xsd:language denote different values and wehave the following non-entailment:Example 3Deg:doc dc:language "en-US"^^xsd:language .does not entaileg:doc dc:language "en-us"^^xsd:language .Plain StringsThe[RDF Semantics] says(in an informative section):the value space and lexical-to-valuemapping of the XSD datatype xsd:stringsanctions the identification of typed literals with plain literalswithout language tags for all character strings which are in thelexical space of the datatype, since both of them denote theUnicode character string which is displayed in the literal;Thus "en-US"^^xsd:string denotes the same as theplain literal "en-US", and the following twoentailments hold:Example 3Eeg:doc dc:language "en-US"^^xsd:string .entailseg:doc dc:language "en-US" .Example 3Feg:doc dc:language "en-US"^^xsd:language .entailseg:doc dc:language "en-US" .3.4.2 Hard ExamplesWhen the two typed literals being compared have differentprimitive base datatypes,all the values are assumedto be different, and entailments do not follow, evenwhen this is counterintuitive. Thenumber one for instance can be a float, a double, or a decimal.Since they all have different primitive base datatypes,these are all different.Float and DecimalA human age is conventionally given as an integer (number ofyears, except for babies). but a float is a plausible alternativerepresentation. On April 7th 2004,Jeremy was forty,"40"^^xsd:integer has a different primitivebasetype to"40"^^xsd:float, so that, they are not equaland:Example 3Geg:JeremyCarroll eg:ageInYears "40"^^xsd:integer .does notentaileg:JeremyCarroll eg:ageInYears "40"^^xsd:float .Similarly, float and doubleare different primitive base datatypes, and sosuperficially similar values,such as"1.3"^^xsd:floatand"1.3"^^xsd:decimalare different, and:Example 3Heg:car eg:engineSizeInLitres "1.3"^^xsd:decimal .does notentaileg:car eg:engineSizeInLitres "1.3"^^xsd:float .Float and DoubleAs with float and decimal,neither float or double is derived from the other.Thus,"40"^^xsd:double and "40"^^xsd:floatare treated as not equal, and:Example 3Jeg:JeremyCarroll eg:ageInYears "40"^^xsd:double .does notentaileg:JeremyCarroll eg:ageInYears "40"^^xsd:float .Similarly:Example 3Keg:car eg:engineSizeInLitres "1.3"^^xsd:double .does notentaileg:car eg:engineSizeInLitres "1.3"^^xsd:float .String and anyURISimilarly, the two types stringand anyURI, are distinctprimitive base datatypes. So that,despite superficial similarities,"http://www.example.org/doc"^^xsd:stringis different from"http://www.example.org/doc"^^xsd:anyURI, and:Example 3Leg:doc dc:identifier "http://www.example.org/doc"^^xsd:anyURI .does not entaileg:doc dc:identifier "http://www.example.org/doc"^^xsd:string .hexBinaryand base64BinaryThe final case where the value spaces of two XML Schema simpletypes appear to the same is forxsd:hexBinary andxsd:base64Binary. For both the value space is describedas: the set of finite-length sequences of binary octets. Forinstance the binary sequence of two octets (00001111 10110111)(i.e. the 16-bit integer 4023) can be written in hexadecmial as0FB7. In base64 encoding[RFC 2045] this same sequence of two octets is represented asD7c=.00001111 10110111 00000000000011 111011 011100 0000003 59 28 padD 7 c =-->Despite this, the two types hexBinaryand base64Binary, are distinctprimitive base datatypes. So that,"0FB7"^^xsd:hexBinaryis different from"D7c="^^xsd:base64Binary, and:Example 3Meg:doc eg:checkSum "0FB7"^^xsd:hexBinary .does not entaileg:doc eg:checkSum "D7c="^^xsd:base64Binary .3.5 Using SPARQL for EqualityWhile some of the non-entailments shown may be counterintuitive,it is possible to use SPARQL toquery a graph and retrieve literal values thatare similar even if not derived from the same primitive basetype.For example, related to examples 3H and3K. Given a graph including thefollowing three triples:eg:car eg:engineSizeInLitres "1.3"^^xsd:double .eg:car eg:engineSizeInLitres "1.3"^^xsd:decimal .eg:car eg:engineSizeInLitres "1.3"^^xsd:float .The following[SPARQL] query will match all three.SELECT ?sizeWHERE { eg:car eg:engineSizeInLitres ?size .FILTER (?size = 1.3) . }In the current[SPARQL] working draft, the mapping from the typedliteral, as a syntactic object, to its corresponding value, is done aspart of the operation of the = operator in the above query, ratherthanas part of say a D-interpretation fromshape="rect">[RDF Semantics].This mapping is specified in[Functions & Operators], and, being stronglytyped, is not identical with that specified inshape="rect">[RDF Semantics]3.6 Value Approximate MappingA different approach, better embedded inshape="rect">[RDF Semantics], could enablemeaningful mappings among values from different datatypes.This could give better foundations for operations such as the typepromotion of the XML Path Language 2.0shape="rect">[XPath 2.0] and the = operator inSPARQL mentioned inshape="rect">Section 3.5. A quick sketch is that we extend theRDFshape="rect">D-interpretation to support value approximate maps, as follows:"defn-mapsto">[Definition:] A value approximate map mapsTois a partial mapping from typed literals to typed literals.Example 3NAn example value approximate mapping is"1.3"^^xsd:decimal owlx:mapsTo "1.3"^^xsd:float ."rdf-value-map-int">[Definition:] Given a datatype map D and a value approximate map mapsTo, the approximate equality aeq is defined as follows:aeq("s1"^^u1,"s2"^^u2)=true ifL2S(D(u1))(s1) =L2S(D(u2))(s2) or if mapsTo("s1"^^u1)="s3"^^u2 and L2S(D(u2))(s3) =L2S(D(u2))(s2),aeq("s1"^^u1,"s2"^^u2)=false otherwise.L2S(D(u1))(s1) â‰ L2S(D(u2))(s2) and mapsTo("s1"^^u1) is undefined, or if L2S(D(u1))(s1) â‰ L2S(D(u2))(s2), mapsTo("s1"^^u1)="s3"^^u2 and L2S(D(u2))(s3) â‰ L2S(D(u2))(s2). -->"s2"^^u2) is incomparable ifmapsTo(D(u1),D(u2))is undefined.-->Note that, according to the above definition, aeq("s1"^^u1,"s2"^^u2)=true does not imply that "s1"^^u1 and"s2"^^u2 are interpreted as the same value (L2S(D(u1))(s1) =L2S(D(u2))(s2)). The approximate equality is different from equality and is not necessarily symmetric, depending on the corresponding value approxiate map. The unsymmetry is needed to support e.g. type promotions in the XML Path Language 2.0shape="rect">[XPath 2.0]. Note that notion of value approxiate mappings is very general - it does not disallow having symmetric mappings between two typed literals. In Example 3N, one can also specify a value approximate mapping from "1.3"^^xsd:float to "1.3"^^xsd:decimal to make the mappings between the two typed literals symmetric.To sum up, applications can specify a value approximate map mapsTo and make use of the approximate equality aeq for their purposes.4.DurationThe [RDF Semantics]Recommendation discourages the use of thexsd:duration datatype (see [XML SCHEMA2]). It says:[Some] built-in XML Schema datatypes are unsuitable for variousreasons, and SHOULD NOT be used:xsd:duration does not have a well-defined value space(this may be corrected in later revisions of XML Schema datatypes,in which case the revised datatype would be suitable for use in RDFdatatyping);The underlying difficulty is the impossibility of an unequivocalanswer to the question "How many days in a month?" This has provedproblematic in other applications of XML Schema datatypes. TheXQuery and XSLT Working Groups have a proposed solution. Theyderive two new datatypes,xdt:yearMonthDuration andxdt:dayTimeDuration fromxsd:duration, sidestepping the unanswerable question.Insection 10.2 of [Functions & Operators] weread:[Definition:] xdt:yearMonthDuration is derived fromxs:duration by restricting its lexical representationto contain only the year and month components. The value space ofxdt:yearMonthDuration is the set ofxs:integer month values. The year and month componentsof xdt:yearMonthDuration correspond to the Gregorianyear and month components defined in section 5.5.3.2 of [ISO 8601], respectively.and[Definition:] xdt:dayTimeDuration is derived fromxs:duration by restricting its lexical representationto contain only the days, hours, minutes and seconds components.The value space of xdt:dayTimeDuration is the set offractional second values. The components ofxdt:dayTimeDuration correspond to the day, hour,minute and second components defined in Section 5.5.3.2 of [ISO 8601], respectively.These two new datatypes are suitable for use with RDF and OWL.(Note that they are not yet recommended, since F&O is still inWorking Draft).5.The Use of Numeric TypesFor much data on the Semantic Weba motivation for providing type informationis to permit the use of the databy engineering applications, and interoperationbetween engineering applications.Most such data will be marked up using the numeric typesfrom XML Schema.Loss inprecision or unexpected changes in values due to automatic typeconversion could be problematic in an engineering environment.In the engineering domain there arethree importanttypes of usage for numerics: count, measurement,and constant.countA count is an integer representing essentially thecardinal number for a set of things classified by some set of tests.An example would be the count of packages of candy available forshipment. A count is an exact number. Tests may includemeasurements, but a count is not an approximation of a sum ofthese measurements nor is it a sum of the approximation of thesemeasurements. A type such as xsd:integeror a type derived from xsd:integer is appropriate forcounts.measurementA measurement is an inexact numeric value (usually represented as areal) produced by some measurement method. This value indicates avalue range which includes the actual value. The actual value isunknowable, but more precise measurement methods can reduce therange of uncertainty. The precision or uncertainty isusually included with the measurement value. Either implicitlyusing significant figures or explicitly using a separate propertyvalue such as error range.Either the xsd:float or xsd:doubledatatypes are appropriate for measurement, but it should be notedthat these do not include a precision or uncertainity, which shouldbe included as the value of a separate property.[XML SCHEMA2]explicitly states for xsd:decimalthat, "Precision is notreflected in this value space, the number 2.0 is not distinct fromthe number 2.00."constantA constant is an exact value used in computation. It may or may notbe possible to express exactly as a numeric. A millimeter is exactly0.001 meters, but Pi is not 3.14159.Often an xsd:decimal will be more appropriate thanan xsd:float or xsd:double for expressinga constant.Example 5AAs an example of a measurement with an error rangeto indicate a weight in the interval (73.0Kg, 73.2Kg).eg:JeremyCarroll eg:weight _:w ._:w eg:units "kilogram" ._:w eg:value "73.1"^^xsd:float ._:w eg:errorRange "0.1"^^xsd:float .These different usages suggestsome potential needs and concerns for a type systemunderlying this.Because the value spaces for these typesare different, measurements are disjoint from counts and constants.Some means of capturing precision or error/uncertainty is neededfor measurement values.Some means is desirable for writing downconstants that cannot be expressed precisely in numeric form.The first of these issues will generally be reflectedin the use of xsd:integer for counts,xsd:float and xsd:double formeasurements, and xsd:decimal for constants.The second issue concerning precision of measurements,must be addressed at the modelling level byusing objects to state precision or errorproperties for measurements. This is not a bad approach,in any case, sincethere are often other properties or metadata associated with ameasurement.For the third issue, concerning some constants, nosolution is offered.6.AcknowledgementsEvan Wallace is the author of Section 5.Evan Wallace,Ashok Malhotra,Pat Hayes,Dave Peterson,Dave Reynolds,Michael Sperberg-McQueen and Ralph Swickcontributed useful reviews.7.References[RDF-SEMANTICS]RDFSemantics, Patrick Hayes, Editor, W3C Recommendation, 10February 2004, http://www.w3.org/TR/2004/REC-rdf-mt-20040210/ .Latest version availableat http://www.w3.org/TR/rdf-mt/ .[RDFPrimer]RDFPrimer, Frank Manola and Eric Miller, Editors, W3CRecommendation, 10 February 2004,http://www.w3.org/TR/2004/REC-rdf-primer-20040210/ . Latest version available athttp://www.w3.org/TR/rdf-primer/ .[RDFConcepts]ResourceDescription Framework (RDF): Concepts and AbstractSyntax, Graham Klyne and Jeremy J. Carroll, Editors, W3CRecommendation, 10 February 2004,http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/ . Latest version availableat http://www.w3.org/TR/rdf-concepts/ .[RDFSyntax]RDF/XMLSyntax Specification (Revised), Dave Beckett, Editor,W3C Recommendation, 10 February 2004,http://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/ .Latestversion available at http://www.w3.org/TR/rdf-syntax-grammar/.[N-triples]RDF TestCases, Jan Grant and Dave Beckett, Editors, W3CRecommendation, 10 February 2004,http://www.w3.org/TR/2004/REC-rdf-testcases-20040210/ . Latest version availableat http://www.w3.org/TR/rdf-testcases/ .[OWL Abstract Syntax][OWLSemantics]OWL WebOntology Language Semantics and Abstract Syntax, PeterF. Patel-Schneider, Patrick Hayes, and Ian Horrocks, Editors, W3CRecommendation 10 February 2004,http://www.w3.org/TR/2004/REC-owl-semantics-20040210/ . Latest version availableat http://www.w3.org/TR/owl-semantics/ .[OWL Guide]OWL WebOntology Language Guide, Michael K. Smith, Chris Welty,and Deborah L. McGuinness, Editors, W3C Recommendation, 10 February2004, http://www.w3.org/TR/2004/REC-owl-guide-20040210/ . Latest version available athttp://www.w3.org/TR/owl-guide/ .[OWL Test Cases]OWL Web Ontology Language Test Cases,Jeremy J. Carroll and Jos De Roo, Editors.W3C Recommendation, 10 February 2004,http://www.w3.org/TR/2004/REC-owl-test-20040210/.Latest versionavailable at http://www.w3.org/TR/owl-test/.[XPointer Framework]XPointer Framework, Paul Grosso, Eve Maler, Jonathan Marsh and NormanWalsh, Editors, W3C Recommendation, 25 March 2003,http://www.w3.org/TR/2003/REC-xptr-framework-20030325/ . Latest version availableat http://www.w3.org/TR/xptr-framework/ .[XML-SCHEMA1]XML SchemaPart 1: Structures, Second Edition, W3C Recommendation,World Wide Web Consortium, Henry S. Thompson,David Beech,Murray Maloneyand Noah Mendelsohn(editors), 28 October 2004. This version ishttp://www.w3.org/TR/2004/REC-xmlschema-1-20041028/. The latest version isavailable at http://www.w3.org/TR/xmlschema-1/.[XML-SCHEMA2]XML SchemaPart 2: Datatypes, Second Edition, W3C Recommendation,World Wide Web Consortium, Paul V. Biron and Ashok Malhotra(editors), 28 October 2004. This version ishttp://www.w3.org/TR/2004/REC-xmlschema-2-20041028/. The latest version isavailable at http://www.w3.org/TR/xmlschema-2/.[RFC 2045]N. Freed and N. Borenstein. RFC 2045: Multipurpose InternetMail Extensions (MIME) Part One: Format of Internet MessageBodies. 1996. Available at: http://www.ietf.org/rfc/rfc2045.txt[RFC3986]T. Berners-Lee, R. Fielding, and L. Masinter. UniformResource Identifiers (URI): Generic Syntax. IETF RFC 3986. Seehttp://www.ietf.org/rfc/rfc3986.txt.[RFC 3066]H. Alvestrand, ed. RFC 3066: Tags for the Identification ofLanguages 2001. Available at: http://www.ietf.org/rfc/rfc3066.txt[ISO 8601]ISO (International Organization for Standardization).Representations of dates and times, 2000-08-03. Availablefrom: http://www.iso.ch/[ISO 11404]ISO (International Organization for Standardization).Language-independent Datatypes. Availablefrom: http://www.iso.ch/[UNICODE]The Unicode Standard, Version 3, The UnicodeConsortium, Addison-Wesley, 2000. ISBN 0-201-61633-5, as updatedfrom time to time by the publication of new versions. (See http://www.unicode.org/unicode/standard/versions/for the latest version and additional information on versions ofthe standard and of the Unicode Character Database).[Functions & Operators]XQuery1.0 and XPath 2.0 Functions and Operators, AshokMalhotra, Jim Melton and Norman Walsh (editors), World Wide WebConsortium Working Draft, work in progress, 15 September 2005. Thisversion of Functions and Operators ishttp://www.w3.org/TR/2005/WD-xpath-functions-20050915/. Thelatest versionof Functions and Operators is athttp://www.w3.org/TR/xpath-functions/.[XPath 2.0]XML Path Language (XPath) 2.0, Anders Berglund, Scott Boag, Don Chamberlin, Mary F. Fernández, Michael Kay, Jonathan Robie and Jérôme Siméon (editors), W3C Candidate Recommendation 3 November 2005. Thisversion of XML Path Language (XPath) ishttp://www.w3.org/TR/2005/CR-xpath20-20051103/. Thelatest versionof XML Path Language (XPath) is athttp://www.w3.org/TR/xpath20/.[SPARQL]SPARQLQuery Language for RDF, Eric Prud'hommeaux and AndySeaborne, Editors, W3C Working Draft 21 July 2005,http://www.w3.org/TR/2005/WD-rdf-sparql-query-20050721/ . Latest versionavailable at http://www.w3.org/TR/rdf-sparql-query/ .[XSCD]XML SchemaComponent Designators, Mary Holstege and Asir S.Vedamuthu, Editors, W3C Working Draft, 29 March 2005,http://www.w3.org/TR/2005/WD-xmlschema-ref-20050329/. Latest version availableat http://www.w3.org/TR/xmlschema-ref/ .[Pan 2004]Description Logics:Reasoning Support for the Semantic Web, Jeff Z.Pan, PhDThesis, School of Computer Science, The University of Manchester,2004.[PH 2005]"http://dl-web.man.ac.uk/~panz/Zhilin/pubc.php?type=epapers&id=LNCS-PaHo05">OWL-Eu: Adding Customised Datatypes into OWL, Jeff Z.Pan and Ian Horrocks. In Proc. of the Second European Semantic Web Conference (ESWC 2005), pages 153-166, 2005. An extended version appears in the Journal of Web Semantic, 4(1). An online version is available at http://www.websemanticsjournal.org/ps/pub/2005-24.[N3]Primer: Getting into RDF & Semantic Web using N3Tim Berners-Lee, Dan ConnollyAppendix A: The Semantics ofDatatyping in the Semantic Web RecommendationsA.1 Datatypes inRDFAccording to[RDF Semantics],(see section 5.1),RDF allows the use of datatypes defined by anyexternal type systems, e.g., the XML Schema type system, whichconform to the following specification.[Definition:] In RDF, a datatype dis characterised by a value space, V(d), which is a non-empty set,a lexical space, L(d), which is a non-empty set of Unicodestrings, and a total mapping L2V(d) from the lexical space to thevalue space.This specification allows the use of non-list XML Schema simpletypes as datatypes in RDF.[Definition:]All literals have a lexical form being a Unicode [UNICODE] string. Typed literals are ofthe form "v"^^u, where "v" is a Unicodestring, called the lexical form of the typed literal, andu is a URI reference of a datatype. Plain literals have alexical form and optionally a language tag as defined by[RFC-3066], normalized tolowercase.Example ABoolean is a datatype with value space{true,false}, lexical space {"true","false","1","0"} and lexical-to-value mapping{"true"â†’true, "false"â†’false, "1"â†’true, "0"â†’false}."true"^^xsd:boolean is a typed literal, while"true" is a plain literal.The associations between datatype URI references (e.g.,xsd:boolean) and datatypes (e.g., boolean) can be provided bydatatype maps defined as follows.[Definition:] A datatype map Dis a partial mapping from datatype URI references to datatypes.An RDFS-interpretation w.r.t. a datatype map D can be defined asfollows.[Definition:] Given a datatypemap D, an RDFS D-interpretation I of a vocabulary V is anyRDFS-interpretation of Vâˆª{u |âˆƒd.D(u)=d} which introduces (i) adistinguished subset LV of IR, called the set of literalvalues, which contains all the plain literals in V, and (ii) amapping IL from literals in V into IR, and satisfies the followingextra conditions:LV = ICEXT(rdfs:Literal).For any plain literal plâˆˆV, IL(pl) = pl.For each pair <u,d> where d = D(u),I(u) âˆˆ ICEXT(rdfs:Datatype),there exists dâˆˆIR s.t. I(u) = d,ICEXT(d) = V(d) âŠ† LV,for "s"^^u'âˆˆV, I(u') = d, if sâˆˆL(d), thenIL("s"^^u') = L2S(d)(s); otherwise,IL("s"^^u') âˆˆ IR \ LV.If d âˆˆ ICEXT(rdfs:Datatype), then <d, I(rdfs:Literal)> âˆˆIEXT(rdfs:subClassOf).A.2 Datatypes inOWL DLOWL Full datatyping follows the RDF Semantics as above;OWL DL datatyping is specifiedinsection 3.1 of the[OWL Semantics], as follows.The fundamental difference between RDF datatyping and OWL DLdatatyping is the relationship between datatypes and classes. InOWL DL, datatypes are not classes, and object and datatypedomains are disjoint with each other.-->OWL allows different OWL reasoners to provide differentsupported datatypes.[Definition:] Given a datatype map D, adatatype URI reference u is called a supported datatype URIreference w.r.t. D if there exists a datatype d such that<u,d>âˆˆD (in this case, d is called a supporteddatatype w.r.t. D); otherwise, u is called an unsupporteddatatype URI reference w.r.t. D.OWL provides the use of so called enumerated datatypes, whichare built using literals.[Definition:] Let y1, ...,yn be literals. An enumerated datatype is of theform oneOf(y1, ..., yn).An OWL DL D-interpretation w.r.t. a datatype map D can bedefined as follows.[Definition:] An OWL DL datatypeinterpretation w.r.t. to a datatype map D is a pair (LV,ED),where the datatype domain LV(only) contains the value spaces for each datatype in Dand PL(the valuespace for plain literals, i.e., the union of the set of Unicodestrings and the set of pairs of Unicode strings and language tags)= PLâˆªâˆªfor eachsupported datatype URIref u w.r.t. DD(u) (PL is-->and ED is a datatype interpretation function, which has to satisfythe following conditions:LV = ED(rdfs:Literal).For any plain literal pl, ED(pl) = pl âˆˆ PL.For each supported datatype URIref u (let d = D(u)):ED(u) = V(d) âŠ† LV,if s âˆˆ L(d), then ED("s"^^u) = L2V(d)(s);otherwise, ED("s"^^u) is not defined.For each unsupported datatype URIref u, ED(u) âŠ† LV andED("s"^^u) âˆˆ ED(u).Each enumerated datatype oneOf(y1, ...,yn) is interpreted as {ED(y1)}âˆª ...âˆª {ED(yn)}.Note that here we simplify the presentation by using ED as theinterpretation function for both datatype URI references andliterals, while [OWL Semantics]uses EC for datatypes URI references and L for literals.In OWL Full, the disjointness restriction betweenobject and datatype domains is not required.Appendix B: Integrating Description Logics with User-Defined Datatypes[Pan 2004] and [PH 2005] present a scheme ofintegrating a large family of decidable Description Logics(including SHOIN, the underpinning of OWL DL) with unarydatatype groups, so as to support user defined datatypes. Acombined DL is decidable if the unary datatype group is conforming.A conforming unary datatype group is equipped with a decisionprocedure for the satisfiability problem of finite conjunctionsover supported datatypes."datatype-group">[Definition:] A unary datatypegroup G is a triple <D,B,dom>, where D is a datatype map,B is the set of primitive base datatype URI references in G and domis the declared domain function. We call S the set of supporteddatatype URI references, i.e., for each uâˆˆS, D(u) is defined; werequire B âŠ† S. The declared domain function dom has the followingproperties: for each u âˆˆ S, if u âˆˆ B, dom(u) = u; otherwise, dom(u)= v, where v âˆˆ B. We assume that there exists a datatype URIreference rdfsx:DatatypeBottom such that D(rdfsx:DatatypeBottom) isundefined.Note that in [Pan 2004] datatypegroups allow arbitrary datatype predicates, while here we consideronly datatypes, which can be regarded as unary datatypepredicates.Example BG1=(D1,B1,dom1) is aunary datatype group, whereD1 = {xsd:integer â†’ integer, xsd:stringâ†’ string, xsd:nonNegativeInteger â†’â‰¥0, xsdx:integerLessThanN â†’<N},B1 = {xsd:integer, xsd:string},dom1 = {xsd:integer â†’ xsd:integer,xsd:string â†’ xsd:string, xsd:nonNegativeIntegerâ†’ xsd:integer, xsdx:integerLessThanN â†’xsd:integer}.According to D1, we have S1 = {xsd:integer,xsd:string, xsd:nonNegativeInteger, xsdx:integerGreaterThanN},hence we have B1 âŠ† S1. Note that the valuespace of <N isV(<N) = {i âˆˆ V(integer) | i< L2S(integer)(N)} and by<N we mean there exists a built-indatatype <N for each integerL2S(integer)(N).In a unary datatype group, datatype expressions can be used torepresent user defined datatypes."datatype-expression">[Definition:] Let G be a unarydatatype group, the set unary datatype expressions for G,abbreviated Dexp(G), is inductively defined as follows:let u be a datatype URI reference, u âˆˆ DPexp(G);let u be a datatype URI reference, its (relativised) negationnot(u) âˆˆ DPexp(G);let y1, ..., yn be literals, theenumerated datatype oneOf(y1, ..., yn) âˆˆDPexp(G);for any p,q âˆˆ DPexp(G), their conjunction and(p,q) âˆˆDPexp(G);for any p,q âˆˆ DPexp(G), their disjunction or(p,q) âˆˆDPexp(G).Example CThe XML Schema user defined datatype humanAge defined in[Example 1A] can be represented by thefollowing unary datatype expression:and(xsd:nonNegativeInteger,xsdx:integerLessThan150)."dt-interpretation-datatype-group">[Definition:] A datatypeinterpretation of a unary datatype group G = (D,B,dom) is apair (LV,ED), where the datatype domain LV is a non-empty set andED is a datatype interpretation function that has to satisfies thefollowing conditions:ED(rdfs:Literal)=LV and ED(rdfsx:DatatypeBottom)} = âˆ….For each plain literal pl, ED(pl) = pl âˆˆ PL and PL âŠ† LV.For any two primitivebase datatype URI references u1 and u2,ED(u1) âˆ© ED(u2) = âˆ….For each supported datatype URI reference u âˆˆ S (let d = D(u)):ED(u) = V(d) âŠ† V(D(dom(u))) âŠ† LV, L(D(u)) âŠ† L(D(dom(u)) andL2S(D(u)) âŠ† L2S(D(dom(u)),if s âˆˆ L(d), then ED("s"^^u) = L2V(d)(s);otherwise, ED("s"^^u) is not defined.For each unsupported datatype URI reference u âˆ‰ S, ED(u) âŠ† LVand "s"^^u âˆˆ ED(u).The datatype interpretation function ED can be extended to providesemantics to unary datatype expressions as follows:Relativised negations: if u âˆˆ S \ D, ED(not(u)) = ED(dom(U)) \ED(u); otherwise, ED(not(u)) = LV \ ED(u).Enumerated datatypes: ED(oneOf(y1, ...,yn)) = {ED(y1)}âˆª ... âˆª{ED(yn)}.Conjunctions: ED(and(p,q)) = ED(p) âˆ© ED(q).Disjunctions: ED(or(p,q)) = ED(p) âˆª ED(q).[PH 2005] shows that we can combineany decidable DL (including SHOIN, the underpinning of OWL DL)that provides the conjunction and bottom constructors with aconforming unary datatype group and the combined DL is stilldecidable.Appendix C: Changes sinceWorking Draft of 27 April 2005C.1 Typos etc.'Semanitcs' in introduction.Updated syntax for XML Schema Component Designators.Deleted broken link from description of[ISO 11404]. Added reference to ISO homepage instead.C.2 Discussion removalThe earlier draft was a discussion document.This note is not intended as such, so some issues,particularly to do with the interactions between variousstandards, recommendations, RFCs etc. has been removed.RemovedDAML+OIL solution.Removedtrue values solution.RemovedXPath eq solution.Moved OWL syntax example from DAML+OIL section to the end ofid section.In theXML Schema Component Designator section:Discussion of relationship between XSCD, XPointerand RFC 3023 has been removed.Discussion about the exact semantics of anXSCD fragment has been removed.Deleted words "(less contentious)" and "Moreover, "from id solution.ChangedXML Schema Component Designator section, to indicate thatXSCD is a good practice. In particular, see last paragraph.Changeddiscussion subsection on user defined datatypesto suggest that both the (remaining) solutions are appropriate,and have no discussion. Changed title to Suggested Practice.Discussion ofharder examples cut downsubstantially, since these are all triviallynon-entailments with the agreed semantics.Removed EDITORS' OPINION notes.C.3 Changes in response to comment from Ashok MalhotraDeleted all uses of the word "derivation" in section 1.3 since it hascaused confusion. Added links to the XML Schema document for union, list and restriction,to make it clear that the intended concept is "derivation"as defined by that document.Added brief discussionof target namespace after example 2Aproviding further examples example 2B andexample 2C.Scoped this document to notaddress "XML Schema [...] assembled from multiple schemadocuments".Added reference [XML SCHEMA1].In theXML Schema Component Designator section: added more extended discussion of target namespace issue;andadded example XSCD for schema with target namespace.Added text showing how the@id solution doescomply with the secondary resource concept from RFC 3986,when read in conjunction with RDF Concepts, XPointer and XML Schema.C.4 Restructuring of section 3Reordered subsections in section 3,deletingold3.5,3.6 and 3.7, and ordering theremaining subsections as follows:3.1,3.4,3.2, 3.3. Followed by renumbering.Text discussing examples has changed, and the change trackingis not detailed.Moved definition ofprimitive base datatypefrom the examplessubsection to theformal analysis subsection.Deleted references to the examplesfrom the new section 3.2 (was3.4)Added exampleSPARQL query, to show howto use = in SPARQL to compare across the type hierarchy.Added an updated discussion of mapsTo.C.5 Other changesAddedfurther acknowledgements.Updated reference to RFC 2396 to be to RFC 3986UpdatedTable of ContentsRemoved unusedreferences.Updated versions ofW3C WD's in references.