XML Signature Syntax and Processing Version 1.1* ReSpec 3 CSS* Robin Berjon - http://berjon.com/*****************************************************************//* --- INLINES --- */em.rfc2119 {text-transform: lowercase;font-variant: small-caps;font-style: normal;color: #900;}h1 acronym, h2 acronym, h3 acronym, h4 acronym, h5 acronym, h6 acronym, a acronym,h1 abbr, h2 abbr, h3 abbr, h4 abbr, h5 abbr, h6 abbr, a abbr {border: none;}dfn {font-weight: bold;}a.internalDFN {color: inherit;border-bottom: 1px solid #99c;text-decoration: none;}a.externalDFN {color: inherit;border-bottom: 1px dotted #ccc;text-decoration: none;}a.bibref {text-decoration: none;}cite .bibref {font-style: normal;}code {color: #ff4500;}/* --- --- */ol.algorithm { counter-reset:numsection; list-style-type: none; }ol.algorithm li { margin: 0.5em 0; }ol.algorithm li:before { font-weight: bold; counter-increment: numsection; content: counters(numsection, ".") ") "; }/* --- TOC --- */.toc a, .tof a {text-decoration: none;}a .secno, a .figno {color: #000;}ul.tof, ol.tof {list-style: none outside none;}.caption {margin-top: 0.5em;font-style: italic;}/* --- TABLE --- */table.simple {border-spacing: 0;border-collapse: collapse;border-bottom: 3px solid #005a9c;}.simple th {background: #005a9c;color: #fff;padding: 3px 5px;text-align: left;}.simple th[scope="row"] {background: inherit;color: inherit;border-top: 1px solid #ddd;}.simple td {padding: 3px 10px;border-top: 1px solid #ddd;}.simple tr:nth-child(even) {background: #f0f6ff;}/* --- DL --- */.section dd > p:first-child {margin-top: 0;}.section dd > p:last-child {margin-bottom: 0;}.section dd {margin-bottom: 1em;}.section dl.attrs dd, .section dl.eldef dd {margin-bottom: 0;}div.example-title {min-width: 7.5em;color: #b9ab2d;}div.example-title span {text-transform: uppercase;}aside.example, div.example, div.illegal-example {padding: 0.5em;margin: 1em 0;position: relative;clear: both;}div.illegal-example { color: red }div.illegal-example p { color: black }aside.example, div.example {padding: .5em;border-left-width: .5em;border-left-style: solid;border-color: #e0cb52;background: #fcfaee;}aside.example div.example {border-left-width: .1em;border-color: #999;background: #fff;}aside.example div.example div.example-title {color: #999;}code.prettyprint {color: inherit;}/* this from google-code-prettify */.pln{color:#000}@media screen{.str{color:#080}.kwd{color:#008}.com{color:#800}.typ{color:#606}.lit{color:#066}.pun,.opn,.clo{color:#660}.tag{color:#008}.atn{color:#606}.atv{color:#080}.dec,.var{color:#606}.fun{color:red}}@media print,projection{.str{color:#060}.kwd{color:#006;font-weight:bold}.com{color:#600;font-style:italic}.typ{color:#404;font-weight:bold}.lit{color:#044}.pun,.opn,.clo{color:#440}.tag{color:#006;font-weight:bold}.atn{color:#404}.atv{color:#060}}ol.linenums{margin-top:0;margin-bottom:0}li.L0,li.L1,li.L2,li.L3,li.L5,li.L6,li.L7,li.L8{list-style-type:none}li.L1,li.L3,li.L5,li.L7,li.L9{background:#eee}XML Signature Syntax and Processing Version 1.1W3C Recommendation 11 April 2013This version:http://www.w3.org/TR/2013/REC-xmldsig-core1-20130411/Latest published version:http://www.w3.org/TR/xmldsig-core1/Latest editor's draft:http://www.w3.org/2008/xmlsec/Drafts/xmldsig-core-11/Previous version:http://www.w3.org/TR/2013/PR-xmldsig-core1-20130124/Editors:Donald Eastlake, d3e3e3@gmail.comJoseph Reagle, reagle@mit.eduDavid Solo, dsolo@alum.mit.eduFrederick Hirsch, frederick.hirsch@nokia.com (2nd edition, 1.1)Magnus NystrÃ¶m, mnystrom@microsoft.com (1.1)Thomas Roessler, tlr@w3.org (2nd edition, 1.1)Kelvin Yiu, kelviny@microsoft.com (1.1)Authors:Mark Bartel, mbartel@adobe.comJohn Boyer, boyerj@ca.ibm.comBarb Fox, bfox@Exchange.Microsoft.comBrian LaMacchia, bal@microsoft.comEd Simon, edsimon@xmlsec.comPlease refer to the errata for this document, which may include some normative corrections.The English version of this specification is the only normative version. Non-normativetranslations may also be available.Copyright Â©2013The IETF Trust &W3CÂ®(MIT,ERCIM,Keio, Beihang), All Rights Reserved.W3C liability,trademark anddocument use rules apply.AbstractThis document specifies XML digital signature processing rulesand syntax. XML Signatures provide integrity, message authentication, and/or signerauthentication services for data of any type, whether located within theXML that includes the signature or elsewhere.Status of This DocumentNote: On 23 April 2013, the reference to the "Additional XML Security URIs" RFC was updated. The Director previously authorized the publication knowing that the reference would be updated in a near future.This section describes the status of this document at the time of its publication. Otherdocuments may supersede this document. A list of current W3C publications and the latest revisionof this technical report can be found in the W3C technical reportsindex at http://www.w3.org/TR/.This document has been reviewed by W3C Members, by softwaredevelopers, and by other W3C groups and interested parties, andis endorsed by the Director as a W3C Recommendation. It is astable document and may be used as reference material or citedfrom another document. W3C's role in making the Recommendationis to draw attention to the specification and to promote itswidespread deployment. This enhances the functionality andinteroperability of the Web.The original version ofthis specification was produced by the IETF/W3C XML Signature Working Group; the InteroperabilityReport shows at least 10 implementations with at least twointeroperable implementations over every feature.The SecondEdition was produced by the W3CXML Security SpecificationsMaintenance Working Group, adding Canonical XML 1.1 as arequired canonicalization algorithm and incorporating knownerrata. A detailedlist of Second Edition changes is available as is aSecondEdition implementation report demonstrating four or moreimplementations of all new features.Conformance-affecting changes of XML Signature 1.1 against this previousrecommendation mainly affect the set ofmandatory to implement cryptographic algorithms, including EllipticCurve DSA (and mark-up forcorresponding key material), and additional hashalgorithms.Adetailed explanation of changes sincethe last Recommendation areavailable [XMLDSIG-CORE1-CHGS].Changes are also described in a diff document showing changes sincethe Second Edition, as well as a diff document showing changessince the previous PR draft.Please refer tothe implementationreport for version 1.1 of this specification foradditional details about the implementation status offeatures added in this revision.This document was published by the XML Security Working Group as a Recommendation.If you wish to make comments regarding this document, please send them topublic-xmlsec@w3.org(subscribe,archives).All comments are welcome.This document was produced by a group operating under the5 February 2004 W3C Patent Policy.W3C maintains a public list of any patent disclosuresmade in connection with the deliverables of the group; that page also includes instructions fordisclosing a patent. An individual who has actual knowledge of a patent which the individual believes containsEssential Claim(s) must disclose theinformation in accordance with section6 of the W3C Patent Policy.Additional information related to the IPR status of XML Signature 1.1 is available.Table of Contents 1. Introduction 1.1 Conformance 1.2 Design Philosophy 1.3 Versions, Namespaces and Identifiers 1.4 Acknowledgements 2. Signature Overview and Examples 2.1 Simple Example (Signature,SignedInfo, Methods, andReferences) 2.1.1 More on Reference 2.2 Extended Example (Object and SignatureProperty) 2.3 Extended Example (Object and Manifest) 3. Processing Rules 3.1 Signature Generation 3.1.1 Reference Generation 3.1.2 Signature Generation 3.2 Core Validation 3.2.1 Reference Validation 3.2.2 Signature Validation 4. Core Signature Syntax 4.1 The ds:CryptoBinary Simple Type 4.2 The Signature element 4.3 The SignatureValue Element 4.4 The SignedInfo Element 4.4.1 The CanonicalizationMethod Element 4.4.2 The SignatureMethod Element 4.4.3 The Reference Element 4.4.3.1 The URI Attribute 4.4.3.2 The Reference Processing Model 4.4.3.3 Same-Document URI-References 4.4.3.4 The Transforms Element 4.4.3.5 The DigestMethod Element 4.4.3.6 The DigestValue Element 4.5 The KeyInfo Element 4.5.1 The KeyName Element 4.5.2 The KeyValue Element 4.5.2.1 The DSAKeyValue Element 4.5.2.2 The RSAKeyValue Element 4.5.2.3 The ECKeyValue Element 4.5.2.3.1 Explicit Curve Parameters 4.5.2.3.2 Compatibility with RFC 4050 4.5.3 The RetrievalMethod Element 4.5.4 The X509Data Element 4.5.4.1 Distinguished Name Encoding Rules 4.5.5 The PGPData Element 4.5.6 The SPKIData Element 4.5.7 The MgmtData Element 4.5.8 XML Encryption EncryptedKeyand DerivedKey Elements 4.5.9 The DEREncodedKeyValue Element 4.5.10 The KeyInfoReference Element 4.6 The Object Element 5. Additional Signature Syntax 5.1 The Manifest Element 5.2 The SignatureProperties Element 5.3 Processing Instructions in Signature Elements 5.4 Comments in Signature Elements 6. Algorithms 6.1 Algorithm Identifiers and Implementation Requirements 6.2 Message Digests 6.2.1 SHA-1 6.2.2 SHA-224 6.2.3 SHA-256 6.2.4 SHA-384 6.2.5 SHA-512 6.3 Message AuthenticationCodes 6.3.1 HMAC 6.4 Signature Algorithms 6.4.1 DSA 6.4.2 RSA (PKCS#1 v1.5) 6.4.3 ECDSA 6.5 Canonicalization Algorithms 6.5.1 Canonical XML 1.0 6.5.2 Canonical XML 1.1 6.5.3 Exclusive XML Canonicalization 1.0 6.6 Transform Algorithms 6.6.1 Canonicalization 6.6.2 Base64 6.6.3 XPath Filtering 6.6.4 Enveloped Signature Transform 6.6.5 XSLT Transform 7. XML Canonicalization and Syntax Constraint Considerations 7.1 XML 1.0 Syntax Constraints, and Canonicalization 7.2 DOM/SAX Processing and Canonicalization 7.3 Namespace Context and Portable Signatures 8. Security Considerations 8.1 Transforms 8.1.1 Only What is Signed is Secure 8.1.2 Only What is "Seen" Should be Signed 8.1.3 "See" What is Signed 8.2 Check the Security Model 8.3 Algorithms, Key Lengths, Certificates, Etc. 8.4 Error Messages 9. Schema 9.1 XSD Schema 9.2 RNG Schema 10. Definitions A. References A.1 Normative references A.2 Informative references1. IntroductionThis document specifies XML syntax and processing rules for creating andrepresenting digital signatures. XML Signatures can be applied to any digital content (data object), including XML. An XMLSignature may be applied to the content of one or more resources. Enveloped or enveloping signatures are over data withinthe same XML document as the signature; detached signatures are over data external to the signatureelement. More specifically, this specification defines an XML signatureelement type and an XML signatureapplication; conformance requirements for each are specified by way ofschema definitions and prose respectively. This specification also includesother useful types that identify methods for referencing collections ofresources, algorithms, and keying and management information.The XML Signature is a method of associating a key with referenced data(octets); it does not normatively specify how keys are associated with personsor institutions, nor the meaning of the data being referenced and signed.Consequently, while this specification is an important component of secure XMLapplications, it itself is not sufficient to address all applicationsecurity/trust concerns, particularly with respect to using signed XML (orother data formats) as a basis of human-to-human communication and agreement.Such an application must specify additional key, algorithm, processing andrendering requirements. For further information, please seesee section 8. Security Considerations.The Working Group encourages implementers and developers to readXML Signature Best Practices [XMLDSIG-BESTPRACTICES]. Itcontains a number of best practices related to the use of XMLSignature, including implementation considerations and practical waysof improving security.1.1 ConformanceFor readability, brevity, and historic reasons this document uses the term"signature" to generally refer to digital authentication values of all types.Obviously, the term is also strictly used to refer to authentication valuesthat are based on public keys and that provide signer authentication. Whenspecifically discussing authentication values based on symmetric secret keycodes we use the terms authenticators or authenticationcodes. (See section 8.2 Check the Security Model.)This specification provides a normative XML Schema[XMLSCHEMA-1], [XMLSCHEMA-2]. The full normative grammar isdefined by the XSD schema and the normative text in thisspecification. The standalone XSD schema file is authoritative incase there is any disagreement between it and the XSD schemaportions in this specification.The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT","SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in thisspecification are to be interpreted as described in [RFC2119]."They MUST only be used where it is actually required for interoperationor to limit behavior which has potential for causing harm (e.g., limitingretransmissions)"Consequently, we use these capitalized key words to unambiguously specifyrequirements over protocol and application features and behavior that affectthe interoperability and security of implementations. These key words are notused (capitalized) to describe XML grammar; schema definitions unambiguouslydescribe such requirements and we wish to reserve the prominence of theseterms for the natural language descriptions of protocols and features. Forinstance, an XML attribute might be described as being "optional." Compliancewith the Namespaces in XML specification [XML-NAMES] is describedas "REQUIRED."This document specifies optional and mandatory to supportalgorithms, providing references for these algorithms. This meansthat a conformant implementation should for given inputs be ableto produce outputs for those algorithms that interoperate asspecified in the referenced specification. A conformantimplementation may use any technique to achieve the results as-ifit were implemented according to the referenced specification, butis not required to follow detailed implementation techniques ofthat specification.1.2 Design PhilosophyThe design philosophy and requirements of this specification are addressedin the original XML-Signature Requirements document[XMLDSIG-REQUIREMENTS] and the XML Security 1.1 Requirementsdocument [XMLSEC11-REQS].1.3 Versions, Namespaces and IdentifiersThis specification makes use of XML namespaces, and uses UniformResource Identifiers [URI] to identify resources, algorithms, andsemantics.Implementations of this specification MUST use the following XMLnamespace URIs:URInamespace prefixXML internal entityhttp://www.w3.org/2000/09/xmldsig#default namespace,ds:, dsig:<!ENTITY dsig "http://www.w3.org/2000/09/xmldsig#">http://www.w3.org/2009/xmldsig11#dsig11:<!ENTITY dsig11 "http://www.w3.org/2009/xmldsig11#">While implementations MUST support XML and XML namespaces, and while use of the above namespaceURIs is REQUIRED, the namespace prefixes and entity declarationsgiven are merely editorialconventions used in this document. Their use by implementations is OPTIONAL.These namespace URIs are also used as the prefix for algorithm identifiers that are undercontrol of this specification. For resources not under the control of this specification, we usethe designated Uniform Resource Names [URN], [RFC3406]or UniformResource Identifiers [URI] defined by the relevant normativeexternal specification.The http://www.w3.org/2000/09/xmldsig# (dsig:) namespace wasintroduced in the first edition of this specification. This version does not coin any newelements or algorithm identifiers in that namespace; instead, thehttp://www.w3.org/2009/xmldsig11# (dsig11:)namespaceis used.This specification uses algorithm identifiers in the namespacehttp://www.w3.org/2001/04/xmldsig-more# that were originallycoined in [RFC6931]. RFC 6931 associates these identifierswith specific algorithms. Implementations of this specificationMUST be fully interoperable with the algorithms specified in[RFC6931], but MAY compute the requisite values through anytechnique that leads to the same output.Examples of items in various namespaces include:SignatureProperties is identified and defined by the disg:namespacehttp://www.w3.org/2000/09/xmldsig#SignaturePropertiesECKeyValue is identified and defined by thedsig11: namespacehttp://www.w3.org/2009/xmldsig11#ECKeyValueXSLT is identified and defined by an external URIhttp://www.w3.org/TR/1999/REC-xslt-19991116SHA1 is identified via thisspecification's namespace and defined via a normative reference [FIPS-180-3]http://www.w3.org/2001/04/xmlenc#sha256FIPS PUB 180-3. Secure Hash Standard. U.S. Department ofCommerce/National Institute of Standards and Technology.No provision is made for an explicit version number in this syntax. If a future version ofthis specification requires explicit versioning of the document format, a different namespace willbe used.1.4 AcknowledgementsThe contributions of the members of the XML Signature WorkingGroup to the first edition specification aregratefully acknowledged: Mark Bartel, Adobe, was Accelio (Author); John Boyer, IBM (Author);Mariano P. Consens, University of Waterloo; John Cowan, Reuters Health; Donald Eastlake 3rd,Motorola  (Chair, Author/Editor); Barb Fox, Microsoft (Author); Christian Geuer-Pollmann,University Siegen; Tom Gindin, IBM; Phillip Hallam-Baker, VeriSign Inc; Richard Himes, US Courts;Merlin Hughes, Baltimore; Gregor Karlinger, IAIK TU Graz; Brian LaMacchia, Microsoft (Author);Peter Lipp, IAIK TU Graz; Joseph Reagle, NYU, was W3C (Chair, Author/Editor); Ed Simon, XMLsec(Author); David Solo, Citigroup (Author/Editor); Petteri Stenius, Capslock; Raghavan Srinivas,Sun; Kent Tamura, IBM; Winchel Todd Vincent III, GSU; Carl Wallace, Corsec Security, Inc.; GregWhitehead, Signio Inc.As are the first edition Last Call comments from the following:Dan Connolly, W3CPaul Biron, Kaiser Permanente, on behalf of the XML Schema WG.Martin J. Duerst, W3C; and Masahiro Sekiguchi, Fujitsu; on behalf of the Internationalization WG/IG.Jonathan Marsh, Microsoft, on behalf of the Extensible Stylesheet LanguageWG.The following members of the XML Security Specification Maintenance Working Group contributedto the second edition: Juan Carlos Cruellas, Universitat PolitÃ¨cnica de Catalunya; PratikDatta, Oracle Corporation; Phillip Hallam-Baker, VeriSign, Inc.; Frederick Hirsch, Nokia, (Chair,Editor); Konrad Lanz, Applied Information processing and Kommunications (IAIK); Hal Lockhart, BEASystems, Inc.; Robert Miller, MITRE Corporation; Sean Mullan, Sun Microsystems, Inc.; Bruce Rich,IBM Corporation; Thomas Roessler, W3C/ERCIM, (Staff contact, Editor); Ed Simon, W3C InvitedExpert; Greg Whitehead, HP.Contributions for version 1.1 were received from the members of the XML Security Working Group:Scott Cantor, Juan Carlos Cruellas, Pratik Datta, Gerald Edgar, Ken Graf, Phillip Hallam-Baker,Brad Hill, Frederick Hirsch (Chair,Editor), Brian LaMacchia, Konrad Lanz, Hal Lockhart, Cynthia Martin, RobMiller, Sean Mullan, Shivaram Mysore, Magnus NystrÃ¶m, Bruce Rich, Thomas Roessler (Staff contact, Editor), Ed Simon, ChrisSolc, John Wray, Kelvin Yiu (Editor).The Working Group thanks Makoto Murata for assistance with theRELAX NG schemas.2. Signature Overview and ExamplesThis section provides an overview and examples of XML digital signaturesyntax. The specific processing is given insection 3. Processing Rules.The formalsyntax is found in section 4. Core Signature Syntaxand section 5. Additional Signature Syntax.In this section, an informal representation and examples are used todescribe the structure of the XML signature syntax. This representation andexamples may omit attributes, details and potential features that are fullyexplained later.XML Signatures are applied to arbitrary digital content (data objects)via an indirection. Data objects are digested, the resulting value is placedin an element (with other information) and that element is then digested andcryptographically signed. XML digital signatures are represented by theSignature element which has the following structure (where "?" denoteszero or one occurrence; "+" denotes one or more occurrences; and "*" denoteszero or more occurrences):Example 1 <Signature ID?><SignedInfo><CanonicalizationMethod /><SignatureMethod />(<Reference URI? >(<Transforms>)?<DigestMethod><DigestValue></Reference>)+</SignedInfo><SignatureValue>(<KeyInfo>)?(<Object ID?>)*</Signature>Signatures are related to data objects via URIs [URI]. Within an XML document, signatures arerelated to local data objects via fragment identifiers. Such local data can beincluded within an enveloping signature or can enclose an enveloped signature. Detached signatures are over externalnetwork resources or local data objects that reside within the same XMLdocument as sibling elements; in this case, the signature is neitherenveloping (signature is parent) nor enveloped (signature is child). Since aSignatureelement (and its Id attribute value/name) may co-exist or becombined with other elements (and their IDs) within a single XML document,care should be taken in choosing names such that there are no subsequentcollisions that violate theID uniqueness validity constraint [XML10].2.1 Simple Example (Signature,SignedInfo, Methods, andReferences)The following example is a detached signature of the content of the HTML4in XML specification.Example 2 [s01] <Signature Id="MyFirstSignature" xmlns="http://www.w3.org/2000/09/xmldsig#">[s02] <SignedInfo>[s03] <CanonicalizationMethod Algorithm="http://www.w3.org/2006/12/xml-c14n11"/>[s04] <SignatureMethod Algorithm="http://www.w3.org/2001/04/xmldsig-more#rsa-sha256"/>[s05] <Reference URI="http://www.w3.org/TR/2000/REC-xhtml1-20000126/">[s06] <Transforms>[s07] <Transform Algorithm="http://www.w3.org/2006/12/xml-c14n11"/>[s08] </Transforms>[s09] <DigestMethod Algorithm="http://www.w3.org/2001/04/xmlenc#sha256"/>[s10] <DigestValue>dGhpcyBpcyBub3QgYSBzaWduYXR1cmUK...</DigestValue>[s11] </Reference>[s12] </SignedInfo>[s13] <SignatureValue>...</SignatureValue>[s14] <KeyInfo>[s15a] <KeyValue>[s15b] <DSAKeyValue>[s15c] <P>...</P><Q>...</Q><G>...</G><Y>...</Y>[s15d] </DSAKeyValue>[s15e] </KeyValue>[s16] </KeyInfo>[s17] </Signature>[s02-12] The required SignedInfoelement is the information that is actually signed. Core validation ofSignedInfo consists of two mandatory processes: validation of the signature overSignedInfo and validation of eachReference digest withinSignedInfo. Note thatthe algorithms used in calculating theSignatureValue are also included in the signed information whilethe SignatureValue element is outside SignedInfo.[s03] The CanonicalizationMethod is the algorithmthat is used to canonicalize theSignedInfo element before it is digested as part of the signatureoperation.Note that this example is not in canonical form. (None of the examples in thisspecification are in canonical form.)[s04] The SignatureMethod is the algorithm thatis used to convert the canonicalizedSignedInfo into the SignatureValue. It is acombination of a digest algorithm and a key dependent algorithm and possiblyother algorithms such as padding, for example RSA-SHA1. The algorithm namesare signed to resist attacks based on substituting a weaker algorithm. Topromote application interoperability we specify a set of signature algorithmsthat MUST be implemented, though their use is at the discretion of thesignature creator. We specify additional algorithms as RECOMMENDED or OPTIONALfor implementation; the design also permits arbitrary user specifiedalgorithms.[s05-11] Each Reference element includes thedigest method and resulting digest value calculated over the identified dataobject. It also may include transformations that produced the input to thedigest operation. A data object is signed by computing its digest value and asignature over that value. The signature is later checked viareference and signature validation.[s14-16] KeyInfo indicates the key to be used tovalidate the signature. Possible forms for identification includecertificates, key names, and key agreement algorithms and information -- wedefine only a few.KeyInfo is optional for two reasons. First, the signer may notwish to reveal key information to all document processing parties. Second, theinformation may be known within the application's context and need not berepresented explicitly. Since KeyInfo is outside ofSignedInfo, if the signer wishes to bind the keying information to thesignature, a Reference can easily identify and include theKeyInfo as part of the signature.Use of KeyInfo is optional, however note that senders and receiversmust agree on how it will be used through a mechanism out of scope forthis specification.2.1.1 More on ReferenceExample 3 [s05]   <Reference URI="http://www.w3.org/TR/2000/REC-xhtml1-20000126/">[s06] <Transforms>[s07] <Transform Algorithm="http://www.w3.org/2006/12/xml-c14n11"/>[s08] </Transforms>[s09] <DigestMethod Algorithm="http://www.w3.org/2001/04/xmlenc#sha256"/>[s10] <DigestValue>dGhpcyBpcyBub3QgYSBzaWduYXR1cmUK...</DigestValue>[s11] </Reference>[s05] The optional URI attribute ofReference identifies the data object to be signed. This attributemay be omitted on at most oneReference in a Signature. (This limitation isimposed in order to ensure that references and objects may be matchedunambiguously.)[s05-08] This identification, along with the transforms, is adescription provided by the signer on how they obtained the signed data objectin the form it was digested (i.e. the digested content). The verifier mayobtain the digested content in another method so long as the digest verifies.In particular, the verifier may obtain the content from a different locationsuch as a local store than that specified in theURI.[s06-08] Transforms is an optional ordered list of processingsteps that were applied to the resource's content before it was digested.Transforms can include operations such as canonicalization, encoding/decoding(including compression/inflation), XSLT, XPath, XML schema validation, orXInclude. XPath transforms permit the signer to derive an XML document thatomits portions of the source document. Consequently those excluded portionscan change without affecting signature validity. For example, if the resourcebeing signed encloses the signature itself, such a transform must be used toexclude the signature value from its own computation. If noTransforms element is present, the resource's content is digesteddirectly. While the Working Group has specified mandatory (and optional)canonicalization and decoding algorithms, user specified transforms arepermitted.[s09-10] DigestMethod is the algorithm applied to the dataafter Transforms is applied (if specified) to yield theDigestValue. The signing of theDigestValue is what binds the content of a resource tothe signer'skey.2.2 Extended Example (Object and SignatureProperty)This specification does not address mechanisms for making statements orassertions. Instead, this document defines what it means for something to besigned by an XML Signature (integrity,message authentication, and/or signerauthentication). Applications that wish to represent other semantics mustrely upon other technologies, such as [XML10], [RDF-PRIMER]. Forinstance, an application might use afoo:assuredby attribute within its own markup to reference aSignature element. Consequently, it's the application that mustunderstand and know how to make trust decisions given the validity of thesignature and the meaning ofassuredby syntax. We also define aSignatureProperties element type for the inclusion of assertionsabout the signature itself (e.g., signature semantics, the time of signing orthe serial number of hardware used in cryptographic processes). Suchassertions may be signed by including a Reference for theSignatureProperties in SignedInfo. While the signingapplication should be very careful about what it signs (it should understandwhat is in theSignatureProperty) a receiving application has no obligation tounderstand that semantic (though its parent trust engine may wish to). Anycontent about the signature generation may be located within theSignatureProperty element. The mandatory Target attributereferences theSignature element to which the property applies.Consider the preceding example with an additional reference to a localObject that includes aSignatureProperty element. (Such a signature would not only be detached [p02] but enveloping [p03].)Example 4 [   ]  <Signature Id="MySecondSignature" ...>[p01] <SignedInfo>[ ] ...[p02] <Reference URI="http://www.w3.org/TR/xml-stylesheet/">[ ] ...[p03] <Reference URI="#AMadeUpTimeStamp"[p04] Type="http://www.w3.org/2000/09/xmldsig#SignatureProperties">[p05] <Transforms>[p06] <Transform Algorithm="http://www.w3.org/2006/12/xml-c14n11"/>[p07] </Transforms>[p08] <DigestMethod Algorithm="http://www.w3.org/2001/04/xmlenc#sha256"/>[p09] <DigestValue>dGhpcyBpcyBub3QgYSBzaWduYXR1cmUK...</DigestValue>[p10] </Reference>[p11] </SignedInfo>[p12] ...[p13] <Object>[p14] <SignatureProperties>[p15] <SignatureProperty Id="AMadeUpTimeStamp" Target="#MySecondSignature">[p16] <timestamp xmlns="http://www.ietf.org/rfcXXXX.txt">[p17] <date>19990914</date>[p18] <time>14:34:34:34</time>[p19] </timestamp>[p20] </SignatureProperty>[p21] </SignatureProperties>[p22] </Object>[p23]</Signature>[p04] The optional Type attribute ofReference provides information about the resource identified bythe URI. In particular, it can indicate that it is anObject,SignatureProperty, or Manifest element. This can beused by applications to initiate special processing of some Referenceelements. References to an XML data element within an Objectelement SHOULD identify the actual element pointed to. Where the elementcontent is not XML (perhaps it is binary or encoded data) the reference shouldidentify the Object and theReference Type, if given, SHOULD indicateObject. Note that Type is advisory and no action based onit or checking of its correctness is required by core behavior.[p13] Object is an optional element for includingdata objects within the signature element or elsewhere. The Objectcan be optionally typed and/or encoded.[p14-21] Signature properties, such as time of signing, can beoptionally signed by identifying them from within a Reference.(These properties are traditionally called signature "attributes" althoughthat term has no relationship to the XML term "attribute".)2.3 Extended Example (Object and Manifest)The Manifest element is provided to meet additionalrequirements not directly addressed by the mandatory parts of thisspecification. Two requirements and the way theManifest satisfies them follow.First, applications frequently need to efficiently sign multiple dataobjects even where the signature operation itself is an expensive public keysignature. This requirement can be met by including multiple Referenceelements withinSignedInfo since the inclusion of each digest secures the datadigested. However, some applications may not want the core validation behavior associated with this approach because itrequires every Reference withinSignedInfo to undergo reference validation -- the DigestValueelements are checked. These applications may wish to reserve referencevalidation decision logic to themselves. For example, an application mightreceive a signature validSignedInfo element that includes threeReference elements. If a singleReference fails (the identified data object when digested doesnot yield the specified DigestValue) the signature would fail core validation. However, the application may wishto treat the signature over the two validReference elements as valid or take different actions dependingon which fails.  To accomplish this,SignedInfo would reference a Manifestelement that contains one or more Reference elements (with thesame structure as those in SignedInfo). Then, referencevalidation of the Manifest is under application control.Second, consider an application where many signatures (using differentkeys) are applied to a large number of documents. An inefficient solution isto have a separate signature (per key) repeatedly applied to a largeSignedInfo element (with many References); this iswasteful and redundant. A more efficient solution is to include manyreferences in a single Manifest that is then referenced frommultiple Signature elements.The example below includes a Reference that signs aManifest found within the Objectelement.Example 5 [   ] ...[m01] <Reference URI="#MyFirstManifest"[m02] Type="http://www.w3.org/2000/09/xmldsig#Manifest">[m03] <Transforms>[m04] <Transform Algorithm="http://www.w3.org/2006/12/xml-c14n11"/>[m05] </Transforms>[m06] <DigestMethod Algorithm="http://www.w3.org/2001/04/xmlenc#sha256"/>[m07] <DigestValue>dGhpcyBpcyBub3QgYSBzaWduYXR1cmUK...=</DigestValue>[m08] </Reference>[ ] ...[m09] <Object>[m10] <Manifest Id="MyFirstManifest">[m11] <Reference>[m12] ...[m13] </Reference>[m14] <Reference>[m15] ...[m16] </Reference>[m17] </Manifest>[m18] </Object>3. Processing RulesThe sections below describe the operations to be performed as part ofsignature generation and validation.3.1 Signature GenerationThe REQUIRED steps include the generation ofReference elements and theSignatureValue over SignedInfo.3.1.1 Reference GenerationFor each data object being signed:Apply the Transforms, as determined by the application, tothe data object.Calculate the digest value over the resulting data object.Create a Reference element, including the (optional)identification of the data object, any (optional) transform elements, thedigest algorithm and theDigestValue.(Note, it is the canonical form of these references that are signed insection 3.1.2 Signature Generation andvalidated insection 3.2.1 Reference Validation.)The Reference Processing Model(section 4.4.3.2 The Reference Processing Model)requires use ofCanonical XML 1.0 [XML-C14N] as default processing behavior when atransformation isexpecting an octet-stream, but the data object resulting from URIdereferencing or from the previous transformation in the list ofTransform elements is a node-set. We RECOMMEND that, when generatingsignatures, signature applications do not rely on this default behavior, butexplicitly identify the transformation that is applied to perform thismapping. In cases in which inclusive canonicalization is desired, we RECOMMENDthat Canonical XML 1.1 [XML-C14N11] be used.< id="EdNote-C14N11-AppendixA1">Editors Note: There has been a correction to Appendix A of the C14N11 Candidate Recommendation. Thiscorrection is available athttp://lists.w3.org/Archives/Public/public-xml-core-wg/2007Jun/att-0050/Apendix_20060625.html.The XML Security Specifications Maintenance WG anticipates this change will be adopted as part ofC14N11 CR review and will use this update to Appendix A for Interop testing.-->3.1.2 Signature GenerationCreate SignedInfo element withSignatureMethod,CanonicalizationMethod andReference(s).Canonicalize and then calculate theSignatureValue over SignedInfo based on algorithmsspecified in SignedInfo.Construct the Signature element that includesSignedInfo, Object(s) (if desired, encoding may bedifferent than that used for signing),KeyInfo (if required), andSignatureValue.Note, if the Signature includes same-document references,[XML10] or [XMLSCHEMA-1], [XMLSCHEMA-2]validation of the document might introduce changes that break thesignature. Consequently, applications should be careful toconsistentlyprocess the document or refrain from using externalcontributions (e.g.,defaults and entities).3.2 Core ValidationThe REQUIRED steps of core validation include (1) reference validation, the verification of the digest contained ineach Reference inSignedInfo, and (2) the cryptographic signature validation of the signature calculated overSignedInfo.Note, there may be valid signatures that some signature applications areunable to validate. Reasons for this include failure to implement optionalparts of this specification, inability or unwillingness to execute specifiedalgorithms, or inability or unwillingness to dereference specified URIs (someURI schemes may cause undesirable side effects), etc.Comparison of each value in reference and signature validation isover thenumeric (e.g., integer) or decoded octet sequence of the value. Differentimplementations may produce different encoded digest and signature values whenprocessing the same resources because of variances in their encoding, such asaccidental white space. But if one uses numeric or octet comparison (chooseone) on both the stated and computed values these problems are eliminated.3.2.1 Reference ValidationCanonicalize the SignedInfo element based on theCanonicalizationMethod inSignedInfo.For each Reference in SignedInfo:Obtain the data object to be digested. (For example, the signatureapplication may dereference theURI and execute Transformsprovided by the signer in the Referenceelement, or it may obtain the content through other means such as alocal cache.)Digest the resulting data object using theDigestMethod specified in itsReference specification.Compare the generated digest value againstDigestValue in the SignedInfoReference; if there is any mismatch, validation fails.Note, SignedInfo is canonicalized in step 1. The applicationmust ensure that the CanonicalizationMethod has nodangerous side effects,such as rewriting URIs, (seenote on Canonicalization Method) and that itSees What is Signed, which is the canonical form.Note, After a Signature element has been created inSignatureGeneration for a signature with a same document reference, animplementation can serialize the XML content with variations in thatserialization. This means that Reference Validation needs tocanonicalize the XML document before digesting in step 1 to avoidissues related to variations in serialization.3.2.2 Signature ValidationObtain the keying information from KeyInfo or from an external source.Obtain the canonical form of theSignatureMethod using theCanonicalizationMethod and use the result (and previouslyobtained KeyInfo) to confirm theSignatureValue over the SignedInfoelement.Note, KeyInfo (or some transformed version thereof) may be signedvia a Reference element. Transformation and validation of thisreference (3.2.1) is orthogonal to Signature Validation which uses theKeyInfo as parsed.Additionally, the SignatureMethod URI may have been altered bythe canonicalization of SignedInfo(e.g., absolutization of relative URIs) and it is the canonical form that MUSTbe used. However, the required canonicalization [XML-C14N]of this specification does not change URIs.4. Core Signature SyntaxThe general structure of an XML signature is described insection 2. Signature Overview and Examples.This section provides detailed syntax of the core signaturefeatures. Features described in this section are mandatory toimplement unlessotherwise indicated. The syntax is defined via an[XMLSCHEMA-1][XMLSCHEMA-2] with the following XMLpreamble, declaration, andinternal entity.Schema Definition: <?xml version="1.0" encoding="utf-8"?><!DOCTYPE schema PUBLIC "-//W3C//DTD XMLSchema 200102//EN"[<!ATTLIST schemaxmlns:ds CDATA #FIXED "http://www.w3.org/2000/09/xmldsig#"><!ENTITY dsig 'http://www.w3.org/2000/09/xmldsig#'><!ENTITY % p ''><!ENTITY % s ''>]><schema xmlns="http://www.w3.org/2001/XMLSchema"xmlns:ds="http://www.w3.org/2000/09/xmldsig#"targetNamespace="http://www.w3.org/2000/09/xmldsig#"version="0.1" elementFormDefault="qualified">Additional markup defined in version 1.1 of thisspecification uses the dsig11:namespace. The syntax is defined in an XML schema with thefollowing preamble:Schema Definition: <?xml version="1.0" encoding="utf-8"?><!DOCTYPE schema PUBLIC "-//W3C//DTD XMLSchema 200102//EN"[<!ENTITY dsig 'http://www.w3.org/2000/09/xmldsig#'><!ENTITY dsig11 'http://www.w3.org/2009/xmldsig11#'><!ENTITY % p ''><!ENTITY % s ''>]><schema xmlns="http://www.w3.org/2001/XMLSchema"xmlns:ds="http://www.w3.org/2000/09/xmldsig#"xmlns:dsig11="http://www.w3.org/2009/xmldsig11#"targetNamespace="http://www.w3.org/2009/xmldsig11#"version="0.1" elementFormDefault="qualified">4.1 The ds:CryptoBinary Simple TypeThis specification defines the ds:CryptoBinarysimple type for representing arbitrary-length integers (e.g. "bignums") in XMLas octet strings. The integer value is first converted to a "big endian"bitstring. The bitstring is then padded with leading zero bits so that thetotal number of bits == 0 mod 8 (so that there are an integral number ofoctets). If the bitstring contains entire leading octets that are zero, theseare removed (so the high-order octet is always non-zero). This octet string isthen base64 [RFC2045] encoded. (Theconversion from integer to octet string is equivalent to IEEE 1363'sI2OSP[IEEE1363]with minimal length).This type is used by "bignum" values such asRSAKeyValue and DSAKeyValue. If a value can be oftype base64Binary ords:CryptoBinary they are defined as base64Binary. For example, if the signature algorithmis RSA or DSA thenSignatureValue represents a bignum and could beds:CryptoBinary. However, if HMAC-SHA1 is the signature algorithmthen SignatureValue could have leading zero octets that must bepreserved. ThusSignatureValue is generically defined as of typebase64Binary.Schema Definition: <simpleType name="CryptoBinary"><restriction base="base64Binary" /></simpleType>4.2 The Signature elementThe Signature element is the root element of an XMLSignature.Implementation MUST generatelaxlyschema valid[XMLSCHEMA-1][XMLSCHEMA-2]Signature elements as specified bythe following schema:Schema Definition: <element name="Signature" type="ds:SignatureType"/><complexType name="SignatureType"><sequence><element ref="ds:SignedInfo"/><element ref="ds:SignatureValue"/><element ref="ds:KeyInfo" minOccurs="0"/><element ref="ds:Object" minOccurs="0" maxOccurs="unbounded"/></sequence><attribute name="Id" type="ID" use="optional"/></complexType>4.3 The SignatureValue ElementThe SignatureValue element contains theactual value of thedigital signature; it is always encoded using base64 [RFC2045].Schema Definition: <element name="SignatureValue" type="ds:SignatureValueType" /><complexType name="SignatureValueType"><simpleContent><extension base="base64Binary"><attribute name="Id" type="ID" use="optional"/></extension></simpleContent></complexType>4.4 The SignedInfo ElementThe structure of SignedInfo includes the canonicalizationalgorithm, a signature algorithm, and one or more references. TheSignedInfo element may contain an optional ID attribute that will allowit to be referenced by other signatures and objects.SignedInfo does not include explicit signature or digestproperties (such as calculation time, cryptographic device serial number,etc.). If an application needs to associate properties with the signature ordigest, it may include such information in a SignaturePropertieselement within an Object element.Schema Definition: <element name="SignedInfo" type="ds:SignedInfoType"/><complexType name="SignedInfoType"><sequence><element ref="ds:CanonicalizationMethod"/><element ref="ds:SignatureMethod"/><element ref="ds:Reference" maxOccurs="unbounded"/></sequence><attribute name="Id" type="ID" use="optional"/></complexType>4.4.1 The CanonicalizationMethod ElementCanonicalizationMethod is a required element that specifiesthe canonicalization algorithm applied to theSignedInfo element prior to performing signature calculations.This element uses the general structure for algorithms described insection 6.1 Algorithm Identifiers and Implementation Requirements.Implementations MUST support the REQUIRED canonicalization algorithms.Alternatives to the REQUIRED canonicalization algorithms (section 6.5), such asCanonical XML with Comments (section6.5.1) or a minimal canonicalization (such as CRLF and charsetnormalization),may be explicitly specified but are NOT REQUIRED. Consequently, their use maynot interoperate with other applications that do not support the specifiedalgorithm (see XML Canonicalization and Syntax Constraint Considerations,section 7). Security issues may also arise in the treatment of entityprocessing and comments if non-XML aware canonicalization algorithms are notproperly constrained (see section 8.1.2: OnlyWhat is "Seen" Should be Signed).The way in which the SignedInfo element is presented to thecanonicalization method is dependent on that method. The following applies toalgorithms which process XML as nodes or characters:XML based canonicalization implementations MUST be providedwith an [XPATH]node-set originally formed from the document containing theSignedInfo and currently indicating theSignedInfo, its descendants, and the attribute and namespacenodes of SignedInfo and its descendant elements.Text based canonicalization algorithms (such as CRLF and charsetnormalization) should be provided with the UTF-8 octets that represent thewell-formed SignedInfo element, from the firstcharacter to the lastcharacter of the XML representation, inclusive. This includes the entiretext of the start and end tags of the SignedInfoelement as well as alldescendant markup and character data (i.e., the text) between those tags. Use of text based canonicalization ofSignedInfo is NOT RECOMMENDED.We recommend applications that implement a text-based instead of XML-basedcanonicalization -- such as resource constrained apps -- generatecanonicalized XML as their output serialization so as to mitigateinteroperability and security concerns. For instance, such an implementationSHOULD (at least) generatestandalone XMLinstances [XML10].Note: The signatureapplication must exercise great care in accepting and executing an arbitraryCanonicalizationMethod. For example, the canonicalization method couldrewrite the URIs of the References being validated. Or, themethod could massively transform SignedInfo so that validationwould always succeed (i.e., converting it to a trivial signature with a knownkey over trivial data). SinceCanonicalizationMethod is insideSignedInfo, in the resulting canonical form it could erase itselffrom SignedInfo or modify theSignedInfo element so that it appears that a differentcanonicalization function was used! Thus aSignature which appears to authenticate the desired data with thedesired key, DigestMethod, andSignatureMethod, can be meaningless if a capriciousCanonicalizationMethod is used.Schema Definition: <element name="CanonicalizationMethod" type="ds:CanonicalizationMethodType"/><complexType name="CanonicalizationMethodType" mixed="true"><sequence><any namespace="##any" minOccurs="0" maxOccurs="unbounded"/><!-- (0,unbounded) elements from (1,1) namespace --></sequence><attribute name="Algorithm" type="anyURI" use="required"/></complexType>4.4.2 The SignatureMethod ElementSignatureMethod is a required element that specifies thealgorithm used for signature generation and validation. This algorithmidentifies all cryptographic functions involved in the signature operation(e.g. hashing, public key algorithms, MACs, padding, etc.). This element usesthe general structure here for algorithms described insection 6.1 Algorithm Identifiers and Implementation Requirements.While there is a single identifier, that identifier mayspecify a format containing multiple distinct signature values.Schema Definition: <element name="SignatureMethod" type="ds:SignatureMethodType"/><complexType name="SignatureMethodType" mixed="true"><sequence><element name="HMACOutputLength" minOccurs="0"type="ds:HMACOutputLengthType"/><any namespace="##other" minOccurs="0" maxOccurs="unbounded"/><!-- (0,unbounded) elements from (1,1) external namespace --></sequence><attribute name="Algorithm" type="anyURI" use="required"/></complexType>The ds:HMACOutputLength parameter is used for HMAC [HMAC] algorithms. Theparameter specifies a truncation length in bits. If this parameter is trusted without furtherverification, then this can lead to a security bypass[CVE-2009-0217].Signatures MUST be deemed invalid if the truncation length is belowthe larger of (a) half the underlying hash algorithm's output length,and (b) 80 bits.Note that some implementations are known to notaccept truncation lengths that are lower than the underlying hash algorithm's output length.4.4.3 The Reference ElementReference is an element that may occur one or more times. Itspecifies a digest algorithm and digest value, and optionally an identifier ofthe object being signed, the type of the object, and/or a list of transformsto be applied prior to digesting. The identification (URI) and transformsdescribe how the digested content (i.e., the input to the digest method) wascreated. The Type attribute facilitates the processing ofreferenced data. For example, while this specification makes no requirementsover external data, an application may wish to signal that the referent is aManifest. An optional ID attribute permits aReference to be referenced from elsewhere.Schema Definition: <element name="Reference" type="ds:ReferenceType"/><complexType name="ReferenceType"><sequence><element ref="ds:Transforms" minOccurs="0"/><element ref="ds:DigestMethod"/><element ref="ds:DigestValue"/></sequence><attribute name="Id" type="ID" use="optional"/><attribute name="URI" type="anyURI" use="optional"/><attribute name="Type" type="anyURI" use="optional"/></complexType>4.4.3.1 The URI AttributeThe URI attribute identifies a data object using aURI-Reference [URI].The mapping from this attribute's value to a URI reference MUST beperformed as specified in section 3.2.17 of[XMLSCHEMA-2].Additionally: Some existing implementations are known to verify the value ofthe URI attribute against the grammar in [URI].It is therefore safest to perform any necessary escaping while generating theURI attribute.We RECOMMEND XML Signature applications be able to dereference URIs in theHTTP scheme. Dereferencing a URI in the HTTP scheme MUST comply with the Status Code Definitions of [HTTP11] (e.g., 302, 305 and 307 redirects are followed toobtain the entity-body of a 200 status code response). Applications shouldalso be cognizant of the fact that protocol parameter and state information,(such as HTTP cookies, HTML device profiles or content negotiation), mayaffect the content yielded by dereferencing a URI.If a resource is identified by more than one URI, the most specific shouldbe used (e.g. http://www.w3.org/2000/06/interop-pressrelease.html.en insteadof http://www.w3.org/2000/06/interop-pressrelease). (Seesection 3.2 Core Validation for further information on reference processing.)If the URI attribute is omitted altogether, the receivingapplication is expected to know the identity of the object. For example, alightweight data protocol might omit this attribute given the identity of theobject is part of the application context. This attribute may be omitted fromat most one Reference in any particularSignedInfo, or Manifest.The optional Type attribute contains information about the type of objectbeing signed after all ds:Referencetransforms have been applied. This is represented as a URI. For example:Type="http://www.w3.org/2000/09/xmldsig#Object"Type="http://www.w3.org/2000/09/xmldsig#Manifest"The Type attribute applies to the item being pointedat, not its contents.For example, a reference that results in the digesting of an Objectelement containing aSignatureProperties element is still of type#Object. The Type attribute is advisory. No validation of thetype information is required by this specification.4.4.3.2 The Reference Processing ModelNote: XPath is RECOMMENDED. Signature applications need not conformto [XPATH] specification in order toconform to this specification. However, the XPath data model, definitions(e.g., node-sets) and syntax is used within this document in order todescribe functionality for those that want to process XML-as-XML (instead ofoctets) as part of signature generation. For those that want to use thesefeatures, a conformant [XPATH] implementation is one way to implementthese features, but it is not required. Such applications could use asufficiently functional replacement to a node-set and implement only thoseXPath expression behaviors REQUIRED by this specification. However, forsimplicity we generally will use XPath terminology without including thisqualification on every point. Requirements over "XPath node-sets" can includea node-set functional equivalent. Requirements over XPath processing caninclude application behaviors that are equivalent to the corresponding XPathbehavior.The data-type of the result of URI dereferencing or subsequent Transformsis either an octet stream or an XPath node-set.The Transforms specified in this document are defined withrespect to the input they require. The following is the default signatureapplication behavior:If the data object is an octet stream and the next transform requires anode-set, the signature application MUST attempt to parse the octetsyielding the required node-set via [XML10]well-formed processing.If the data object is a node-set and the next transform requires octets,the signature application MUST attempt to convert the node-set to an octetstream using Canonical XML [XML-C14N].Users may specify alternative transforms that override these defaults intransitions between transforms that expect different inputs. The final octetstream contains the data octets being secured. The digest algorithm specifiedbyDigestMethod is then applied to these data octets, resulting inthe DigestValue.Note: Thesection 3.1.1 Reference Generationincludes furtherrestrictions on the reliance upon defined default transformations whenapplications generate signatures.In this specification, a 'same-document' reference is defined as aURI-Reference that consists of a hash sign ('#') followed by a fragment oralternatively consists of an empty URI [URI].Unless the URI-Reference is such a 'same-document' reference , the resultof dereferencing the URI-Reference MUST be an octet stream. In particular, anXML document identified by URI is not parsed by the signature applicationunless the URI is a same-document reference or unless a transform thatrequires XML parsing is applied. (See Transforms (section 4.4.3.4).)When a fragment is preceded by an absolute or relative URI in theURI-Reference, the meaning of the fragment is defined by the resource's MIMEtype [RFC2045]. Even for XML documents, URI dereferencing (including the fragmentprocessing) might be done for the signature application by a proxy. Therefore,reference validation might fail if fragment processing is not performed in astandard way (as defined in the following section for same-documentreferences). Consequently, we RECOMMEND in this case that theURI  attribute not include fragment identifiers and thatsuch processing be specified as anadditional XPath Transformor XPath Filter 2 Transform [XMLDSIG-XPATH-FILTER2].When a fragment is not preceded by a URI in the URI-Reference, XMLSignature applications MUST support the null URI and shortname XPointer [XPTR-FRAMEWORK]. We RECOMMEND support for the same-documentXPointers '#xpointer(/)' and '#xpointer(id('ID'))'if the application also intends to support any canonicalization that preserves comments. (OtherwiseURI="#foo" will automatically remove comments before thecanonicalization can even be invoked due to the processing defined in Same-Document URI-References (section 4.4.3.3).) All other supportfor XPointers is OPTIONAL, especially all support for shortname and otherXPointers in external resources since the application may not have controlover how the fragment is generated (leading to interoperability problems andvalidation failures).'#xpointer(/)' MUST be interpreted to identify theroot node [XPATH]of the document that contains the URI attribute.'#xpointer(id('ID'))' MUST be interpretedto identifythe element node identified by '#element(ID)'[XPTR-ELEMENT] when evaluated withrespect to the document that contains theURI attribute.The original edition of this specification [XMLDSIG-CORE]referenced the XPointerCandidate Recommendation [XPTR-XPOINTER-CR2001]and some implementations support it optionally.That Candidate Recommendation has been superseded by the[XPTR-FRAMEWORK], [XPTR-XMLNS] and [XPTR-ELEMENT] Recommendations,and -- at the time of this edition -- the[XPTR-XPOINTER]Working Draft. Therefore, the use ofthexpointer() scheme [XPTR-XPOINTER] beyond the usagediscussed in this section is discouraged.The following examples demonstrate what the URI attribute identifies andhow it is dereferenced:URI="http://example.com/bar.xml"Identifies the octets that represent the external resource'http://example.com/bar.xml', that is probably an XML document given itsfile extension.URI="http://example.com/bar.xml#chapter1"Identifies the element with ID attribute value 'chapter1' of theexternal XML resource 'http://example.com/bar.xml', provided as an octetstream. Again, for the sake of interoperability, the element identified as'chapter1' should be obtained using an XPath transform rather than a URIfragment (shortname XPointer resolution in external resources is notREQUIRED in this specification).URI=""Identifies the node-set (minus any comment nodes) of the XML resourcecontaining the signatureURI="#chapter1"Identifies a node-set containing the element with ID attribute value'chapter1' of the XML resource containing the signature. XML Signature (andits applications) modify this node-set to include the element plus alldescendants including namespaces and attributes -- but not comments.4.4.3.3 Same-Document URI-ReferencesDereferencing a same-document reference MUST result in an XPath node-setsuitable for use by Canonical XML [XML-C14N]. Specifically, dereferencing a nullURI (URI="") MUST result in an XPath node-set that includes everynon-comment node of the XML document containing the URIattribute. In a fragment URI, the characters after the number sign ('#')character conform to the XPointer syntax [XPTR-FRAMEWORK]. When processing an XPointer, the applicationMUST behave as if the XPointer was evaluated with respect to the XML documentcontaining the URIattribute . The application MUST behave as if the result of XPointerprocessing [XPTR-FRAMEWORK] were a node-set derived from the resultantsubresource as follows:include XPath nodes having full or partial content within thesubresourcereplace the root node with its children (if it is in the node-set)replace any element node E withE plus all descendants of E(text, comment, PI, element) and all namespace and attribute nodes ofE and its descendant elements.if the URI has no fragment identifier or the fragment identifier is ashortname XPointer, then delete all comment nodesThe second to last replacement is necessary because XPointer typicallyindicates a subtree of an XML document's parse tree using just the elementnode at the root of the subtree, whereas Canonical XML treats a node-set as aset of nodes in which absence of descendant nodes results in absence of theirrepresentative text from the canonical form.The last step is performed for null URIs and shortname XPointers . It isnecessary because when [XML-C14N] or [XML-C14N11] is passed anode-set, it processes the node-set as is:with or without comments. Only when it is called with an octet stream does itinvoke its own XPath expressions (default or without comments). Therefore toretain the default behavior of stripping comments when passed a node-set, theyare removed in the last step if the URI is not a scheme-based XPointer. Toretain comments while selecting an element by an identifier ID, usethe following scheme-based XPointer:URI='#xpointer(id('ID'))'. To retain comments whileselecting the entire document, use the following scheme-based XPointer:URI='#xpointer(/)'.The interpretation of these XPointers is defined in The Reference Processing Model(section 4.4.3.2).4.4.3.4 The Transforms ElementThe optional Transforms element contains an ordered list ofTransform elements; these describe how the signer obtained the dataobject that was digested. The output of each Transform serves asinput to the nextTransform. The input to the firstTransform is the result of dereferencing theURI attribute of the Reference element. The outputfrom the last Transform is the input for the DigestMethodalgorithm. When transforms are applied the signer is not signing the native(original) document but the resulting (transformed) document. (See Only What is Signed is Secure(section 8.1.1).)Each Transform consists of anAlgorithm attribute and content parameters, if any, appropriatefor the given algorithm. The Algorithmattribute value specifies the name of the algorithm to be performed, and theTransform content provides additional data to govern the algorithm'sprocessing of the transform input. (See section 6.1 Algorithm Identifiers and Implementation Requirements)As described in The Reference Processing Model (section  4.4.3.2), sometransforms take an XPath node-set as input, while others require an octetstream. If the actual input matches the input needs of the transform, then thetransform operates on the unaltered input. If the transform input requirementdiffers from the format of the actual input, then the input must be converted.Some Transforms may require explicit MIME type, charset (IANAregistered "character set"), or other such informationconcerning the datathey are receiving from an earlier Transform or the source data,although noTransform algorithm specified in this document needs suchexplicit information. Such data characteristics are provided as parameters tothe Transform algorithm and should be described in thespecification for the algorithm.Examples of transforms include but are not limited to base64decoding [RFC2045],canonicalization [XML-C14N], XPath filtering [XPATH], and XSLT [XSLT]. The generic definition of theTransform element also allows application-specific transformalgorithms. For example, the transform could be a decompression routine givenby a Java class appearing as a base64 encoded parameter to a JavaTransform algorithm. However, applications should refrain from usingapplication-specific transforms if they wish their signatures to be verifiableoutside of their application domain. Transform Algorithms(section 6.6) defines the list of standard transformations.Schema Definition: <element name="Transforms" type="ds:TransformsType"/><complexType name="TransformsType"><sequence><element ref="ds:Transform" maxOccurs="unbounded"/></sequence></complexType><element name="Transform" type="ds:TransformType"/><complexType name="TransformType" mixed="true"><choice minOccurs="0" maxOccurs="unbounded"><any namespace="##other" processContents="lax"/><!-- (1,1) elements from (0,unbounded) namespaces --><element name="XPath" type="string"/></choice><attribute name="Algorithm" type="anyURI" use="required"/></complexType>4.4.3.5 The DigestMethod ElementDigestMethod is a required element that identifies the digestalgorithm to be applied to the signed object. This element uses the generalstructure here for algorithms specified in section 6.1 Algorithm Identifiers and Implementation Requirements.If the result of the URI dereference and application of Transforms is anXPath node-set (or sufficiently functional replacement implemented by theapplication) then it must be converted as describedin section 4.4.3.2 The Reference Processing Model. Ifthe result of URI dereference and application of transforms is an octetstream, then no conversion occurs (comments might be present if the CanonicalXML with Comments was specified in the Transforms). The digest algorithm isapplied to the data octets of the resulting octet stream.Schema Definition: <element name="DigestMethod" type="ds:DigestMethodType"/><complexType name="DigestMethodType" mixed="true"><sequence><any namespace="##other" processContents="lax"minOccurs="0" maxOccurs="unbounded"/></sequence><attribute name="Algorithm" type="anyURI" use="required"/></complexType>4.4.3.6 The DigestValue ElementDigestValue is an element that contains the encoded value of the digest.The digest is always encoded using base64 [RFC2045].Schema Definition: <element name="DigestValue" type="ds:DigestValueType"/><simpleType name="DigestValueType"><restriction base="base64Binary"/></simpleType>4.5 The KeyInfo ElementKeyInfo is an optional element that enables the recipient(s)to obtain the key needed to validate thesignature.  KeyInfomay contain keys, names, certificates and other public key managementinformation, such as in-band key distribution or key agreement data. Thisspecification defines a few simple types but applications may extend thosetypes or all together replace them with their own key identification andexchange semantics using the XML namespace facility [XML-NAMES].However, questions of trust of such key information (e.g., itsauthenticity or strength) are out of scope of this specification and left to theapplication.Details of the structure and usage of element childrenof KeyInfo other thansimple types described in this specification are out of scope. Forexample, the definition of PKI certificate contents, certificate ordering,certificate revocation and CRL management are out of scope.If KeyInfo is omitted, the recipient is expected to be able toidentify the key based on application context. Multiple declarations withinKeyInfo refer to the same key. While applications may define and useany mechanism they choose through inclusion of elements from a differentnamespace, compliant versions MUSTimplement KeyValue (section 4.5.2 The KeyValue Element) andSHOULD implement KeyInfoReference(section 4.5.10 The KeyInfoReference Element).KeyInfoReference is preferred over use ofRetrievalMethod as it avoids use ofTransform child elements thatintroduce security risk and implementation challenges. Support forother children of KeyInfo is OPTIONAL.The schema specification of many ofKeyInfo's children (e.g., PGPData,SPKIData, X509Data) permit their content to beextended/complemented with elements from another namespace. This may be doneonly if it is safe to ignore these extension elements while claiming supportfor the types defined in this specification. Otherwise, external elements,includingalternative structures to those defined by this specification, MUSTbe a child of KeyInfo. For example, should a complete XML-PGPstandard be defined, its root element MUST be a child of KeyInfo.(Of course, new structures from external namespaces can incorporate elementsfrom the dsig: namespace via features of the type definitionlanguage. For instance, they can create a schema that permits, includes,imports, or derives new types based on dsig: elements.)The following list summarizes the KeyInfo types that areallocated an identifier in the dsig:namespace; these can be used within theRetrievalMethod Type attribute to describe a remoteKeyInfo structure.http://www.w3.org/2000/09/xmldsig#DSAKeyValuehttp://www.w3.org/2000/09/xmldsig#RSAKeyValuehttp://www.w3.org/2000/09/xmldsig#X509Datahttp://www.w3.org/2000/09/xmldsig#PGPDatahttp://www.w3.org/2000/09/xmldsig#SPKIDatahttp://www.w3.org/2000/09/xmldsig#MgmtDataThe following list summarizes the additional KeyInfotypes that are allocated an identifier in the dsig11:namespace.http://www.w3.org/2009/xmldsig11#ECKeyValuehttp://www.w3.org/2009/xmldsig11#DEREncodedKeyValueIn addition to the types above for which we define an XML structure, wespecify one additional type to indicate a binary (ASN.1 DER)X.509 Certificate.http://www.w3.org/2000/09/xmldsig#rawX509CertificateSchema Definition: <element name="KeyInfo" type="ds:KeyInfoType"/><complexType name="KeyInfoType" mixed="true"><choice maxOccurs="unbounded"><element ref="ds:KeyName"/><element ref="ds:KeyValue"/><element ref="ds:RetrievalMethod"/><element ref="ds:X509Data"/><element ref="ds:PGPData"/><element ref="ds:SPKIData"/><element ref="ds:MgmtData"/><!-- <element ref="dsig11:DEREncodedKeyValue"/> --><!-- DEREncodedKeyValue (XMLDsig 1.1) will use the any element --><!-- <element ref="dsig11:KeyInfoReference"/> --><!-- KeyInfoReference (XMLDsig 1.1) will use the any element --><!-- <element ref="xenc:EncryptedKey"/> --><!-- EncryptedKey (XMLEnc) will use the any element --><!-- <element ref="xenc:Agreement"/> --><!-- Agreement (XMLEnc) will use the any element --><any processContents="lax" namespace="##other"/><!-- (1,1) elements from (0,unbounded) namespaces --></choice><attribute name="Id" type="ID" use="optional"/></complexType>4.5.1 The KeyName ElementThe KeyName element contains a string value (in which whitespace is significant) which may be used by the signer to communicate a keyidentifier to the recipient. Typically,KeyName contains an identifier related to the key pair used tosign the message, but it may contain other protocol-related information thatindirectly identifies a key pair. (Common uses of KeyName includesimple string names for keys, a key index, a distinguished name (DN), an emailaddress, etc.)Schema Definition: <element name="KeyName" type="string" />4.5.2 The KeyValue ElementThe KeyValue element contains a single public key that may beuseful in validating the signature. Structured formats for defining DSA(REQUIRED), RSA (REQUIRED) and ECDSA (REQUIRED) public keys aredefined insection 6.4 Signature Algorithms.TheKeyValue element may include externally defined public keysvalues represented as PCDATA or element types from an external namespace.Schema Definition: <element name="KeyValue" type="ds:KeyValueType" /><complexType name="KeyValueType" mixed="true"><choice><element ref="ds:DSAKeyValue"/><element ref="ds:RSAKeyValue"/><!-- <element ref="dsig11:ECKeyValue"/> --><!-- ECC keys (XMLDsig 1.1) will use the any element --><any namespace="##other" processContents="lax"/></choice></complexType>4.5.2.1 The DSAKeyValue ElementIdentifierType="http://www.w3.org/2000/09/xmldsig#DSAKeyValue"(this can be used within a RetrievalMethodor Reference element to identify the referent's type)DSA keys and the DSA signature algorithm are specified in[FIPS-186-3]. DSA publickey values can have the following fields:Pa prime modulus meeting the [FIPS-186-3] requirementsQan integer in the range 2**159 < Q < 2**160 which is a prime divisor ofP-1Gan integer with certain properties with respect to P and QYG**X mod P (where X is part of the private key and not made public)J(P - 1) / Qseeda DSA prime generation seedpgenCountera DSA prime generation counterParameter J is available for inclusion solely forefficiency as it iscalculatable from Pand Q. Parameters seedand pgenCounter are used in the DSAprime number generation algorithm specified in [FIPS-186-3]. Assuch, they areoptional but must either both be present or both be absent. This primegeneration algorithm is designed to provide assurance that a weakprime is notbeing used and it yields a P and Qvalue. Parameters P, Q, and G canbe publicand common to a group of users. They might be known from application context.As such, they are optional but P and Qmust either both appear or both beabsent. If all ofP, Q, seed, andpgenCounter are present, implementations are not required tocheck if they are consistent and are free to use either P andQ or seed andpgenCounter. All parameters are encoded as base64[RFC2045]values.Arbitrary-length integers (e.g. "bignums" such as RSA moduli) arerepresented in XML as octet strings as defined by theds:CryptoBinary type.Schema Definition: <element name="DSAKeyValue" type="ds:DSAKeyValueType" /><complexType name="DSAKeyValueType"><sequence><sequence minOccurs="0"><element name="P" type="ds:CryptoBinary"/><element name="Q" type="ds:CryptoBinary"/></sequence><element name="G" type="ds:CryptoBinary" minOccurs="0"/><element name="Y" type="ds:CryptoBinary"/><element name="J" type="ds:CryptoBinary" minOccurs="0"/><sequence minOccurs="0"><element name="Seed" type="ds:CryptoBinary"/><element name="PgenCounter" type="ds:CryptoBinary"/></sequence></sequence></complexType>4.5.2.2 The RSAKeyValue ElementIdentifierType="http://www.w3.org/2000/09/xmldsig#RSAKeyValue"(this can be used within a RetrievalMethodor Reference element to identify the referent's type)RSA key values have two fields: Modulusand Exponent.Example 6 <RSAKeyValue><Modulus>xA7SEU+e0yQH5rm9kbCDN9o3aPIo7HbP7tX6WOocLZAtNfyxSZDU16ksL6WjubafOqNEpcwR3RdFsT7bCqnXPBe5ELh5u4VEy19MzxkXRgrMvavzyBpVRgBUwUlV5foK5hhmbktQhyNdy/6LpQRhDUDsTvK+g9Ucj47es9AQJ3U=</Modulus><Exponent>AQAB</Exponent></RSAKeyValue>Arbitrary-length integers (e.g. "bignums" such as RSA moduli) arerepresented in XML as octet strings as defined by theds:CryptoBinary type.Schema Definition: <element name="RSAKeyValue" type="ds:RSAKeyValueType" /><complexType name="RSAKeyValueType"><sequence><element name="Modulus" type="ds:CryptoBinary" /><element name="Exponent" type="ds:CryptoBinary" /></sequence></complexType>4.5.2.3 The ECKeyValue ElementIdentifierType="http://www.w3.org/2009/xmldsig11#ECKeyValue"(this can be used within a RetrievalMethodor Reference element to identify the referent's type)The ECKeyValue element is defined in thehttp://www.w3.org/2009/xmldsig11# namespace.EC public key values consists of two sub components: Domain parameters andPublicKey.Example 7 <ECKeyValue xmlns="http://www.w3.org/2009/xmldsig11#"><NamedCurve URI="urn:oid:1.2.840.10045.3.1.7" /><PublicKey>vWccUP6Jp3pcaMCGIcAh3YOev4gaa2ukOANC7UfgCf8KDO7AtTOsGJK7/TA8IC3vZoCy9I5oPjRhyTBulBnj7Y</PublicKey></ECKeyValue>Note - A line break has been added to the PublicKeycontent to preserve printed page width.Domain parameters can be encoded explicitly usingthe dsig11:ECParameters elementor by reference using the dsig11:NamedCurve element. A namedcurve is specifiedthrough the URI attribute. For named curves that areidentified byOIDs, such as those defined in [RFC3279] and [RFC4055],the OID SHOULD be encodedaccording to [URN-OID]. Conformantapplications MUST support the dsig11:NamedCurve element andthe 256-bit prime fieldcurve as identified by the OID 1.2.840.10045.3.1.7.The PublicKey element contains a Base64 encoding ofa binary representationof the x and y coordinates of the point. Its value is computed asfollows:Convert the elliptic curve point (x,y) to an octet stringby first converting the field elements x and y to octet strings asspecified in Section 6.2 of [ECC-ALGS] (note),and then prepend theconcatenated result of the conversion with 0x04. Support forElliptic-Curve-Point-to-Octet-String conversion without pointcompression is REQUIRED.Base64 encode the octet string resulting from theconversion in Step 1.Schema Definition: <!-- targetNamespace="http://www.w3.org/2009/xmldsig11#" --><element name="ECKeyValue" type="dsig11:ECKeyValueType" /><complexType name="ECKeyValueType"><sequence><choice><element name="ECParameters" type="dsig11:ECParametersType" /><element name="NamedCurve" type="dsig11:NamedCurveType" /></choice><element name="PublicKey" type="dsig11:ECPointType" /></sequence><attribute name="Id" type="ID" use="optional" /></complexType><complexType name="NamedCurveType"><attribute name="URI" type="anyURI" use="required" /></complexType><simpleType name="ECPointType"><restriction base="ds:CryptoBinary" /></simpleType>4.5.2.3.1 Explicit Curve ParametersThe ECParameters element consists of the followingsubelements. Note thesedefinitions are based on the those described in [RFC3279].The FieldID element identifies the finite fieldover which the ellipticcurve is defined. Additional details on the structures fordefining primeand characteristic two fields is provided below.The dsig11:Curve element specifies the coefficients aand b of the ellipticcurve E. Each coefficient is first converted from a fieldelement to anoctet string as specified in section 6.2 of [ECC-ALGS], thenthe resultant octet string is encoded inbase64.The Base element specifies the base point P onthe elliptic curve. Thebase point is represented as a value of type ECPointType.The Order element specifies the order n of the base point and is encodedas a positiveInteger.The Cofactor element is an optional element thatspecifies the integer h= #E(Fq)/n. The cofactor is not required to support ECDSA, except inparameter validation. The cofactor MAY be included to support parametervalidation for ECDSA keys. Parameter validation is not required by thisspecification. The cofactor is required in ECDH public key parameters.The dsig11:ValidationData element is an optionalelement thatspecifies the hash algorithm used to generate the elliptic curve Eand the base point G verifiably at random. It also specifies theseed that was used to generate the curve and the base point.Schema Definition: <!-- targetNamespace="http://www.w3.org/2009/xmldsig11#" --><complexType name="ECParametersType"><sequence><element name="FieldID" type="dsig11:FieldIDType" /><element name="Curve" type="dsig11:CurveType" /><element name="Base" type="dsig11:ECPointType" /><element name="Order" type="ds:CryptoBinary" /><element name="CoFactor" type="integer" minOccurs="0" /><element name="ValidationData"type="dsig11:ECValidationDataType" minOccurs="0" /></sequence></complexType><complexType name="FieldIDType"><choice><element ref="dsig11:Prime" /><element ref="dsig11:TnB" /><element ref="dsig11:PnB" /><element ref="dsig11:GnB" /><any namespace="##other" processContents="lax" /></choice></complexType><complexType name="CurveType"><sequence><element name="A" type="ds:CryptoBinary" /><element name="B" type="ds:CryptoBinary" /></sequence></complexType><complexType name="ECValidationDataType"><sequence><element name="seed" type="ds:CryptoBinary" /></sequence><attribute name="hashAlgorithm" type="anyURI" use="required" /></complexType>Prime fields are described by a single subelement P,which represents thefield size in bits. It is encoded as a positiveInteger.Schema Definition: <!-- targetNamespace="http://www.w3.org/2009/xmldsig11#" --><element name="Prime" type="dsig11:PrimeFieldParamsType" /><complexType name="PrimeFieldParamsType"><sequence><element name="P" type="ds:CryptoBinary" /></sequence></complexType>Structures are defined for three types of characteristic two fields:gaussian normal basis, pentanomial basis and trinomial basis.Schema Definition: <!-- targetNamespace="http://www.w3.org/2009/xmldsig11#" --><element name="GnB" type="dsig11:CharTwoFieldParamsType" /><complexType name="CharTwoFieldParamsType"><sequence><element name="M" type="positiveInteger" /></sequence></complexType><element name="TnB" type="dsig11:TnBFieldParamsType" /><complexType name="TnBFieldParamsType"><complexContent><extension base="dsig11:CharTwoFieldParamsType"><sequence><element name="K" type="positiveInteger" /></sequence></extension></complexContent></complexType><element name="PnB" type="dsig11:PnBFieldParamsType" /><complexType name="PnBFieldParamsType"><complexContent><extension base="dsig11:CharTwoFieldParamsType"><sequence><element name="K1" type="positiveInteger" /><element name="K2" type="positiveInteger" /><element name="K3" type="positiveInteger" /></sequence></extension></complexContent></complexType>4.5.2.3.2 Compatibility with RFC 4050Implementations that need to support the [RFC4050]format for ECDSA keys can avoid known interoperability problems with thatspecification by adhering to the following profile:Avoid validating the ECDSAKeyValue element against the [RFC4050]schema. XML schema validators may not support integer types with decimal dataexceeding 18 decimal digits.[XMLSCHEMA-1][XMLSCHEMA-2].Support only the NamedCurve element.Support the 256-bit prime field curve, as identified by the URNurn:oid:1.2.840.10045.3.1.7.The following is an example of a ECDSAKeyValue element that meets theprofile described in this section.Example 8 <ECDSAKeyValue xmlns="http://www.w3.org/2001/04/xmldsig-more#"><DomainParameters><NamedCurve URN="urn:oid:1.2.840.10045.3.1.7" /></DomainParameters><PublicKey><X Value="58511060653801744393249179046482833320204931884267326155134056258624064349885" /><Y Value="102403352136827775240910267217779508359028642524881540878079119895764161434936" /></PublicKey></ECDSAKeyValue>Note - A line break has been added to the Xand Y Value attribute values to preserveprinted page width.4.5.3 The RetrievalMethod ElementA RetrievalMethod element withinKeyInfo is used to convey a reference toKeyInfo information that is stored at another location. Forexample, several signatures in a document might use a key verified by anX.509v3 certificate chain appearing once in the document or remotely outsidethe document; each signature'sKeyInfo can reference this chain using a singleRetrievalMethod element instead of including the entire chainwith a sequence of X509Certificateelements.RetrievalMethod uses the same syntax and dereferencingbehavior as the Reference URI attribute (section 4.4.3.1 The URI Attribute) andthe Reference Processing Modelexcept that there areno DigestMethodor DigestValuechild elements and presence of the URI attribute ismandatory.Type is an optional identifier for the type of data retrievedafter all transforms have been applied. The result of dereferencing aRetrievalMethod Reference for all KeyInfo types defined by thisspecification( section 4.5 The KeyInfo Element)with a corresponding XML structure is an XMLelement or document with that element as the root. TherawX509Certificate KeyInfo(for which there is no XML structure) returns a binary X509certificate.Note that when referencing one of thedefined KeyInfo types within the same document, or some remote documents, atleast one Transform is required to turn an ID-basedreference to a KeyInfoelement into a child element located inside it. This is due to the lack ofan XML ID attribute on the defined KeyInfo types.In such cases, use of KeyInfoReference isencouraged instead, seesection 4.5.10 The KeyInfoReference Element.Note:The KeyInfoReference element is preferred over use ofRetrievalMethod as it avoids useof Transform child elements thatintroduce security risk and implementation challenges.Schema Definition: <element name="RetrievalMethod" type="ds:RetrievalMethodType" /><complexType name="RetrievalMethodType"><sequence><element ref="ds:Transforms" minOccurs="0" /></sequence><attribute name="URI" type="anyURI" /><attribute name="Type" type="anyURI" use="optional" /></complexType>Note: The schema for the URIattribute of RetrievalMethod erroneously omitted the attribute:use="required". However, this error only results in amore lax schemawhich permits all valid RetrievalMethodelements. Because the existing schemais embedded in many applications, which may include the schema in theirsignatures, the schema has not been corrected to be morerestrictive.4.5.4 The X509Data ElementIdentifierType="http://www.w3.org/2000/09/xmldsig#X509Data"(this can be used within a RetrievalMethod orReference element to identify the referent's type)An X509Data element within KeyInfocontains one or more identifiers of keys or X509 certificates (orcertificates' identifiers or a revocation list). The content ofX509Data is at least one element, from the followingset of element types; any of these may appear together or more thanonce iff (if and only if) each instance describes or is related tothe same certificate:The deprecated X509IssuerSerial element, which contains an X.509issuer distinguished name/serial number pair. The distinguished nameSHOULD be represented as a string that complies with section 3 ofRFC4514 [LDAP-DN], to be generated according to theDistinguished Name Encoding Rulessection below,The X509SubjectName element, which contains an X.509subject distinguished name that SHOULD be represented as a string thatcomplies with section 3 of RFC4514 [LDAP-DN], to be generated according to theDistinguished Name Encoding Rulessection below,The X509SKI element, which contains the base64 encodedplain (i.e. non-DER-encoded) value of a X509 V.3 SubjectKeyIdentifierextension,The X509Certificate element, which contains abase64-encoded [X509V3] certificate, andThe X509CRL element, which contains a base64-encodedcertificate revocation list (CRL) [X509V3].The dsig11:X509Digest element contains a base64-encodeddigest of a certificate. The digest algorithm URI is identified with arequired Algorithm attribute. The input to the digest MUSTbe the raw octets that would be base64-encoded were the same certificateto appear in the X509Certificate element.Elements from an external namespace which accompanies/complementsany of the elements above.Any X509IssuerSerial, X509SKI, X509SubjectName,and dsig11:X509Digest elements that appear MUST refer to thecertificate or certificates containing the validation key. All such elementsthat refer to a particular individual certificate MUST be grouped inside asingle X509Data element and if the certificate to which they referappears, it MUST also be in that X509Data element.Any X509IssuerSerial, X509SKI, X509SubjectName,and dsig11:X509Digest elements that relate to the same key butdifferent certificates MUST be grouped within a single KeyInfobut MAY occur in multiple X509Data elements.Note that if X509Data child elements are used to identify atrusted certificate (rather than solely as an untrusted hint supplemented byvalidation by policy), the complete set of such elements that are intended toidentify a certificate SHOULD be integrity protected, typically by signing anentire X509Data or KeyInfo element.All certificates appearing in an X509Data element MUST relateto the validation key by either containing it or being part of a certificationchain that terminates in a certificate containing the validation key.No ordering is implied by the above constraints. The comments in thefollowing instance demonstrate these constraints:Example 9 <KeyInfo><X509Data> <!-- two pointers to certificate-A --><X509IssuerSerial><X509IssuerName>CN=TAMURA Kent, OU=TRL, O=IBM, L=Yamato-shi, ST=Kanagawa, C=JP</X509IssuerName><X509SerialNumber>12345678</X509SerialNumber></X509IssuerSerial><X509SKI>31d97bd7</X509SKI></X509Data><X509Data><!-- single pointer to certificate-B --><X509SubjectName>Subject of Certificate B</X509SubjectName></X509Data><X509Data> <!-- certificate chain --><!--Signer cert, issuer CN=arbolCA,OU=FVT,O=IBM,C=US, serial 4--><X509Certificate>MIICXTCCA..</X509Certificate><!-- Intermediate cert subject CN=arbolCA,OU=FVT,O=IBM,C=USissuer CN=tootiseCA,OU=FVT,O=Bridgepoint,C=US --><X509Certificate>MIICPzCCA...</X509Certificate><!-- Root cert subject CN=tootiseCA,OU=FVT,O=Bridgepoint,C=US --><X509Certificate>MIICSTCCA...</X509Certificate></X509Data></KeyInfo>Note, there is no direct provision for a PKCS#7 encoded "bag" ofcertificates or CRLs. However, a set of certificates and CRLs can occur withinan X509Data element and multipleX509Data elements can occur in aKeyInfo. Whenever multiple certificates occur in anX509Data element, at least one such certificate must contain thepublic key which verifies the signature.While in principle many certificate encodings are possible, it is RECOMMENDEDthat certificates appearing in anX509Certificate element be limited to an encoding of BER or its DERsubset, allowing that within the certificate other content may be present. Theuse of other encodings may lead to interoperability issues. In any case, XMLSignature implementations SHOULD NOT alter or re-encode certificates, as doingso could invalidate their signatures.The X509IssuerSerial element has been deprecated in favor of thenewly-introduced dsig11:X509Digest element. The XML Schema type ofthe serial number was defined to be an integer, and XML Schema validators may notsupport integer types with decimal data exceeding 18 decimal digits [XMLSCHEMA-2].This has proven insufficient, because many Certificate Authorities issuecertificates with large, random serial numbers that exceed this limit.As a result, deployments that do make use of this element should take careif schema validation is involved. New deployments SHOULD avoid use of the element.4.5.4.1 Distinguished Name Encoding RulesTo encode a distinguished name (X509IssuerSerial,X509SubjectName,andKeyName if appropriate), the encoding rules in section 2 of RFC4514 [LDAP-DN] SHOULD be applied, except that the character escapingrules in section 2.4 of RFC 4514 [LDAP-DN] MAY be augmented as follows:Escape all occurrences of ASCII control characters (Unicode range \x00 -\x1f) by replacing them with "\" followed by a two digit hex number showingits Unicode number.Escape any trailing space characters (Unicode \x20) by replacing themwith "\20", instead of using the escape sequence "\ ".Since an XML document logically consists of characters, not octets, theresulting Unicode string is finally encoded according to the characterencoding used for producing the physical representation of the XML document.Schema Definition: <element name="X509Data" type="ds:X509DataType"/><complexType name="X509DataType"><sequence maxOccurs="unbounded"><choice><element name="X509IssuerSerial" type="ds:X509IssuerSerialType"/><element name="X509SKI" type="base64Binary"/><element name="X509SubjectName" type="string"/><element name="X509Certificate" type="base64Binary"/><element name="X509CRL" type="base64Binary"/><!-- <element ref="dsig11:X509Digest"/> --><!-- The X509Digest element (XMLDSig 1.1) will use the any element --><any namespace="##other" processContents="lax"/></choice></sequence></complexType><complexType name="X509IssuerSerialType"><sequence><element name="X509IssuerName" type="string"/><element name="X509SerialNumber" type="integer"/></sequence></complexType><!-- Note, this schema permits X509Data to be empty; this isprecluded by the text in<a href="#sec-KeyInfo" class="sectionRef"></a> which statesthat at least one element from the dsig namespace should be presentin the PGP, SPKI, and X509 structures. This is easily expressed forthe other key types, but not for X509Data because of its richstructure. --><!-- targetNameSpace="http://www.w3.org/2009/xmldsig11#" --><element name="X509Digest" type="dsig11:X509DigestType"/><complexType name="X509DigestType"><simpleContent><extension base="base64Binary"><attribute name="Algorithm" type="anyURI" use="required"/></extension></simpleContent></complexType>4.5.5 The PGPData ElementIdentifierType="http://www.w3.org/2000/09/xmldsig#PGPData"(this can be used within a RetrievalMethod orReference element to identify the referent's type)The PGPData element within KeyInfois used to convey information related to PGP public key pairs and signatureson such keys. The PGPKeyID's value is a base64Binary sequencecontaining a standard PGP public key identifier as defined in [PGP] section 11.2]. The PGPKeyPacketcontains a base64-encoded Key Material Packet as defined in [PGP]section 5.5]. These children element types can be complemented/extended bysiblings from an external namespace within PGPData, orPGPData can be replaced all together with an alternative PGP XMLstructure as a child of KeyInfo.PGPData must contain one PGPKeyIDand/or one PGPKeyPacket and 0 or more elements from an externalnamespace.Schema Definition: <element name="PGPData" type="ds:PGPDataType"/><complexType name="PGPDataType"><choice><sequence><element name="PGPKeyID" type="base64Binary"/><element name="PGPKeyPacket" type="base64Binary" minOccurs="0"/><any namespace="##other" processContents="lax" minOccurs="0"maxOccurs="unbounded"/></sequence><sequence><element name="PGPKeyPacket" type="base64Binary"/><any namespace="##other" processContents="lax" minOccurs="0"maxOccurs="unbounded"/></sequence></choice></complexType>4.5.6 The SPKIData ElementIdentifierType="http://www.w3.org/2000/09/xmldsig#SPKIData"(this can be used within a RetrievalMethod orReference element to identify the referent's type)The SPKIData element within KeyInfois used to convey information related to SPKI public key pairs, certificatesand other SPKI data. SPKISexp is the base64 encoding of a SPKIcanonical S-expression.SPKIData must have at least oneSPKISexp; SPKISexp can be complemented/extended bysiblings from an external namespace within SPKIData, orSPKIData can be entirely replaced with an alternative SPKI XMLstructure as a child of KeyInfo.Schema Definition: <element name="SPKIData" type="ds:SPKIDataType"/><complexType name="SPKIDataType"><sequence maxOccurs="unbounded"><element name="SPKISexp" type="base64Binary"/><any namespace="##other" processContents="lax" minOccurs="0"/></sequence></complexType>4.5.7 The MgmtData ElementIdentifierType="http://www.w3.org/2000/09/xmldsig#MgmtData"(this can be used within a RetrievalMethod orReference element to identify the referent's type)The MgmtData element within KeyInfo is astring value used to conveyin-band key distribution or agreement data. However, use of thiselement is NOT RECOMMENDED and SHOULD NOT be used.Thesection 4.5.8 XML Encryption EncryptedKeyand DerivedKey Elements describesnew KeyInfo types for conveying key information.Schema Definition: <element name="MgmtData" type="string" />4.5.8 XML Encryption EncryptedKeyand DerivedKey ElementsThe <xenc:EncryptedKey>and <xenc:DerivedKey> elements defined in[XMLENC-CORE1] as children of ds:KeyInfo can be usedto convey in-bandencrypted or derived key material. In particular, thexenc:DerivedKey> element may be present when the key used incalculating a Message Authentication Code is derived from a sharedsecret.4.5.9 The DEREncodedKeyValue ElementIdentifierType="http://www.w3.org/2009/xmldsig11#DEREncodedKeyValue"(this can be used within a RetrievalMethodor Reference element to identify the referent's type)The public key algorithm and value are DER-encoded in accordance with thevalue that would be used in the Subject Public Key Info field of an X.509certificate, per section 4.1.2.7 of [RFC5280].The DER-encoded value is then base64-encoded.For the key value types supported in this specification, refer to thefollowing for normative references on the format of Subject Public Key Infoand the relevant OID values that identify the key/algorithm type:RSASee section 2.3.1 of [RFC3279]DSASee section 2.3.2 of [RFC3279]ECSee section 2 of [RFC5480]Specifications that define additional key types should provide sucha normative reference for their own key types where possible.Schema Definition: <!-- targetNamespace="http://www.w3.org/2009/xmldsig11#" --><element name="DEREncodedKeyValue" type="dsig11:DEREncodedKeyValueType" /><complexType name="DEREncodedKeyValueType"><simpleContent><extension base="base64Binary"><attribute name="Id" type="ID" use="optional"/></extension></simpleContent></complexType>Historical note: The DEREncodedKeyValue element was addedto XML Signature 1.1 in order to support certain interoperabilityscenarios where at least one of signer and/or verifier are not able toserialize keys in the XML formats described insection 4.5.2 The KeyValue Elementabove. The KeyValue element is to be used for"bare" XML keyrepresentations (not XML wrappings around other binary encodings likeASN.1 DER); for this reason the DEREncodedKeyValueelement is not achild of KeyValue.The DEREncodedKeyValue element is also not a child of theX509Data element, as the keys representedby DEREncodedKeyValue maynot have X.509 certificates associated with them (a requirement forX509Data).4.5.10 The KeyInfoReference ElementA KeyInfoReference element within KeyInfo isused toconvey a reference to aKeyInfo element at another location in the same ordifferent document. Forexample, several signatures in a document might use a key verified by anX.509v3 certificate chain appearing once in the document or remotely outsidethe document; each signature's KeyInfo can reference thischain using asingle KeyInfoReference element instead of including theentire chain with asequence of X509Certificate elements repeated in multipleplaces.KeyInfoReference uses the same syntax and dereferencingbehavior asReference's URI (section 4.4.3.1 The URI Attribute) and the ReferenceProcessing Model(section 4.4.3.2 The Reference Processing Model)except that there are no child elements and thepresenceof the URI attribute is mandatory.The result of dereferencing a KeyInfoReference MUST bea KeyInfo element, oran XML document with a KeyInfo element as the root.Note: The KeyInfoReference element is a desirablealternative to the use ofRetrievalMethod when the data being referred to isa KeyInfo element and theuse of RetrievalMethod would require one ormore Transform child elements,which introduce security risk and implementation challenges.Schema Definition: <!-- targetNamespace="http://www.w3.org/2009/xmldsig11#" --><element name="KeyInfoReference" type="dsig11:KeyInfoReferenceType"/><complexType name="KeyInfoReferenceType"><attribute name="URI" type="anyURI" use="required"/><attribute name="Id" type="ID" use="optional"/></complexType>4.6 The Object ElementIdentifierType="http://www.w3.org/2000/09/xmldsig#Object"(this can be used within aReference element to identify the referent's type)Object is an optional element that may occur one or moretimes. When present, this element may contain any data. The Objectelement may include optional MIME type, ID, and encoding attributes.The Object's Encoding attributed may be used toprovide a URI that identifies the method by which the object is encoded (e.g.,a binary file).The MimeType attribute is an optional attribute whichdescribes the data within the Object(independent of its encoding). This is a string with values definedby [RFC2045].For example, if the Object contains base64 encodedPNG, theEncoding may be specified as 'http://www.w3.org/2000/09/xmldsig#base64'and theMimeType as 'image/png'. This attribute is purely advisory; novalidation of the MimeType information is required by thisspecification. Applications which require normative type and encodinginformation for signature validation should specify Transforms with well defined resulting types and/orencodings.The Object's Id is commonly referenced from aReference inSignedInfo, or Manifest. This element is typicallyused for enveloping signatures where the object beingsigned is to be included in the signature element. The digest is calculatedover the entire Objectelement including start and end tags.Note, if the application wishes to exclude the<Object> tags from the digest calculation theReference must identify the actual data object (easy for XMLdocuments) or a transform must be used to remove theObject tags (likely where the data object is non-XML). Exclusionof the object tags may be desired for cases where one wants the signature toremain valid if the data object is moved from inside a signature to outsidethe signature (or vice versa), or where the content of the Objectis an encoding of an original binary document and it is desired to extract anddecode so as to sign the original bitwise representation.Schema Definition: <element name="Object" type="ds:ObjectType" /><complexType name="ObjectType" mixed="true"><sequence minOccurs="0" maxOccurs="unbounded"><any namespace="##any" processContents="lax" /></sequence><attribute name="Id" type="ID" use="optional" /><attribute name="MimeType" type="string" use="optional" /><attribute name="Encoding" type="anyURI" use="optional" /></complexType>5. Additional Signature SyntaxThis section describes the optional to implementManifest and SignaturePropertieselements and describes the handling of XML processing instructions andcomments. With respect to the elementsManifest and SignatureProperties this sectionspecifies syntax and little behavior -- it is left to the application. Theseelements can appear anywhere the parent's content model permits; theSignature content model only permits them within Object.5.1 The Manifest ElementIdentifierType="http://www.w3.org/2000/09/xmldsig#Manifest"(this can be used within a Referenceelement to identify the referent's type)The Manifest element provides a list ofReferences. The difference from the list inSignedInfo is that it is application defined which, if any, ofthe digests are actually checked against the objects referenced and what to doif the object is inaccessible or the digest compare fails. If a Manifestis pointed to from SignedInfo, the digest over theManifest itself will be checked by the core signature validationbehavior. The digests within such aManifest are checked at the application's discretion. If aManifest is referenced from anotherManifest, even the overall digest of this two level deepManifest might not be checked.Schema Definition: <element name="Manifest" type="ds:ManifestType" /><complexType name="ManifestType"><sequence><element ref="ds:Reference" maxOccurs="unbounded" /></sequence><attribute name="Id" type="ID" use="optional" /></complexType>5.2 The SignatureProperties Element IdentifierType="http://www.w3.org/2000/09/xmldsig#SignatureProperties"(this can be used within a Referenceelement to identify the referent's type)Additional information items concerning the generation of the signature(s)can be placed in a SignaturePropertyelement (i.e., date/time stamp or the serial number of cryptographic hardwareused in signature generation).Schema Definition: <element name="SignatureProperties" type="ds:SignaturePropertiesType" /><complexType name="SignaturePropertiesType"><sequence><element ref="ds:SignatureProperty" maxOccurs="unbounded" /></sequence><attribute name="Id" type="ID" use="optional" /></complexType><element name="SignatureProperty" type="ds:SignaturePropertyType" /><complexType name="SignaturePropertyType" mixed="true"><choice maxOccurs="unbounded"><any namespace="##other" processContents="lax" /><!-- (1,1) elements from (1,unbounded) namespaces --></choice><attribute name="Target" type="anyURI" use="required" /><attribute name="Id" type="ID" use="optional" /></complexType>5.3 Processing Instructions in Signature ElementsNo XML processing instructions (PIs) are used by this specification.Note that PIs placed inside SignedInfo by an application willbe signed unless theCanonicalizationMethod algorithm discards them. (Thisis true forany signed XML content.) All of theCanonicalizationMethods identified within this specificationretain PIs. When a PI is part of content that is signed (e.g., withinSignedInfo or referenced XML documents) any change to the PI willobviously result in a signature failure.5.4 Comments in Signature ElementsXML comments are not used by this specification.Note that unless CanonicalizationMethod removes commentswithin SignedInfo or any other referenced XML (which [XML-C14N]does), they will be signed. Consequently, if they are retained, a change tothe comment will cause a signature failure. Similarly, the XML signature overany XML data will be sensitive to comment changes unless a comment-ignoringcanonicalization/transform method, such as the Canonical XML[XML-C14N], is specified.6. AlgorithmsThis section identifies algorithms used with the XML digital signaturespecification. Entries contain the identifier to be used in Signatureelements, a reference to the formal specification, and definitions, whereapplicable, for the representation of keys and the results of cryptographicoperations.6.1 Algorithm Identifiers and Implementation RequirementsAlgorithms are identified by URIs that appear as an attribute to theelement that identifies the algorithms' role (DigestMethod,Transform,SignatureMethod, orCanonicalizationMethod). All algorithms used herein takeparameters but in many cases the parameters are implicit. For example, aSignatureMethod is implicitly given two parameters: the keying info andthe output ofCanonicalizationMethod. Explicit additional parameters to analgorithm appear as content elements within the algorithm role element. Suchparameter elements have a descriptive element name, which is frequentlyalgorithm specific, and MUST be in the XML Signature namespace or an algorithmspecific namespace.This specification defines a set of algorithms, their URIs, andrequirements for implementation. Requirements are specified overimplementation, not over requirements for signature use. Furthermore, themechanism is extensible; alternative algorithms may be used by signatureapplications.DigestRequiredSHA1 (Use is DISCOURAGED; see SHA-1 Warning)http://www.w3.org/2000/09/xmldsig#sha1SHA256http://www.w3.org/2001/04/xmlenc#sha256OptionalSHA224http://www.w3.org/2001/04/xmldsig-more#sha224SHA384http://www.w3.org/2001/04/xmldsig-more#sha384SHA512http://www.w3.org/2001/04/xmlenc#sha512EncodingRequiredbase64 (*note)http://www.w3.org/2000/09/xmldsig#base64MACRequiredHMAC-SHA1 (Use isDISCOURAGED; see SHA-1 Warning)http://www.w3.org/2000/09/xmldsig#hmac-sha1HMAC-SHA256http://www.w3.org/2001/04/xmldsig-more#hmac-sha256RecommendedHMAC-SHA384http://www.w3.org/2001/04/xmldsig-more#hmac-sha384HMAC-SHA512http://www.w3.org/2001/04/xmldsig-more#hmac-sha512OptionalHMAC-SHA224http://www.w3.org/2001/04/xmldsig-more#hmac-sha224SignatureRequiredRSAwithSHA256http://www.w3.org/2001/04/xmldsig-more#rsa-sha256[section 6.4.2 RSA (PKCS#1 v1.5)]ECDSAwithSHA256http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha256[section 6.4.3 ECDSA]DSAwithSHA1(signature verification)http://www.w3.org/2000/09/xmldsig#dsa-sha1[section 6.4.1 DSA]RecommendedRSAwithSHA1(signature verification; use forsignature generation is DISCOURAGED;see SHA-1 Warning)http://www.w3.org/2000/09/xmldsig#rsa-sha1OptionalRSAwithSHA224http://www.w3.org/2001/04/xmldsig-more#rsa-sha224[section 6.4.2 RSA (PKCS#1 v1.5)]RSAwithSHA384http://www.w3.org/2001/04/xmldsig-more#rsa-sha384[section 6.4.2 RSA (PKCS#1 v1.5)]RSAwithSHA512http://www.w3.org/2001/04/xmldsig-more#rsa-sha512ECDSAwithSHA1 (Use is DISCOURAGED; see SHA-1 Warning)http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha1[section 6.4.3 ECDSA]ECDSAwithSHA224http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha224[section 6.4.3 ECDSA]ECDSAwithSHA384http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha384[section 6.4.3 ECDSA]ECDSAwithSHA512http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha512[section 6.4.3 ECDSA]DSAwithSHA1(signature generation)normal">http://www.w3.org/2000/09/xmldsig#dsa-sha1[section 6.4.1 DSA]DSAwithSHA256http://www.w3.org/2009/xmldsig11#dsa-sha256[section 6.4.1 DSA]CanonicalizationRequiredCanonical XML 1.0 (omit comments)http://www.w3.org/TR/2001/REC-xml-c14n-20010315Canonical XML 1.1 (omit comments)http://www.w3.org/2006/12/xml-c14n11Exclusive XML Canonicalization 1.0 (omit comments)http://www.w3.org/2001/10/xml-exc-c14n#RecommendedCanonical XML 1.0 (with comments)http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithCommentsCanonical XML 1.1 (with comments)http://www.w3.org/2006/12/xml-c14n11#WithCommentsExclusive XML Canonicalization 1.0 (with comments)http://www.w3.org/2001/10/xml-exc-c14n#WithCommentsTransformRequiredbase64 (*note)http://www.w3.org/2000/09/xmldsig#base64Enveloped Signature (**note)http://www.w3.org/2000/09/xmldsig#enveloped-signatureRecommendedXPathhttp://www.w3.org/TR/1999/REC-xpath-19991116XPath Filter 2.0http://www.w3.org/2002/06/xmldsig-filter2OptionalXSLThttp://www.w3.org/TR/1999/REC-xslt-19991116*note: Note thatthe same URI is used to identify base64 both in "encoding"context (e.g. within the Object element) as well as in"transform" context (when identifying a base64transform).**note: The Enveloped Signature transform removes theSignature element from the calculation of the signature when thesignature is within the content that it is being signed. This MAY beimplemented via the XPath specification specified in 6.6.4: Enveloped Signature Transform; itMUST have the same effect as that specified by theXPath Transform.When using transforms, we RECOMMEND selecting the least expressive choice that stillaccomplishes the needs of the use case at hand: Use of XPath filter 2.0 is recommended over use ofXPath filter. Use of XPath filter is recommended over use of XSLT.Note: Implementation requirements for the XPath transform may be downgraded toOPTIONAL in a future version of this specification.6.2 Message DigestsThis specification defines several possible digest algorithms forthe DigestMethod element, including REQUIRED algorithm SHA-256. Useof SHA-256 is strongly recommended over SHA-1 because recentadvances in cryptanalysis (see e.g. [SHA-1-Analysis]) have cast doubt on the long-termcollision resistance of SHA-1. Therefore, SHA-1 support is REQUIREDin this specification only for backwards-compatibility reasons.Digest algorithms that are known not to be collision resistant SHOULD NOT beused in DigestMethod elements. For example, the MD5 message digest algorithmSHOULD NOT be used as specific collisions have been demonstrated for thatalgorithm.6.2.1 SHA-1Identifier:http://www.w3.org/2000/09/xmldsig#sha1Note: Useof SHA-256 is strongly recommended over SHA-1 because recentadvances in cryptanalysis (see e.g. [SHA-1-Analysis],[SHA-1-Collisions] ) have cast doubt on the long-termcollision resistance of SHA-1.The SHA-1 algorithm [FIPS-186-3] takes no explicit parameters. An example of an SHA-1DigestAlg element is:Example 10 <DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#sha1"/>A SHA-1 digest is a 160-bit string. The content of the DigestValue elementshall be the base64 encoding of this bit string viewed as a 20-octet octetstream. For example, the DigestValue element for the message digest:Example 11 A9993E36 4706816A BA3E2571 7850C26C 9CD0D89Dfrom Appendix A of the SHA-1 standard would be:Example 12 <DigestValue>qZk+NkcGgWq6PiVxeFDCbJzQ2J0=</DigestValue>6.2.2 SHA-224Identifier:http://www.w3.org/2001/04/xmldsig-more#sha224TheSHA-224algorithm [FIPS-180-3] takes no explicitparameters. A SHA-224 digest is a224-bit string. The content of the DigestValue elementshall be the base64encoding of this bit string viewed as a 28-octet octet stream.6.2.3 SHA-256Identifier:http://www.w3.org/2001/04/xmlenc#sha256The SHA-256 algorithm [FIPS-180-3] takes no explicitparameters. A SHA-256 digest is a256-bit string. The content of the DigestValue element shall be the base64encoding of this bit string viewed as a 32-octet octet stream.6.2.4 SHA-384Identifier:http://www.w3.org/2001/04/xmldsig-more#sha384The SHA-384 algorithm [FIPS-180-3]takes no explicit parameters. A SHA-384 digest is a384-bit string. The content of the DigestValue element shall be the base64encoding of this bit string viewed as a 48-octet octet stream.6.2.5 SHA-512Identifier:http://www.w3.org/2001/04/xmlenc#sha512The SHA-512 algorithm [FIPS-180-3]takes no explicit parameters. A SHA-512 digest is a512-bit string. The content of the DigestValue element shall be the base64encoding of this bit string viewed as a 64-octet octet stream.6.3 Message AuthenticationCodesMAC algorithms take two implicit parameters, their keying materialdetermined from KeyInfo and the octet stream output byCanonicalizationMethod. MACs and signature algorithms aresyntacticallyidentical but a MAC implies a shared secret key.6.3.1 HMACIdentifier:http://www.w3.org/2000/09/xmldsig#hmac-sha1http://www.w3.org/2001/04/xmldsig-more#hmac-sha224http://www.w3.org/2001/04/xmldsig-more#hmac-sha256http://www.w3.org/2001/04/xmldsig-more#hmac-sha384http://www.w3.org/2001/04/xmldsig-more#hmac-sha512The HMACalgorithm (RFC2104 [HMAC]) takes the output(truncation) length in bits as aparameter;this specification REQUIRES that the truncation length be a multiple of 8(i.e. fall on a byte boundary) because Base64 encoding operates on full bytes. If the truncation parameter is not specified then all the bits of the hash are output.Any signature with a truncation length that is less than half the output length of the underlyinghash algorithm MUST be deemed invalid.An example of an HMAC SignatureMethodelement:Example 13 <SignatureMethod Algorithm="http://www.w3.org/2000/09/xmldsig#hmac-sha1"><HMACOutputLength>128</HMACOutputLength></SignatureMethod>The output of the HMAC algorithm is ultimately the output (possiblytruncated) of the chosen digest algorithm. This value shall be base64 encodedin the same straightforward fashion as the output of the digest algorithms.Example: the SignatureValue element for the HMAC-SHA1 digestExample 14 9294727A 3638BB1C 13F48EF8 158BFC9Dfrom the test vectors in [HMAC] would beExample 15 <SignatureValue>kpRyejY4uxwT9I74FYv8nQ==</SignatureValue>Schema Definition: <simpleType name="HMACOutputLengthType"><restriction base="integer" /></simpleType>6.4 Signature AlgorithmsSignature algorithms take two implicit parameters, their keying materialdetermined from KeyInfo and the octet stream output byCanonicalizationMethod. Signature and MAC algorithms are syntacticallyidentical but a signature implies public key cryptography.6.4.1 DSAIdentifier:http://www.w3.org/2000/09/xmldsig#dsa-sha1http://www.w3.org/2009/xmldsig11#dsa-sha256The DSA family of algorithms is defined in FIPS 186-3 [FIPS-186-3]. FIPS 186-3 defines DSA in terms of two security parameters L and N where L =|p|, N = |q|, p is the prime modulus, q is a prime divisor of (p-1). FIPS 186-3 defines four valid pairs of (L, N); they are: (1024, 160), (2048,224), (2048, 256) and (3072, 256).  The pair (1024, 160) corresponds tothe algorithm DSAwithSHA1, which is identified in this specification by theURIhttp://www.w3.org/2000/09/xmldsig#dsa-sha1.  The pairs (2048, 256)and (3072, 256) correspond to the algorithm DSAwithSHA256, which is identifiedin this specification by the URIhttp://www.w3.org/2009/xmldsig11#dsa-sha256.  This specification doesnot use the (2048, 224) instance of DSA (which corresponds to DSAwithSHA224). DSA takes no explicitparameters; an example of a DSASignatureMethod element is:Example 16 <SignatureMethod Algorithm="http://www.w3.org/2009/xmldsig11#dsa-sha256"/>The output of the DSA algorithm consists of a pair of integers usuallyreferred by the pair (r, s). The signature value consists of the base64encoding of the concatenation of two octet-streams that respectively resultfrom the octet-encoding of the values r and s in that order. Integer tooctet-stream conversion must be done according to the I2OSP operation definedin the RFC 3447[PKCS1] specification with a lparameter equal to 20. For example, the SignatureValueelement for a DSAsignature (r,s) with values specified in hexadecimal:Example 17 r = 8BAC1AB6 6410435C B7181F95 B16AB97C 92B341C0s = 41E2345F 1F56DF24 58F426D1 55B4BA2D B6DCD8C8from the example in Appendix 5 of the DSS standard would beExample 18 <SignatureValue>i6watmQQQ1y3GB+VsWq5fJKzQcBB4jRfH1bfJFj0JtFVtLotttzYyA==</SignatureValue>Security considerations regarding DSA key sizesPer FIPS 186-3 [FIPS-186-3], the DSA security parameter L isdefined to be 1024, 2048 or 3072 bits and the corresponding DSA qvalue is defined tobe 160, 224/256 and 256 bits respectively.NIST provides guidance on the use of keys of various strength forvarious time frames in special Publication SP 800-57Part 1 [SP800-57]. Implementersshould consult this publication for guidance onacceptable key lengths for applications, however2048-bit public keys are the minimum recommended keylength and 3072-bit keys are recommended for securinginformation beyond 2030. SP800-57 Part 1 states thatDSA 1024-bit key sizes should not be used except toverify and honor signatures created using olderlegacy systems.Since XML Signature 1.0 requires implementations to supportDSA-based digitalsignatures, this XML Signature 1.1 revision allowsverifiers to verify DSA signatures for DSA keys of 1024bits in order tovalidate existing signatures.XML Signature 1.1 implementations MAY but areREQUIRED">NOTREQUIRED to supportDSA-based signature generation. Given the short key sizeand SP800-57 guidelines, DSA with 1024-bit prime moduliSHOULD NOT be used to create signatures. DSA with1024-bit prime moduli MAY be used to verify olderlegacy signatures, with an understanding of theassociated risks. Important older signatures SHOULD bere-signed with stronger signatures.6.4.2 RSA (PKCS#1 v1.5)Identifier:http://www.w3.org/2000/09/xmldsig#rsa-sha1http://www.w3.org/2001/04/xmldsig-more#rsa-sha224http://www.w3.org/2001/04/xmldsig-more#rsa-sha256http://www.w3.org/2001/04/xmldsig-more#rsa-sha384http://www.w3.org/2001/04/xmldsig-more#rsa-sha512The expression "RSA algorithm" as used in this specification refers to theRSASSA-PKCS1-v1_5 algorithm described in RFC 3447[PKCS1]. The RSA algorithm takes noexplicit parameters. An example of an RSA SignatureMethod element is:Example 19 <SignatureMethod Algorithm="http://www.w3.org/2000/09/xmldsig#rsa-sha1"/>The SignatureValue content for an RSA signature is the base64[RFC2045] encoding of the octet stringcomputed as per RFC 3447[PKCS1], section 8.2.1: Signaturegeneration for the RSASSA-PKCS1-v1_5 signature scheme].Computation of the signature will require concatenation of the hash value and a constant stringdetermined by RFC 3447. Signature computation and verification does not require implementation of anASN.1 parser.As specified in theEMSA-PKCS1-V1_5-ENCODE function"http://www.ietf.org/rfc/rfc3447.txt" >RFC 3447[[!PKCS1]], section 9.2.1], the value inputto the signature function MUST contain a pre-pended algorithm objectidentifier for the hash function, but the availability of an ASN.1 parser andrecognition of OIDs is not required of a signature verifier. The PKCS#1 v1.5representation appears as:CRYPT (PAD (ASN.1 (OID, DIGEST (data))))Note that the padded ASN.1 will be of the following form:01 | FF* | 00 | prefix | hashwhere "|" is concatenation, "01", "FF", and "00" are fixed octets of thecorresponding hexadecimal value, "hash" is the SHA1 digest of the data, and"prefix" is the ASN.1 BER SHA1 algorithm designator prefix required in PKCS1[RFC 3447], that is,hex 30 21 30 09 06 05 2B 0E 03 02 1A 05 00 04 14This prefix is included to make it easier to use standard cryptographiclibraries. The FF octet MUST be repeated the maximum number of times such thatthe value of the quantity being CRYPTed is one octet shorter than the RSAmodulus. -->The resulting base64 [RFC2045]string is the value of the child text node of theSignatureValue element, e.g.Example 20 <SignatureValue>IWijxQjUrcXBYoCei4QxjWo9Kg8D3p9tlWoT4t0/gyTE96639In0FZFY2/rvP+/bMJ01EArmKZsR5VW3rwoPxw=</SignatureValue>Note - A line break has been added to preserveprinted page width.Security considerations regarding RSA key sizesNIST provides guidance on the use of keys of various strength forvarious time frames in special Publication SP 800-57 Part 1[SP800-57]. Implementersshould consult this publication for guidance onacceptable key lengths for applications, however2048-bit public keys are the minimum recommended keylength and 3072-bit keys are recommended for securinginformation beyond 2030.All conforming implementations of XML Signature 1.1 MUSTsupport RSAsignature generation and verification with public keysat least 2048 bits in length. RSA public keys of 1024bits or less SHOULD NOT be used to create newsignatures but MAY be used to verify signaturescreated by older legacy systems. XML Signature 1.1implementations MUST use at least 2048-bit keys forcreating signatures, and SHOULD use at least 3072-bitkeys for signatures that will be verified beyond2030.6.4.3 ECDSAIdentifiers:http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha1http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha224http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha256http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha384http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha512The ECDSA algorithm [FIPS-186-3] takes no explicit parameters. An example of a ECDSASignatureMethod element is:Example 21 <SignatureMethod Algorithm="http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha256" />The output of the ECDSA algorithm consists of a pair of integers usuallyreferred by the pair (r, s). The signature value consists of the base64encoding of the concatenation of two octet-streams that respectively resultfrom the octet-encoding of the values r and s in that order. Integer tooctet-stream conversion must be done according to the I2OSP operation definedin the RFC 3447 [PKCS1] specification with the l parameter equal to the size of thebase point order of the curve in bytes (e.g. 32 for the P-256 curve and 66 forthe P-521 curve).This specification REQUIRES implementations to implement analgorithm that leads to the same results asECDSA over the P-256prime curve specified in Section D.2.3 of FIPS 186-3 [FIPS-186-3] (and using the SHA-256 hashalgorithm), referred to as theECDSAwithSHA256 signature algorithm [ECC-ALGS].It is further RECOMMENDED that implementations also implementalgorithms that lead to the same results as ECDSA over the P-384and P-521 prime curves; these curves aredefined in Sections D.2.4 and D.2.5 of FIPS 186-3, respectively [ECC-ALGS].Note:As described in IETF RFC 6090, the Elliptic Curve DSA (ECDSA) and KT-Isignature methods are mathematically and functionally equivalent forfields of characteristic greater than three. See IETF RFC 6090 Section7.2 [ECC-ALGS].6.5 Canonicalization AlgorithmsIf canonicalization is performed over octets, the canonicalizationalgorithms take two implicit parameters: the content and its charset. Thecharset is derived according to the rules of the transport protocols and mediatypes (e.g, [XML-MEDIA-TYPES] definesthe media types for XML). This information is necessary to correctly sign andverify documents and often requires careful server side configuration.Various canonicalization algorithms require conversion to[UTF-8]. The algorithms below understand at least [UTF-8] and[UTF-16] as input encodings. We RECOMMEND that externally specifiedalgorithms do the same. Knowledge of other encodings is OPTIONAL.Various canonicalization algorithms transcode from a non-Unicode encodingto Unicode.The output of these algorithms will be in NFC[NFC].This is because theXML processor used to prepare the XPath data model input is required(by the Data Model) to use Normalization Form C when converting an XMLdocument to the UCS character domain from any encoding that is notUCS-based.We RECOMMEND that externally specified canonicalization algorithms do thesame. (Note, there can be ambiguities in converting existing charsets toUnicode, for an example see the XML Japanese Profile Note[XML-Japanese].)This specification REQUIRES implementation of Canonical XML 1.0[XML-C14N],Canonical XML 1.1 [XML-C14N11]] and Exclusive XML Canonicalization [XML-EXC-C14N].We RECOMMEND that applications that generatesignatures choose Canonical XML 1.1 [XML-C14N11] when inclusive canonicalizationis desired.Note: Canonical XML 1.0 [XML-C14N] and Canonical XML 1.1 [XML-C14N11] specify a standardserialization of XML that, when applied to a subdocument, includes thesubdocument's ancestor context including all of the namespace declarations andsome attributes in the 'xml:' namespace. However, some applications require amethod which, to the extent practical, excludes unused ancestor context from acanonicalized subdocument. The Exclusive XML Canonicalization Recommendation [XML-EXC-C14N] may be used to address requirements resulting fromscenarios where a subdocument is moved between contexts.6.5.1 Canonical XML 1.0Identifier for REQUIRED Canonical XML 1.0 (omits comments):http://www.w3.org/TR/2001/REC-xml-c14n-20010315Identifier for Canonical XML 1.0 with Comments:http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithCommentsInput: octet-stream, node-setOutput: octet-streamAn example of an XML canonicalization element is:Example 22 <CanonicalizationMethod Algorithm="http://www.w3.org/TR/2001/REC-xml-c14n-20010315"/>The normative specification of Canonical XML1.0 is [XML-C14N]. The algorithm is capable of takingas input either an octet stream or an XPath node-set (or sufficientlyfunctional alternative). The algorithm produces an octet stream as output.Canonical XML is easily parameterized (via an additional URI) to omit orretain comments.6.5.2 Canonical XML 1.1Identifier for REQUIRED Canonical XML 1.1 (omits comments):http://www.w3.org/2006/12/xml-c14n11Identifier for Canonical XML 1.1 with Comments:http://www.w3.org/2006/12/xml-c14n11#WithCommentsInput: octet-stream, node-setOutput: octet-streamThe normative specification of Canonical XML 1.1 is [XML-C14N11]. The algorithm is capable oftaking as input either an octet stream or an XPath node-set (or sufficientlyfunctional alternative). The algorithm produces an octet stream as output.Canonical XML 1.1 is easily parameterized (via an additional URI) to omit orretain comments.6.5.3 Exclusive XML Canonicalization 1.0Identifier for REQUIRED Exclusive XML Canonicalization 1.0 (omits comments):http://www.w3.org/2001/10/xml-exc-c14n#Identifier for Exclusive XML Canonicalization 1.0 with Comments:http://www.w3.org/2001/10/xml-exc-c14n#WithCommentsInput: octet-stream, node-setOutput: octet-streamThe normative specification of Exclusive XML Canonicalization 1.0 is [XML-EXC-C14N]].6.6 Transform AlgorithmsA Transform algorithm has a single implicit parameter: anoctet stream from the Reference or the output of an earlierTransform.For implementation requirements, please see Algorithm Identifiers andImplementation Requirements. Application developers are strongly encouraged to support alltransforms that are listed as RECOMMENDED unless the application environment has resourceconstraints that would make such support impractical. Compliance with this recommendation willmaximize application interoperability and libraries should be available to enable support of thesetransforms in applications without extensive development.6.6.1 CanonicalizationAny canonicalization algorithm that can be used forCanonicalizationMethod (such as those in Canonicalization Algorithms (section6.5)) can be used as aTransform.6.6.2 Base64Identifiers:http://www.w3.org/2000/09/xmldsig#base64Input: octet-stream, node-setOutput: octet-streamThe normative specification for base64 decoding transforms is [RFC2045].The base64Transform element has no content. The input is decoded by thealgorithms. This transform is useful if an application needs to sign the rawdata associated with the encoded content of an element.This transform accepts either an octet-stream or a node-set as input. If an octet-string isgiven as input, then this octet-stream is processed directly. If an XPath node-set (orsufficiently functional alternative) is given as input, then it is converted to an octet stream byperforming operations logically equivalent to 1) applying an XPath transform with expressionself::text(), then 2) sorting the nodeset by document order, then concatenatingthe string-value of each of the nodes into one long string. Thus, if an XMLelement is identified by a shortname XPointer in the Reference URI, and its contentconsists solely of base64 encoded character data, then this transform automatically strips awaythe start and end tags of the identified element and any of its descendant elements as well as anydescendant comments and processing instructions. The output of this transform is an octetstream.6.6.3 XPath FilteringIdentifier:http://www.w3.org/TR/1999/REC-xpath-19991116Input: octet-stream, node-setOutput: node-setThe normative specification for XPath expression evaluation is [XPATH].The XPath expression to be evaluated appears as the character content of atransform parameter child element named XPath.The input required by this transform is an XPath node-set or an octet-stream. Note that if theactual input is an XPath node-set resulting from a null URI or shortnameXPointer dereference, then comment nodes will have been omitted. If the actualinput is an octet stream, then the application MUST convert the octet streamto an XPath node-set suitable for use by Canonical XML with Comments. (Asubsequent application of the REQUIRED Canonical XML algorithm would stripaway these comments.) In other words, the input node-set should be equivalentto the one that would be created by the following process:Initialize an XPath evaluation context by setting the initial node equalto the input XML document's root node, and set the context position and sizeto 1.Evaluate the XPath expression (//. | //@* | //namespace::*)The evaluation of this expression includes all of the document's nodes(including comments) in the node-set representing the octet stream.The transform output is always an XPath node-set. The XPath expressionappearing in the XPath parameter is evaluated once for each nodein the input node-set. The result is converted to a boolean. If the boolean istrue, then the node is included in the output node-set. If the boolean isfalse, then the node is omitted from the output node-set.Note: Even if the input node-set has had comments removed,the comment nodes still exist in the underlying parse tree and can separatetext nodes. For example, the markup<e>Hello, <!-- comment -->world!</e> contains two text nodes.Therefore, the expression self::text()[string()="Hello, world!"]would fail. Should this problem arise in the application, it can be solved byeither canonicalizing the document before the XPath transform to physicallyremove the comments or by matching the node based on the parent element'sstring value (e.g. by using the expressionself::text()[string(parent::e)="Hello, world!"]).The primary purpose of this transform is to ensure that only specificallydefined changes to the input XML document are permitted after the signature isaffixed. This is done by omitting precisely those nodes that are allowed tochange once the signature is affixed, and including all other input nodes inthe output. It is the responsibility of the XPath expression author to includeall nodes whose change could affect the interpretation of thetransform outputin the application context.Note that the XML-Signature XPath Filter 2.0 Recommendation[XMLDSIG-XPATH-FILTER2] may be used for this purpose. Thatrecommendation defines an XPath transformthat permits the easy specification of subtree selection andomission that canbe efficiently implemented.An important scenario would be a document requiring two envelopedsignatures. Each signature must omit itself from its own digest calculations,but it is also necessary to exclude the second signature element from thedigest calculations of the first signature so that adding the secondsignaturedoes not break the first signature.The XPath transform establishes the following evaluation context for eachnode of the input node-set:A context node equal to a node of the inputnode-set.A context position, initialized to 1.A context size, initialized to 1.A library of functions equal to thefunction setdefined in [XPATH] augmented with a functionnamed hereto be treated as if part of the library (and notnamespace prefixed).A set of variable bindings. No means for initializing these isdefined.Thus, the set of variable bindings used when evaluating theXPath expressionis empty, and use of a variable reference in the XPathexpression results inan error.The set of namespace declarations in scope for the XPathexpression.As a result of the context node setting, the XPath expressionsappearing inthis transform will be quite similar to those used in used in[XSLT],except that the size and position are always 1 to reflect the fact that thetransform is automatically visiting every node (in XSLT, onerecursively callsthe command apply-templates to visit the nodes of the inputtree).The function here() is defined asfollows:Function: node-sethere()The here function returns a node-set containing the attributeor processing instruction node or the parent element of the text node thatdirectly bears the XPath expression.  This expression results in an errorif the containing XPath expression does not appear in the same XML documentagainst which the XPath expression is being evaluated.As an example, consider creating an enveloped signature (aSignature element that is a descendant of an element beingsigned). Although the signed content should not be changed after signing, theelements within the Signatureelement are changing (e.g. the digest value must be put inside theDigestValue and the SignatureValuemust be subsequently calculated). One way to prevent these changes frominvalidating the digest value inDigestValue is to add an XPathTransform that omits all Signatureelements and their descendants. For example,Example 23 <Document>...<Signature xmlns="http://www.w3.org/2000/09/xmldsig#"><SignedInfo>...<Reference URI=""><Transforms><Transform Algorithm="http://www.w3.org/TR/1999/REC-xpath-19991116"><XPath xmlns:dsig="&dsig;">not(ancestor-or-self::dsig:Signature)</XPath></Transform></Transforms><DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#sha1"/><DigestValue></DigestValue></Reference></SignedInfo><SignatureValue></SignatureValue></Signature>...</Document>Due to the null Reference URI in this example, the XPathtransform input node-set contains all nodes in the entire parse tree startingat the root node (except the comment nodes). For each node in this node-set,the node is included in the output node-set except if the node or one of itsancestors has a tag of Signature that is in the namespace givenby the replacement text for the entity&dsig;.A more elegant solution uses the here function to omit only theSignature containing the XPath Transform, thus allowing envelopedsignatures to sign other signatures. In the example above, use the XPathelement:Example 24 <XPath xmlns:dsig="&dsig;">count(ancestor-or-self::dsig:Signature |here()/ancestor::dsig:Signature[1]) >count(ancestor-or-self::dsig:Signature)</XPath>Since the XPath equality operator converts node sets to string valuesbefore comparison, we must instead use the XPath union operator (|). For eachnode of the document, the predicate expression is true if and only if thenode-set containing the node and its Signature element ancestorsdoes not include the enveloped Signature element containing theXPath expression (the union does not produce a larger set if the envelopedSignature element is in the node-set given byancestor-or-self::Signature).6.6.4 Enveloped Signature TransformIdentifier:http://www.w3.org/2000/09/xmldsig#enveloped-signatureInput: node-setOutput: node-setAn enveloped signature transform Tremoves the whole Signature element containingT from the digest calculation of theReference element containingT. The entire string of characters used by an XMLprocessor to match the Signature with the XML productionelement is removed. The output of the transform is equivalent to theoutput that would result from replacing T with anXPath transform containing the following XPath parameter element:Example 25 <XPath xmlns:dsig="&dsig;">count(ancestor-or-self::dsig:Signature |here()/ancestor::dsig:Signature[1]) >count(ancestor-or-self::dsig:Signature)</XPath>The input and output requirements of this transform are identical to thoseof the XPath transform, but may only be applied to a node-set from its parentXML document. Note that it is not necessary to use an XPath expressionevaluator to create this transform. However, this transform MUST produceoutput in exactly the same manner as the XPath transform parameterized by theXPath expression above.6.6.5 XSLT TransformIdentifier:http://www.w3.org/TR/1999/REC-xslt-19991116Input:octet-streamOutput:octet-streamThe normative specification for XSL Transformations is [XSLT].Specification of a namespace-qualified stylesheet element, which MUST be thesole child of the Transform element, indicates that the specifiedstyle sheet should be used. Whether this instantiates in-line processing oflocal XSLT declarations within the resource is determined by the XSLTprocessing model; the ordered application of multiple stylesheet may requiremultipleTransforms. No special provision is made for the identificationof a remote stylesheet at a given URI because it can be communicated via an xsl:include or xsl:import within thestylesheet child of the Transform.This transform requires an octet stream as input.XPath node-set, then the signature application should attempt to convert it tooctets (apply"#sec-Canonical" >Canonical XML]) as described inthe Reference ProcessingModel (section 4.3.3.2). -->The output of this transform is an octet stream. The processing rules forthe XSL style sheet [XSL10] or transform element are stated in the XSLT specification[XSLT].We RECOMMEND that XSLT transform authors use an outputmethod of xml for XML and HTML. As XSLT implementations do notproduce consistent serializations of their output, we further RECOMMENDinserting a transform after the XSLT transform to canonicalize the output.These steps will help to ensure interoperability of the resulting signaturesamong applications that support the XSLT transform. Note that if the output isactually HTML, then the result of these steps is logicallyequivalent [XHTML10].7. XML Canonicalization and Syntax Constraint ConsiderationsDigital signatures only work if the verification calculations areperformedon exactly the same bits as the signing calculations. If the surfacerepresentation of the signed data can change between signing andverification,then some way to standardize the changeable aspect must be usedbefore signingand verification. For example, even for simple ASCII text there are at leastthree widely used line ending sequences. If it is possible for signed text tobe modified from one line ending convention to another between the time ofsigning and signature verification, then the line endings need to becanonicalized to a standard form before signing and verification or thesignatures will break.XML is subject to surface representation changes and to processing whichdiscards some surface information. For this reason, XML digital signatureshave a provision for indicating canonicalization methods in the signature sothat a verifier can use the same canonicalization as the signer.Throughout this specification we distinguish between the canonicalizationof a Signature element and other signed XML data objects. It ispossible for an isolated XML document to be treated as if it were binary dataso that no changes can occur. In that case, the digest of the document willnot change and it need not be canonicalized if it is signed and verified assuch. However, XML that is read and processed using standard XML parsing andprocessing techniques is frequently changed such that some of its surfacerepresentation information is lost or modified. In particular, this will occurin many cases for the Signature and enclosedSignedInfo elements since they, and possibly an encompassing XMLdocument, will be processed as XML.Similarly, these considerations apply toManifest, Object, andSignatureProperties elements if those elements have beendigested, their DigestValue is to be checked, and they are beingprocessed as XML.The kinds of changes in XML that may need to be canonicalized can bedivided into four categories. There are those related to the basic[XML10],as described in 7.1 below. There are those related to[DOM-LEVEL-1],[SAX], or similarprocessing as described in 7.2 below. Third, there is thepossibility of codedcharacter set conversion, such as between UTF-8 and UTF-16, both ofwhich all [XML10] compliant processors are required to support,which is described in the paragraph immediately below. And, fourth, there arechanges that related to namespace declaration and XML namespace attributecontext as described in 7.3 below.Any canonicalization algorithm should yield output in a specific fixedcoded character set. All canonicalization algorithms identified in this document useUTF-8 (without a byte order mark (BOM)) and do not provide characternormalization. We RECOMMEND that signature applications create XMLcontent (Signatureelements and their descendants/content) inNormalization Form C [NFC]and check that any XML being consumed is inthat form as well; (if not, signatures may consequently fail to validate).Additionally, none of these algorithms provide data type normalization.Applications that normalize data types in varying formats (e.g.,(true, false)or (1,0)) may not be able to validate each other's signatures.7.1 XML 1.0 Syntax Constraints, and CanonicalizationXML 1.0 [XML10]] defines an interfacewhere a conformant application reading XML is given certain information fromthat XML and not other information. In particular,line endings are normalized to the single character #xA by dropping #xDcharacters if they are immediately followed by a #xA and replacing them with#xA in all other cases,missing attributes declared to have default values are provided to theapplication as if present with the default value, character references are replaced with the corresponding character,entity references are replaced with the corresponding declared entity,attribute values are normalized byreplacing character and entity references as above,replacing occurrences of #x9, #xA, and #xD with #x20 (space) exceptthat the sequence #xD#xA is replaced by a single space, andif the attribute is not declared to be CDATA, stripping all leadingand trailing spaces and replacing all interior runs of spaces with asingle space.Note that items (2), (4), and (5.3) depend on the presence of a schema, DTDor similar declarations. The Signatureelement type is laxly schema valid[XMLSCHEMA-1][XMLSCHEMA-2], consequently external XML or even XML within thesame document as the signature may be (only) well-formed or from anothernamespace (where permitted by the signature schema); the noted items may notbe present. Thus, a signature with such content will only be verifiable byother signature applications if the following syntax constraints are observedwhen generating any signed material including theSignedInfo element:attributes having default values be explicitly present,all entity references (except "amp", "lt", "gt", "apos", "quot", andother character entities not representable in the encoding chosen) beexpanded,attribute value white space be normalized7.2 DOM/SAX Processing and CanonicalizationIn addition to the canonicalization and syntax constraints discussed above,many XML applications use the Document Object Model [DOM-LEVEL-1]or the Simple API for XML  [SAX]. DOMmaps XML into a tree structure of nodes and typically assumes it will be usedon an entire document with subsequent processing being done on this tree. SAXconverts XML into a series of events such as a start tag, content, etc. Ineither case, many surface characteristics such as the ordering of attributesand insignificant white space within start/end tags is lost. In addition,namespace declarations are mapped over the nodes to which they apply, losingthe namespace prefixes in the source text and, in most cases, losing wherenamespace declarations appeared in the original instance.If an XML Signature is to be produced or verified on a system using the DOMor SAX processing, a canonical method is needed to serialize the relevant partof a DOM tree or sequence of SAX events. XML canonicalization specifications,such as [XML-C14N], are based only on informationwhich is preserved by DOM and SAX. For an XML Signature to be verifiable by animplementation using DOM or SAX, not only must theXML 1.0 syntax constraints given in the section 7.1 XML 1.0 Syntax Constraints, and Canonicalizationbe followed butan appropriate XML canonicalization MUST be specified so that the verifier canre-serialize DOM/SAX mediated input into the same octet stream that wassigned.7.3 Namespace Context and Portable SignaturesIn [XPATH] and consequently theCanonical XML data model an element has namespace nodes that correspond tothose declarations within the element and its ancestors:"Note: An elementE has namespace nodes that represent its namespacedeclarations as well as any namespace declarations made by itsancestors that have not been overridden in E'sdeclarations, the default namespace if it is non-empty, and the declarationof the prefix xml." [XML-C14N]When serializing a Signature element or signed XMLdata that's the child of other elements using these data models, that Signatureelement and its children may have in-scope namespaces inherited from its ancestral context.In addition, the Canonical XML and Canonical XML withComments algorithms define special treatment for attributes in the XML namespace,which can cause them to be part of the canonicalized XML even if they were outsideof the document subset. Simple inheritable attributes (i.e. attributes that have a valuethat requires at most a simple redeclaration such as xml:lang and xml:space)are inherited from nearestancestor in which they are declared to the apex nodeof canonicalized XML unless they are already declared at that node.This may frustrate the intent of the signer to create a signature inone context which remains valid in another. For example, given asignature which is a child of B and agrandchild of A:Example 26 <A xmlns:n1="http://foo.example"><B xmlns:n2="http://bar.example"><Signature xmlns="http://www.w3.org/2000/09/xmldsig#">...<Reference URI="#signme"/> ...</Signature><C ID="signme" xmlns="http://baz.example" /></B></A>when either the element B or the signed element Cis moved into a [SOAP12-PART1] envelope for transport:Example 27 <SOAP:Envelope xmlns:SOAP="http://schemas.xmlsoap.org/soap/envelope/">...<SOAP:Body><B xmlns:n2="http://bar.example"><Signature xmlns="http://www.w3.org/2000/09/xmldsig#">...</Signature><C ID="signme" xmlns="http://baz.example" /></B></SOAP:Body></SOAP:Envelope>The canonical form of the signature in this context will contain newnamespace declarations from theSOAP:Envelope context, invalidating the signature. Also, thecanonical form will lack namespace declarations it may have originally hadfrom element A's context, also invalidating the signature. Toavoid these problems, the application may:Rely upon the enveloping application to properly divorce its body (thesignature payload) from the context (the envelope) before the signature isvalidated. Or,Use a canonicalization method that "repels/excludes" instead of"attracts" ancestor context. [XML-C14N] purposefully attracts suchcontext.8. Security ConsiderationsThe XML Signature specification provides a very flexible digital signaturemechanism. Implementers must give consideration to their application threatmodels and to the following factors. For additional securityconsiderations in implementation and deployment of thisspecification, see[XMLDSIG-BESTPRACTICES].8.1 TransformsA requirement of this specification is to permit signatures to "apply to apart or totality of a XML document." (See[XMLDSIG-REQUIREMENTS], section 3.1.3].) TheTransforms mechanism meets this requirement by permitting one tosign data derived from processing the content of the identified resource. Forinstance, applications that wish to sign a form, but permit users to enterlimited field data without invalidating a previous signature on the form mightuse [XPATH] to exclude those portionsthe user needs to change. Transforms may be arbitrarily specifiedand may include encoding transforms, canonicalization instructions or evenXSLT transformations. Three cautions are raised with respect to this featurein the following sections.Note, core validation behavior does not confirm that the signed data wasobtained by applying each step of the indicated transforms. (Though it doescheck that the digest of the resulting content matches that specified in thesignature.)  For example, some applications may be satisfied withverifying an XML signature over a cached copy of already transformed data.Other applications might require that content be freshly dereferenced andtransformed.8.1.1 Only What is Signed is SecureFirst, obviously, signatures over a transformed document do not secure anyinformation discarded by transforms: only what is signed is secure.Note that the use of Canonical  XML [XML-C14N] ensures that all internal entitiesand XML namespaces are expanded within the content being signed. All entitiesare replaced with their definitions and the canonical form explicitlyrepresents the namespace that an element would otherwise inherit. Applicationsthat do not canonicalize XML content (especially theSignedInfo element) SHOULD NOT use internal entities and SHOULDrepresent the namespace explicitly within the content being signed since theycan not rely upon canonicalization to do this for them. Also, users concernedwith the integrity of the element type definitions associated with the XMLinstance being signed may wish to sign those definitions as well (i.e., theschema, DTD, or natural language description associated with thenamespace/identifier).Second, an envelope containing signed information is not secured by thesignature. For instance, when an encrypted envelope contains a signature, thesignature does not protect the authenticity or integrity of unsigned envelopeheaders nor its ciphertext form, it only secures the plaintext actuallysigned.8.1.2 Only What is "Seen" Should be SignedAdditionally, the signature secures any information introduced by thetransform: only what is "seen" (that which is represented to the user viavisual, auditory or other media) should be signed. If signing is intended toconvey the judgment or consent of a user (an automated mechanism or person),then it is normally necessary to secure as exactly as practical theinformation that was presented to that user. Note that this can beaccomplished by literally signing what was presented, such as the screenimages shown a user. However, this may result in data which is difficult forsubsequent software to manipulate. Instead, one can sign the data along withwhatever filters, style sheets, client profile or other information thataffects its presentation.8.1.3 "See" What is SignedJust as a user should only sign what he or she "sees," persons andautomated mechanism that trust the validity of a transformed document on thebasis of a valid signature should operate over the data that was transformed(including canonicalization) and signed, not the original pre-transformeddata. This recommendation applies to transforms specified within the signatureas well as those included as part of the document itself. For instance, if anXML document includes an embedded style sheet [XSLT] it is the transformed document that should be represented tothe user and signed. To meet this recommendation where a document referencesan external style sheet, the content of that external resource should also besigned as via a signature Reference otherwise the content of thatexternal content might change which alters the resulting document withoutinvalidating the signature.Some applications might operate over the original or intermediary data butshould be extremely careful about potential weaknesses introduced between theoriginal and transformed data. This is a trust decision about the characterand meaning of the transforms that an application needs to make with caution.Consider a canonicalization algorithm that normalizes character case (lower toupper) or character composition ('e and accent' to 'accented-e'). An adversarycould introduce changes that are normalized and consequently inconsequentialto signature validity but material to a DOM processor. For instance, bychanging the case of a character one might influence the result of an XPathselection. A serious risk is introduced if that change is normalized forsignature validation but the processor operates over the original data andreturns a different result than intended.As a result:All documents operated upon and generated by signature applications MUSTbe in [NFC] (otherwise intermediate processors mightunintentionally break the signature)Encoding normalizations SHOULD NOT be done as part of a signaturetransform, or (to state it another way) if normalization does occur, theapplication SHOULD always "see" (operate over) the normalized form.8.2 Check the Security ModelThis specification uses public key signatures and keyed hash authenticationcodes. These have substantially different security models. Furthermore, itpermits user specified algorithms which may have other models.With public key signatures, any number of parties can hold the public keyand verify signatures while only the parties with the private key can createsignatures. The number of holders of the private key should be minimized andpreferably be one. Confidence by verifiers in the public key they are usingand its binding to the entity or capabilities represented by the correspondingprivate key is an important issue, usually addressed by certificate or onlineauthority systems.Keyed hash authentication codes, based on secret keys, are typically muchmore efficient in terms of the computational effort required but have thecharacteristic that all verifiers need to have possession of the same key asthe signer. Thus any verifier can forge signatures.This specification permits user provided signature algorithms and keyinginformation designators. Such user provided algorithms may have differentsecurity models. For example, methods involving biometrics usually depend on aphysical characteristic of the authorized user that can not be changed the waypublic or secret keys can be and may have other security model differences.8.3 Algorithms, Key Lengths, Certificates, Etc.The strength of a particular signature depends on all links in the securitychain. This includes the signature and digest algorithms used, the strength ofthe key generation [RANDOM] and the size of the key, the securityof key and certificate authentication and distribution mechanisms, certificatechain validation policy, protection of cryptographic processing from hostileobservation and tampering, etc.Care must be exercised by applications in executing the various algorithmsthat may be specified in an XML signature and in the processing of any"executable content" that might be provided to such algorithms as parameters,such as XSLT transforms. The algorithms specified in this document willusually be implemented via a trusted library but even there perverseparameters might cause unacceptable processing or memory demand. Even morecare may be warranted with application defined algorithms.The security of an overall system will also depend on the security andintegrity of its operating procedures, its personnel, and on theadministrative enforcement of those procedures. All the factors listed in thissection are important to the overall security of a system; however, most arebeyond the scope of this specification.8.4 Error MessagesImplementations SHOULD NOT provide detailed error responses related tosecurity algorithm processing. Error messages should be limited to ageneric error message to avoid providing information to a potentialattacker related to the specifics of the algorithm implementation. Forexample, if an error occurs in signature verification processing the errorresponse should be a generic message providing nospecifics on the details of the processing error.9. Schema9.1 XSD SchemaXML Signature Core Schema Instancexmldsig-core-schema.xsdValid XML schema instance based on[XMLSCHEMA-1][XMLSCHEMA-2].XML Signature 1.1 Schema Instancexmldsig11-schema.xsdThis schema document defines the additional elements defined in this version of the XMLSignature specification.XML Signature 1.1 Schema Driverxmldsig1-schema.xsdThis schema instance binds together the XML Signature Core Schema Instance and the XMLSignature 1.1 Schema Instance9.2 RNG Schema This section is non-normative.Non-normative RELAX NG schema [RELAXNG-SCHEMA] information isavailable in a separate document [XMLSEC-RELAXNG].10. DefinitionsAuthentication Code(Protected Checksum)A value generated from the application of a shared key to a message viaa cryptographic algorithm such that it has the properties of message authentication (andintegrity) but not signer authentication. Equivalent to protected checksum,"A checksum that is computed for a data object by means that protect againstactive attacks that would attempt to change the checksum to make it matchchanges made to the data object."  [RFC4949]Authentication, MessageThe property, given an authentication code/protected checksum, that tampering with both the data andchecksum, so as to introduce changes while seemingly preserving integrity, are still detected. "A signature should identify whatis signed, making it impracticable to falsify or alter either the signedmatter or the signature without detection." [ABA-DSIG-GUIDELINES].Authentication, SignerThe property that the identity of the signer is as claimed. "A signatureshould indicate who signed a document, message or record, and should bedifficult for another person to produce withoutauthorization." [ABA-DSIG-GUIDELINES]Note, signer authentication is an application decision(e.g., does the signing key actually correspond to a specific identity) thatis supported by, but out of scope, of this specification.Checksum"A value that (a) is computed by a function that is dependent on thecontents of a data object and (b) is stored or transmitted together with theobject, for the purpose of detecting changes in the data."  [RFC4949]CoreThe syntax and processing defined by this specification, including core validation. We use this term to distinguish other markup,processing, and applications semantics from our own.Data Object (Content/Document)The actual binary/octet data being operated on (transformed, digested,or signed) by an application -- frequently an HTTP entity [HTTP11]. Note that the propernoun Objectdesignates a specific XML element. Occasionally we refer to a data object asa document or as a resource's content.The term element content is used to describe the data between XMLstart and end tags [XML10]. The term XML document is used todescribe data objects which conform to the XML specification [XML10].Integrity"The property that data has not been changed, destroyed, or lost in anunauthorized or accidental manner." [RFC4949] A simple checksum can provideintegrity from incidental changes in the data; message authentication is similar but also protects against anactive attack to alter the data whereby a change in the checksum isintroduced so as to match the change in the data. ObjectAn XML Signature element wherein arbitrary (non-core) data may be placed. AnObject element is merely one type of digital data (or document) thatcan be signed via aReference.Resource"A resource can be anything that has identity. Familiar examples includean electronic document, an image, a service (e.g., 'today's weather reportfor Los Angeles'), and a collection of other resources.... The resource isthe conceptual mapping to an entity or set of entities, not necessarily theentity which corresponds to that mapping at any particular instance in time.Thus, a resource can remain constant even when its content---the entities towhich it currently corresponds---changes over time, provided that theconceptual mapping is not changed in the process." [URI] In order to avoid a collision of the termentity within the URI and XML specifications, we use the term dataobject,content or document to refer to the actual bits/octetsbeing operated upon.SignatureFormally speaking, a value generated from the application of a privatekey to a message via a cryptographic algorithm such that it has theproperties of integrity, message authentication and/or signer authentication. (However, we sometimes use the termsignature generically such that it encompassesAuthentication Code values as well, but we are careful to makethe distinction when the property of signer authentication is relevant to the exposition.) A signaturemay be (non-exclusively) described asdetached, enveloping, or enveloped.Signature, ApplicationAn application that implements the MANDATORY (REQUIRED/MUST) portions ofthis specification; these conformance requirements are over applicationbehavior, the structure of the Signature element type and itschildren (including SignatureValue) and the specifiedalgorithms.Signature, DetachedThe signature is over content external to theSignature element, and can be identified via aURI or transform. Consequently, the signature is "detached"from the content it signs. This definition typically applies to separatedata objects, but it also includes the instance where the Signatureand data object reside within the same XML document but are siblingelements.Signature, EnvelopingThe signature is over content found within anObject element of the signature itself. TheObject (or its content) is identified via aReference (via a URI fragment identifier ortransform).Signature, EnvelopedThe signature is over the XML content that contains the signature as anelement. The content provides the root XML document element. Obviously,enveloped signatures must take care not to include their own value in thecalculation of theSignatureValue.TransformThe processing of a data from its source to its derived form. Typicaltransforms include XML Canonicalization, XPath, and XSLT.Validation, CoreThe core processing requirements of this specification requiring signature validation andSignedInfo reference validation.Validation, ReferenceThe hash value of the identified and transformed content, specified byReference, matches its specifiedDigestValue.Validation, SignatureThe SignatureValue matches the result of processingSignedInfo with CanonicalizationMethod andSignatureMethod as specified in Core Validation (section 3.2).Validation, Trust/ApplicationThe application determines that the semantics associated with asignature are valid. For example, an application may validate the timestamps or the integrity of the signer key -- though this behavior isexternal to this corespecification.A. References Dated references below are to the latest known or appropriate edition of the referenced work. The referenced works may be subject to revision, and conformant implementations may follow, and are encouraged to investigate the appropriateness of following, some or all more recent editions or replacements of the works cited. It is in each case implementation-defined which editions are supported. A.1 Normative references [ECC-ALGS] D. McGrew; K. Igoe; M. Salter. RFC 6090: Fundamental Elliptic Curve Cryptography Algorithms. February 2011. IETF Informational RFC. URL: http://www.rfc-editor.org/rfc/rfc6090.txt[FIPS-180-3] FIPS PUB 180-3 Secure Hash Standard. U.S. Department of Commerce/National Institute of Standards and Technology. URL: http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf[FIPS-186-3] FIPS PUB 186-3: Digital Signature Standard (DSS). June 2009. U.S. Department of Commerce/National Institute of Standards and Technology. URL: http://csrc.nist.gov/publications/fips/fips186-3/fips_186-3.pdf[HMAC] H. Krawczyk, M. Bellare, R. Canetti. HMAC: Keyed-Hashing for Message Authentication. February 1997. IETF RFC 2104. URL: http://www.ietf.org/rfc/rfc2104.txt[HTTP11] R. Fielding et al. Hypertext Transfer Protocol - HTTP/1.1. June 1999. RFC 2616. URL: http://www.ietf.org/rfc/rfc2616.txt[LDAP-DN] K. Zeilenga. Lightweight Directory Access Protocol : String Representation of Distinguished Names. June 2006. IETF RFC 4514. URL: http://www.ietf.org/rfc/rfc4514.txt[NFC] M. Davis, Ken Whistler. TR15, Unicode Normalization Forms.. 17 September 2010, URL: http://www.unicode.org/reports/tr15/[PGP] J. Callas, L. Donnerhacke, H. Finney, D. Shaw, R. Thayer. OpenPGP Message Format. IETF RFC 4880. November 2007. URL: http://www.ietf.org/rfc/rfc4880.txt[PKCS1] J. Jonsson and B. Kaliski. Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1. RFC 3447 (Informational), February 2003. URL: http://www.ietf.org/rfc/rfc3447.txt[RFC2045] N. Freed and N. Borenstein. Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies. November 1996. URL: http://www.ietf.org/rfc/rfc2045.txt[RFC2119] S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Internet RFC 2119. URL: http://www.ietf.org/rfc/rfc2119.txt[RFC3279] W. Polk, R. Housley, L. Bassham. Algorithmupdates and Identifiers for the Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile. April 2002. Internet RFC 3279. URL: http://www.ietf.org/rfc/rfc3279.txt[RFC3406] L. Daigle, D. van Gulik, R. Iannella, P. Faltstrom. URN Namespace Definition Mechanisms.. IETF RFC 3406 October 2002. URL: http://www.ietf.org/rfc/rfc3406.txt[RFC4055] J. Schaad, B. Kaliski, R. Housley. Additional Algorithms and Identifiers for RSA Cryptography for use in the Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile. June 2005. IETF RFC 4055. URL: http://www.ietf.org/rfc/rfc4055.txt[RFC5280] D. Cooper, et. al. Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile. . IETF RFC 5280 May 2008. URL: http://www.ietf.org/rfc/rfc5280.txt[RFC5480] S. Turner, et. al. Elliptic Curve Cryptography Subject Public Key Information.. IETF RFC 5480 March 2009. URL: http://www.ietf.org/rfc/rfc5480.txt[RFC6931] D. Eastlake 3rd. Additional XML Security Uniform Resource Identifiers. RFC 6931 April 2013. URL: http://tools.ietf.org/html/rfc6931[SP800-57] Recommendation for Key Management â Part 1: General (Revision 3). SP800-57. July 2012. U.S. Department of Commerce/National Institute of Standards and Technology. URL: http://csrc.nist.gov/publications/nistpubs/800-57/sp800-57_part1_rev3_general.pdf[URI] T. Berners-Lee; R. Fielding; L. Masinter. Uniform Resource Identifiers (URI): generic syntax. January 2005. RFC 3986. URL: http://www.ietf.org/rfc/rfc3986.txt[URN] R. Moats. URN Syntax. IETF RFC 2141. May 1997. URL: http://www.ietf.org/rfc/rfc2141.txt[URN-OID] M. Mealling. A URN Namespace of Object Identifiers. . IETF RFC 3061. February 2001. URL: http://www.ietf.org/rfc/rfc3061.txt[UTF-8] F. Yergeau. UTF-8, a transformation format of ISO 10646. IETF RFC 3629. November 2003. URL: http://www.ietf.org/rfc/rfc3629.txt[X509V3] ITU-T Recommendation X.509 version 3 (1997). "Information Technology - Open Systems Interconnection - The Directory Authentication Framework"  ISO/IEC 9594-8:1997.[XML-C14N] John Boyer. Canonical XML Version 1.0. 15 March 2001. W3C Recommendation. URL: http://www.w3.org/TR/2001/REC-xml-c14n-20010315[XML-C14N11] John Boyer; Glenn Marcy. Canonical XML Version 1.1. 2 May 2008. W3C Recommendation. URL: http://www.w3.org/TR/2008/REC-xml-c14n11-20080502/[XML-EXC-C14N] Donald E. Eastlake 3rd; Joseph Reagle; John Boyer. Exclusive XML Canonicalization Version 1.0. 18 July 2002. W3C Recommendation. URL: http://www.w3.org/TR/2002/REC-xml-exc-c14n-20020718/[XML-MEDIA-TYPES] Ãmit YalÃ§Ä±nalp; Anish Karmarkar. Describing Media Content of Binary Data in XML. 4 May 2005. W3C Note. URL: http://www.w3.org/TR/2005/NOTE-xml-media-types-20050504/[XML-NAMES] Richard Tobin et al. Namespaces in XML 1.0 (Third Edition). 8 December 2009. W3C Recommendation. URL: http://www.w3.org/TR/2009/REC-xml-names-20091208/[XML10] C. M. Sperberg-McQueen et al. Extensible Markup Language (XML) 1.0 (Fifth Edition). 26 November 2008. W3C Recommendation. URL: http://www.w3.org/TR/2008/REC-xml-20081126/[XMLDSIG-XPATH-FILTER2] Merlin Hughes; John Boyer; Joseph Reagle. XML-Signature XPath Filter 2.0. 8 November 2002. W3C Recommendation. URL: http://www.w3.org/TR/2002/REC-xmldsig-filter2-20021108/[XMLENC-CORE1] J. Reagle; D. Eastlake; F. Hirsch; T. Roessler. XML Encryption Syntax and Processing Version 1.1. 11 April 2013. W3C Recommendation. URL: http://www.w3.org/TR/2013/REC-xmlenc-core1-20130411/[XMLSCHEMA-1] Henry S. Thompson et al. XML Schema Part 1: Structures Second Edition. 28 October 2004. W3C Recommendation. URL: http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/[XMLSCHEMA-2] Paul V. Biron; Ashok Malhotra. XML Schema Part 2: Datatypes Second Edition. 28 October 2004. W3C Recommendation. URL: http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/[XPATH] James Clark; Steven DeRose. XML Path Language (XPath) Version 1.0. 16 November 1999. W3C Recommendation. URL: http://www.w3.org/TR/1999/REC-xpath-19991116/[XPTR-ELEMENT] Norman Walsh et al. XPointer element() Scheme. 25 March 2003. W3C Recommendation. URL: http://www.w3.org/TR/2003/REC-xptr-element-20030325/[XPTR-FRAMEWORK] Paul Grosso et al. XPointer Framework. 25 March 2003. W3C Recommendation. URL: http://www.w3.org/TR/2003/REC-xptr-framework-20030325/[XSL10] Jeremy Richman et al. Extensible Stylesheet Language (XSL) Version 1.0. 15 October 2001. W3C Recommendation. URL: http://www.w3.org/TR/2001/REC-xsl-20011015/[XSLT] James Clark. XSL Transformations (XSLT) Version 1.0. 16 November 1999. W3C Recommendation. URL: http://www.w3.org/TR/1999/REC-xslt-19991116A.2 Informative references [ABA-DSIG-GUIDELINES] Digital Signature Guidelines. 1 August 1996. Information Security Committee, American Bar Association. URL: http://www.signelec.com/content/download/digital_signature_guidelines.pdf[CVE-2009-0217] Common Vulnerabilities and Exposures List, CVE-2009-0217 URL: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0217[DOM-LEVEL-1] Vidur Apparao et al. Document Object Model (DOM) Level 1. 1 October 1998. W3C Recommendation. URL: http://www.w3.org/TR/1998/REC-DOM-Level-1-19981001/[IEEE1363] IEEE 1363: Standard Specifications for Public Key Cryptography. August 2000. URL: http://grouper.ieee.org/groups/1363/[RANDOM] D. Eastlake, S. Crocker, J. Schiller. Randomness Recommendations for Security.. IETF RFC 4086. June 2005. URL: http://www.ietf.org/rfc/rfc4086.txt[RDF-PRIMER] Frank Manola; Eric Miller. RDF Primer. 10 February 2004. W3C Recommendation. URL: http://www.w3.org/TR/2004/REC-rdf-primer-20040210/[RELAXNG-SCHEMA] Information technology -- Document Schema Definition Language (DSDL) -- Part 2: Regular-grammar-based validation -- RELAX NG. ISO/IEC 19757-2:2008. URL: http://standards.iso.org/ittf/PubliclyAvailableStandards/c052348_ISO_IEC_19757-2_2008(E).zip[RFC4050] S. Blake-Wilson; G. Karlinger; T. Kobayashi; Y. Wang. Using the Elliptic Curve Signature Algorithm (ECDSA) for XML Digital Signatures (RFC 4050). April 2005. RFC. URL: http://www.ietf.org/rfc/rfc4050.txt[RFC4949] R. Shirey. Internet Security Glossary, Version 2.. IETF RFC 4949. August 2007. URL: http://www.ietf.org/rfc/rfc4949.txt[SAX] D. Megginson, et al. SAX: The Simple API for XML. May 1998. URL: http://www.megginson.com/downloads/SAX/[SHA-1-Analysis] McDonald, C., Hawkes, P., and J. Pieprzyk. SHA-1 collisions now 252 . EuroCrypt 2009 Rump session. URL: http://eurocrypt2009rump.cr.yp.to/837a0a8086fa6ca714249409ddfae43d.pdf[SHA-1-Collisions] X. Wang, Y.L. Yin, H. Yu. Finding Collisions in the Full SHA-1. In Shoup, V., editor, Advances in Cryptology - CRYPTO 2005, 25th Annual International Cryptology Conference, Santa Barbara, California, USA, August 14-18, 2005, Proceedings, volume 3621 of LNCS, pages 17â36. Springer, 2005. URL: http://people.csail.mit.edu/yiqun/SHA1AttackProceedingVersion.pdf (also published in http://www.springerlink.com/content/26vljj3xhc28ux5m/)[SOAP12-PART1] Noah Mendelsohn et al. SOAP Version 1.2 Part 1: Messaging Framework (Second Edition). 27 April 2007. W3C Recommendation. URL: http://www.w3.org/TR/2007/REC-soap12-part1-20070427/[UTF-16] P. Hoffman , F. Yergeau. UTF-16, an encoding of ISO 10646. IETF RFC 2781. February 2000. URL: http://www.ietf.org/rfc/rfc2781.txt[XHTML10] Steven Pemberton. XHTMLâ¢ 1.0 The Extensible HyperText Markup Language (Second Edition). 1 August 2002. W3C Recommendation. URL: http://www.w3.org/TR/2002/REC-xhtml1-20020801/[XML-Japanese] M. Murata. XML Japanese Profile (2nd Edition). March 2005. W3C Member Submission. URL: http://www.w3.org/Submission/2005/SUBM-japanese-xml-20050324/[XMLDSIG-BESTPRACTICES] Pratik Datta; Frederick Hirsch. XML Signature Best Practices. 11 April 2013. W3C Working Group Note. URL: http://www.w3.org/TR/2013/NOTE-xmldsig-bestpractices-20130411/[XMLDSIG-CORE] Joseph Reagle et al. XML Signature Syntax and Processing (Second Edition). 10 June 2008. W3C Recommendation. URL: http://www.w3.org/TR/2008/REC-xmldsig-core-20080610/[XMLDSIG-CORE1-CHGS] Frederick Hirsch. Functional Explanation of Changes in XML Signature 1.1. 11 April 2013. W3C Working Group Note. URL: http://www.w3.org/TR/2013/NOTE-xmldsig-core1-explain-20130411/[XMLDSIG-REQUIREMENTS] Joseph Reagle Jr. XML-Signature Requirements. 14 October 1999. W3C Working Draft. URL: http://www.w3.org/TR/1999/WD-xmldsig-requirements-19991014[XMLSEC-RELAXNG] Makoto Murata; Frederick Hirsch. XML Security RELAX NG Schemas. 11 April 2013. W3C Working Group Note. URL: http://www.w3.org/TR/2013/NOTE-xmlsec-rngschema-20130411/[XMLSEC11-REQS] Frederick Hirsch; Thomas Roessler. XML Security 1.1 Requirements and Design Considerations. 11 April 2013. W3C Working Group Note. URL: http://www.w3.org/TR/2013/NOTE-xmlsec-reqs-20130411/[XPTR-XMLNS] Jonathan Marsh et al. XPointer xmlns() Scheme. 25 March 2003. W3C Recommendation. URL: http://www.w3.org/TR/2003/REC-xptr-xmlns-20030325/[XPTR-XPOINTER] Ron Daniel Jr; Eve Maler; Steven DeRose. XPointer xpointer() Scheme. 19 December 2002. W3C Working Draft. URL: http://www.w3.org/TR/2002/WD-xptr-xpointer-20021219/[XPTR-XPOINTER-CR2001] Ron Daniel Jr; Eve Maler; Steven DeRose. XPointer xpointer() Scheme. September 2001. W3C Candidate Recommendation. URL: http://www.w3.org/TR/2001/CR-xptr-20010911/