"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">Mobile Web Application Best Practicesrel="stylesheet" />ul.coverage_list li { text-indent: -3em; padding-left: 3em; list-style-type: none;}code { font-family: monospace; }.comment {background-color: #FFc0c0;}div.constraint,div.issue,div.note,div.notice { margin-left: 2em; }ol.enumar { list-style-type: decimal; }ol.enumla { list-style-type: lower-alpha; }ol.enumlr { list-style-type: lower-roman; }ol.enumua { list-style-type: upper-alpha; }ol.enumur { list-style-type: upper-roman; }.stmt, .stmt1{ border: 1px solid black ;background-color: #c0e0e0;padding: 5pt}.ednote {border: 1px dashed black ;background-color: #FFc0c0}.new {background-color: #FFFF80}.note {background-color: #00FFFF}div.exampleInner pre { margin-left: 1em;margin-top: 0em; margin-bottom: 0em}div.exampleOuter {border: 4px double gray;margin: 0em; padding: 0em}div.exampleInner { background-color: #d5dee3;border-top-width: 4px;border-top-style: double;border-top-color: #d3d3d3;border-bottom-width: 4px;border-bottom-style: double;border-bottom-color: #d3d3d3;padding: 4px; margin: 0em }div.exampleWrapper { margin: 4px }div.exampleHeader { font-weight: bold;margin: 4px}p { margin-bottom: 15px }Mobile Web Application Best PracticesW3C Recommendation 14 December 2010This version:http://www.w3.org/TR/2010/REC-mwabp-20101214/Latest version:http://www.w3.org/TR/mwabp/Previous version:http://www.w3.org/TR/2010/PR-mwabp-20101021/Editors:Adam Connors, GoogleBryan Sullivan, AT&T (until 2008)Please refer to the errata for this document, which may include some normative corrections.See also translations.Copyright ©2010 W3C® (MIT, ERCIM, Keio), All Rights Reserved. W3C liability, trademark and document use rules apply.AbstractThe goal of this document is to aid the development of rich and dynamic mobile Web applications. It collects the most relevant engineering practices, promoting those that enable a better user experience and warning against those that are considered harmful.Status of This DocumentThis section describes the status of this document at the time of its publication. Other documents may supersede this document. A list of current W3C publications and the latest revision of this technical report can be found in the W3C technical reports index at http://www.w3.org/TR/.This is the W3C Recommendation of Mobile Web Application Best Practices. This document was developed by the Mobile Web Best Practices Working Group as part of the Mobile Web Initiative.Since publication as a Proposed Recommendation on 21 October 2010, the Working Group clarified that alternative compression formats (such as EXI) referred to in section 3.4.1 Use Transfer Compression may not share some of the impediments of common compression formats. A diff version is available. No substantive change has been made.The document contains statements that may be regarded as forward-looking when this document is published (14 December 2010). Examples provided in the How to do it sections sometimes reference on-going works on technologies that the Working Group expects to become prevalent in the development community soon. These sections should be taken with a grain of salt, depending on the actual evolution of these technologies. The best practices statements should remain valid in any case. An implementation report is available.Comments on this specification may be sent to public-bpwg-comments@w3.org (with public archive).This document has been reviewed by W3C Members, by software developers, and by other W3C groups and interested parties, and is endorsed by the Director as a W3C Recommendation. It is a stable document and may be used as reference material or cited from another document. W3C's role in making the Recommendation is to draw attention to the specification and to promote its widespread deployment. This enhances the functionality and interoperability of the Web.This document was produced by a group operating under the 5 February 2004 W3C Patent Policy. This document is informative only. W3C maintains a public list of any patent disclosures made in connection with the deliverables of the group; that page also includes instructions for disclosing a patent. An individual who has actual knowledge of a patent which the individual believes contains Essential Claim(s) must disclose the information in accordance with section 6 of the W3C Patent Policy.Table of Contents1 Introduction    1.1 Purpose of the Document    1.2 Audience    1.3 Scope        1.3.1 Best Practices        1.3.2 Web Application        1.3.3 Mobile Context        1.3.4 Delivery Context    1.4 Relationship to other Best Practices andrecommendations    1.5 Terminology2 Structure of Best Practice Statements3 Best Practice Statements    3.1 Application Data        3.1.1 Use Cookies Sparingly/>        3.1.2 Use Appropriate Client-SideStorage Technologies for Local Data        3.1.3 Replicate Local Data    3.2 Security and privacy        3.2.1 Do not Execute Unescaped orUntrusted JSON data    3.3 User Awareness and Control        3.3.1 Ensure the User isInformed About Use of Personal and Device Information        3.3.2 Enable AutomaticSign-in    3.4 Conservative use of resources        3.4.1 Use TransferCompression        3.4.2 Minimize Applicationand Data Size        3.4.3 Avoid Redirects        3.4.4 Optimize NetworkRequests        3.4.5 Minimize ExternalResources        3.4.6 Aggregate Static Imagesinto a Single Composite Resource (Sprites)        3.4.7 Include BackgroundImages Inline in CSS Style Sheets        3.4.8 Cache Resources ByFingerprinting Resource References        3.4.9 Cache AJAX Data        3.4.10 Do not Send CookieInformation Unnecessarily        3.4.11 Keep DOM SizeReasonable    3.5 User Experience        3.5.1 Optimize ForApplication Start-up Time        3.5.2 Minimize PerceivedLatency        3.5.3 Design forMultiple Interaction Methods        3.5.4 Preserve Focus onDynamic Page Updates        3.5.5 Use Fragment IDs toDrive Application View        3.5.6 Make TelephoneNumbers "Click-to-Call"        3.5.7 Ensure Paragraph TextFlows        3.5.8 Ensure Consistency Of StateBetween Devices        3.5.9 Consider Mobile SpecificTechnologies for Initiating Web Applications        3.5.10 Use Meta Viewport Element ToIdentify Desired Screen Size    3.6 Handling Variations in the DeliveryContext        3.6.1 Prefer Server-SideDetection Where Possible        3.6.2 Use Client-Side DetectionWhen Necessary        3.6.3 Use Device Classificationto Simplify Content Adaptation        3.6.4 Support anon-JavaScript Variant if Appropriate        3.6.5 Offer Users a Choice ofInterfaces    3.7 Further Considerations        3.7.1 Consider Use Of Canvas Element orSVG For Dynamic Graphics        3.7.2 Inform the User AboutAutomatic Network Access        3.7.3 Provide Sufficient Means toControl Automatic Network AccessAppendicesAppendix 1: Best PracticeDependent Device PropertiesAppendix 2: References    2.1 MWI References    2.2 Device Independence    2.3 Web, Protocols and Languages    2.4 Other ReferencesAppendix 3: AcknowledgmentsList of Best PracticesThe following Best Practices are discussed in this document and listed herefor convenience.Use Cookies SparinglyUse Appropriate Client-SideStorage Technologies for Local DataReplicate Local DataDo not Execute Unescaped orUntrusted JSON dataEnsure the User isInformed About Use of Personal and Device InformationEnable AutomaticSign-inUse TransferCompressionMinimize Applicationand Data SizeAvoid RedirectsOptimize NetworkRequestsMinimize ExternalResourcesAggregate Static Imagesinto a Single Composite Resource (Sprites)Include BackgroundImages Inline in CSS Style SheetsCache Resources ByFingerprinting Resource ReferencesCache AJAX DataDo not Send CookieInformation UnnecessarilyKeep DOM SizeReasonableOptimize ForApplication Start-up TimeMinimize PerceivedLatencyDesign forMultiple Interaction MethodsPreserve Focus onDynamic Page UpdatesUse Fragment IDs toDrive Application ViewMake TelephoneNumbers "Click-to-Call"Ensure Paragraph TextFlowsEnsure Consistency Of StateBetween DevicesConsider Mobile SpecificTechnologies for Initiating Web ApplicationsUse Meta Viewport Element ToIdentify Desired Screen SizePrefer Server-sideDetection Where PossibleUse Client-side DetectionWhen NecessaryUse Device Classificationto Simplify Content AdaptationSupport anon-JavaScript Variant if AppropriateOffer Users a Choice ofInterfacesThe following advisory notes from the Mobile Web Best Practices WorkingGroup are also discussed in this document and listed here for convenience.Consider Use Of Canvas Element orSVG For Dynamic GraphicsInform the User AboutAutomatic Network AccessProvide Sufficient Means toControl Automatic Network Access1 Introduction1.1 Purpose of the DocumentThis document sets out a series of recommendations designed to facilitatedevelopment and delivery of Web applications on mobile devices. Therecommendations are offered to creators, maintainers and operators of mobileWeb sites.1.2 AudienceReaders of this document are expected to be familiar with the creation ofWeb applications, and to have a general familiarity with the technologiesinvolved, but are not expected to have a background in mobile technologies orprevious experience with Mobile Web Best Practices (BP1)href="#MWBP">[MWBP].The document is not targeted solely at developers; others, such asinteraction and graphic designers, site administrators, and tool developers areencouraged to read it.1.3 ScopeThese recommendations expand on the recommendations of BP1. Where the focusof BP1 is primarily the extension of Web browsing to mobile devices,this document considers the development of Web applications on mobiledevices.1.3.1 Best PracticesThe approach in writing this document has been to collate and present themost relevant engineering practices prevalent in the development communitytoday and identify those that: a) facilitate the exploitation of devicecapabilities to enable a better user experience; or b) are considered harmfuland can have non-obvious detrimental effects on the overall quality of anapplication.The goal of this document is not to invent or endorse future technologies.However, there are a number of cases where explicitly omitting a Best Practicethat referred to an emerging technology on the grounds that it was too recentto have received wide adoption would have unnecessarily excluded a valuablerecommendation. As such, some Best Practices have been included on the groundsthat the Working Group believes that they will soon become fullyqualified Best Practices (e.g. in prevalent use within the developmentcommunity).In building a Web application, it is not necessary to implement allBest Practices. Instead, each Best Practice should be considered as a possiblemeasure that might be implemented towards the goal of providing as rich anddynamic an experience as possible on a mobile Web browser.1.3.2 Web ApplicationFor the purposes of this document, the term "Web application" refers to aWeb page (XHTML or a variant thereof + CSS) or collection of Web pagesdelivered over HTTP which use server-side or client-side processing (e.g.JavaScript) to provide an "application-like" experience within a Web browser.Web applications are distinct from simple Web content (the focus of BP1) inthat they include locally executable elements of interactivity and persistentstate.While the focus of this document is the Best Practices that apply toapplications running in a Web browser, in many cases these recommendations areequally applicable to other kinds of Web run-time, such as the W3C work on WebWidgets [WIDGETS] and also in a number ofvendor-specific initiatives.1.3.3 Mobile ContextIn a world where the line between mobile and non-mobile is necessarilyblurred and a document that restricts its focus solely to best practices thatare uniquely mobile would most likely be very short. With this inmind, the focus of this document is to address those aspects of Web applicationdevelopment for which there are additional, non-trivial concerns associatedwith the mobile context. This applies equally both to the limitations of themobile context (e.g. small screen, intermittent connectivity), and also theadditional scope and features that should be considered when developing for themobile context (e.g. device context / location, presence of personal data onthe device, etc).1.3.4 Delivery ContextThis document builds on some of the concepts described by the Ubiquitous WebApplications Working Group (UWA) and the Device Independence Principleshref="#DIP">[DIP]. It also discusses device and delivery channelcharacteristics, which the UWA has named "Delivery Context"href="#DCODI">[DCODI].This document does not make any explicit assumptions about features of theDelivery Context, but most Best Practices assume devices with support forstandard XHTML, JavaScript, and CSS capability. At the time of writing,developers of relatively complex Web applications targeting mid- to high-enddevices are most likely to benefit from these Best Practices, but as thetechnology evolves it is expected that the range of relevant devices willincrease.Additionally, some Best Practices are relevant only if the device exposescertain capabilities (for example, access to device information such aslocation). In these cases the requirements are summarized as a separatesub-heading.Saying that applications should be sensitive to the Delivery Context impliesthat some level of device knowledge and content adaptation is required. ForBest Practices specifically related to this area, seehref="#bp-devcap-detection">3.6 Handling Variations in Delivery Context.1.4 Relationship to other BestPractices and recommendationsThese recommendations are complementary to the recommendations of Mobile WebBest Practices 1.0 (BP1) though their focus is somewhat orthogonal. Whereas BP1focused on delivering a good experience on a broad range of devices, thisdocument's focus is on making use of advanced device capabilities to deliverthe best possible experience on those devices that can support it. For thisreason, while readers of this document are likely to benefit from reading BP1it is not a pre-requisite.1.5 TerminologyNote that the term "JavaScript" is used in place of the (arguably morecorrect) term "ECMAScript" in order to provide consistency with the companionWeb application technologies (JSON and AJAX) which are in common use and bothimplicitly refer to JavaScript in their names.Also, the terms "AJAX" and XMLHttpRequest (XHR) are used to refer to anyasynchronous browser request.2 Structure of Best PracticeStatementsThe HeadingA summary of the functional area to be addressed by thesestatements.What it meansAn explanation of the intention of the Best Practice statement.How to do itA discussion of the techniques and device capabilities required toimplement this Best Practice.[Requires]A summary of device capabilities required in order for this BestPractice to apply.3 Best Practice Statements3.1 ApplicationDataMost applications have the need to store data of various forms, bothintrinsic content (e.g. the emails of an email application, the calendar eventsof a calendar application) and supplementary personalization settings (e.g.preferred theme, default view, etc).These Best Practices relate to the appropriate technologies and techniquesto use for managing a Web application's data.3.1.1 Use CookiesSparingly3.1.1.1 What it meansCookies are a common and effective means to store small amounts of state onthe client. They are appropriate for simple personalization data and arecommonly used to store a token representing user identity in order to enableautomatic sign-in.Information stored in cookies, however, is sent to the server for everyrequest and so using them for excessive amounts of data can negatively impactperformance, particularly on a mobile network.Also, in the mobile context, cookie support cannot be relied upon since itmay be disabled either in the device configuration or by the mobile network.For this reason, applications should endeavor to remain functional even ifcookies are unavailable. Seehref="http://www.w3.org/TR/mobile-bp/#COOKIES">BP1 [COOKIES] Do not rely oncookies being available for more cookie related caveats.3.1.2 Use AppropriateClient-Side Storage Technologies for Local Data3.1.2.1 What it meansIf supported by the device, client-side storage APIs provide a mechanism tostore more extensive amounts of data than would be appropriate with cookies. Atthe time of writing, work is still undergoing to unify these APIs, see the W3CWebApps working group [WEBAPPS] and Device APIs workinggroup [DAP] for more information. Additionally, someexamples of existing technologies that support client-side storage APIs areBONDI [BONDI], HTML5 [HTML5], andOpera Widgets [OPERA].Making use of client-side storage in Web applications is a powerfultechnique that brings Web applications into parity with native applications interms of start-up time and responsiveness. Two key advantages are worth notingexplicitly:Application data stored locally can be displayed immediately when theapplication is started (without the need for a server roundtrip) allowingstart-up latency to be reduced.By making updates locally at first and replicating changes back to theserver in the background when connectivity is available, Web applicationscan continue to operate responsively even when the network signal isunreliable.3.1.2.2 How to do itEach technology offers a variety of storage facilities that range from simple"key = value" models appropriate for relatively simple, unstructured data, tofull SQL Database APIs appropriate for more extensive and structured content.For a good technical discussion of these facilities in the context of HTML5 seeOffline Web Applications [OFFLINE].[ Client-Side Storage ] Requires: Local Storage API.3.1.3 Replicate Local DataTo A Server If Necessary3.1.3.1 What it meansIf a client-side storage API is being used the data in it is not visible tothe user's other devices. Whilst this is appropriate for some forms of data(e.g. preferences and state relevant only to a given device), it is oftennecessary to send this data back to a server in order to provide a consistentview across devices (e.g. between mobile and desktop instances of anapplication) and make it possible to recover data if the device is lost ordamaged. See 3.5.8 Ensure Consistency Of StateBetween Devices for further discussion on these topics.As a rule of thumb, data that needs to be shared with other devices orrecovered in the case of a lost or damaged device, should be replicated back tothe server as soon as possible.3.1.3.2 How to do itThe technologies that provide client-side storage APIs provide facilities todetect the current network connectivity. For example, HTML5 provides a propertyon the navigator object (navigator.onLine) toindicate whether the client is currently online, and dispatches two events onthe Window object to indicate a change of network state (online and offline).However, these APIs should be used with caution. Even if the browser isreporting an online state, on an intermittent network this is no guarantee thata subsequent connection will succeed. The most effective approach is to failgracefully in the event of a connection failure, store unsaved data in a queueof uncommitted changes, and set a timer to try again later.[ Client-Side Storage ] Requires: Local Storage API.3.2 Security and privacyUse trusted information, and protect all personally identifiableinformation. Mobile Web applications are subject to the same securityconsiderations and risks as desktop Web applications, and as such most desktoprelated security advice is applicable to mobile. (For example, see OWASP [href="#OWASP">OWASP] for a good summary of common Web securityBest Practices). This document does not attempt to provide an exhaustive surveyof security issues but the following Best Practice has been called out on thegrounds that it is specifically relevant to mobile.3.2.1 Do not ExecuteUnescaped or Untrusted JSON data3.2.1.1 What it meansA common technique is to use JSON to transfer data to a client and then useJavaScript's eval() function toparse it. This is a powerful technique, since on constrained devices eval() can executemore quickly than the alternatives. However, direct execution of a datafeedthat contains unescaped user-generated data represents a significant securityrisk and should be avoided.Inadvertently executing malicious JavaScript is particularly dangerous onmobile devices where personal information (current location, contact data, etc)may be exposed.3.2.1.2 How to do itWhere possible, instead of parsing JSON data by executing it with the eval() function, use a JSON parser (for example a JavaScript implementation of a JSON parser [JSON-PARSE]).If this is impractical ensure that the data contains no user-generatedcontent (e.g. the server is responsible for the content of all fields in thedatafeed) or that any user-generated content is correctly escaped.See RFC4627 [RFC4627] for details on how to ensure a JSONdatafeed is suitably escaped and can be safely passed into JavaScript's eval() function.3.3 User Awareness andControlAllow the user to control application behaviour that might not otherwise beapparent, such as access to the network and access to device data. Forexample:Pictures, music, and video clips;Contacts, calendar (PIM data);Call history;System data (battery, coverage, roaming, location);Media recording (record audio/video clip, get new picture);Device context (e.g. location, connectivity, profile setting).Note that where possible it is preferable to rely on the browser's nativefunctionality to notify the user of these activities, however the BestPractices below provide further advice on appropriate applicationbehaviour in situations where the native functionality of the browser may notbe sufficient.>3.3.1 Ensure the User is Informed About Use of Personal and DeviceInformation3.3.1.1 What it meansEnsure that the user is informed if the application needs to access personalor device information. The user should be informed of the types of informationthat will be used by the application and whether / how that data will beexchanged with the server.These notices should be provided when the user first accesses the Webapplication, or on first access to user information. It should provide the userwith enough information to judge whether or not they want to allow theapplication access to their data.3.3.1.2 How to do itIn many cases use of APIs that provide access to personal or deviceinformation causes a native confirmation dialog to be presented to the user. Inthis case the application should not force the user to confirm again at theapplication level, but should make clear in the UI that displayed data has beenaccessed from the device.If the user declines a prompt to allow application access to personal ordevice information, the application must recover gracefully. For example, if arequest to a device API fails, do not automatically retry if this will lead tothe user being presented with repeated native confirmation dialog boxes.[ DEVICE DATA ] Requires: Device DataAPIs.>3.3.2 Enable Automatic Sign-inname="bp-enable-automatic-login-what">3.3.2.1 What it meansIf an application requires user identity it is usual to prompt for usercredentials (username and password) and provide the option to sign-inautomatically on next usage session. This is especially important on a mobiledevice where data input is more difficult than on a desktop.Note that if automatic sign-in is enabled, a sign-out link should also beprovided.name="bp-enable-automatic-login-how">3.3.2.2 How to do itUser credentials can be stored in a cookie or in local storage. However, itis important not to store unencrypted password information since this isinsecure. Typically, a securely hashed token which, if necessary, can berevoked on the server, is stored locally in order to enable automaticsign-in.3.4 Conservative use ofresourcesThe most effective way to ensure that applications run smoothly and with lowlatency is to minimize use of device memory, processor power, and networkbandwidth which are more limited on mobile devices than on the desktop.3.4.1 Use TransferCompression3.4.1.1 What it meansCompress content for efficient delivery.3.4.1.2 How to do itHTTP 1.1 compression, which uses the gzip and DEFLATE algorithms, is widely supported. Web servers should be configured to serve appropriately compressed responses.Note however, that the cost (in time and battery usage) of decompressingdata should be balanced against the gains in transport efficiency. Whenconfiguring HTTP 1.1 compression note that:Most image formats (especially JPEGs) do not benefit from compression,but SVG does;Most other media formats (e.g. audio, video) do not benefit fromcompression;Very small files (e.g. <1k) generally do not benefit fromcompression.Where supported, alternative compression formats (such as EXI [EXI]) that do not share some of the above impediments, may provide benefit.>3.4.2 Minimize Application and Data Size3.4.2.1 What it meansThis section elaborates on the Best Practices of BP1 (href="http://www.w3.org/TR/mobile-bp/#MINIMIZE">MINIMIZE). Smallerapplications will download and execute more quickly and more reliably thanlarger ones on constrained devices.3.4.2.2 How to do itProcess HTML, JavaScript and CSS files to remove whitespace and minifybefore delivery."Minification" / "optimization" may take a number of forms from simpleremoval of white space and comments, to the global substitution of tokens(variables, method names, selector names) with shorter alternatives. Ingeneral, minification based upon a lexical / grammatical understanding of thatsource is less fragile and is preferred to simple regular-expression basedtools.See the JavaScript CompressorRater [JSCOMP] for a comparison of JavaScript minification tools.3.4.3 AvoidRedirects3.4.3.1 What it meansThe redirection of requests (using HTTP 3xx status or HTML meta refresh) istypically used to exchange information between servers (e.g. accountauthentication). The delay incurred by redirects is much higher over mobilenetworks and so the number of redirects should be kept to a minimum.3.4.3.2 How to do itTry not to use redirects. If more than two redirects are required considerusing an interstitial page to communicate to the user that the application isstill working.3.4.4 OptimizeNetwork Requests3.4.4.1 What it meansEstablishing the necessary connections in order to complete an HTTP requestcan take significantly longer on a mobile network than on a fixed network. Eventhough bandwidth is typically more restricted on a mobile network it is stillpreferable to make fewer, larger requests.3.4.4.2 How to do itConsider the following possibilities when designing an application:Batching requests:Since a single request for more data is likely to provide a better userexperience than several smaller requests, wherever possible, batch upmultiple requests at the application level.Throttle low-priority requests:In some applications certain requests may be less critical than others(e.g. logging requests). Throttle low-priority requests to ensure theydon't block the network and prevent more critical requests from beingserviced quickly.Back off during periods of inactivity:If the application polls for updates, it should monitor user activityand poll less frequently during inactive periods.Device Context:If supported by the device, use awareness of current connectivity (e.g.WiFi) to select an appropriate level of interaction.>3.4.5 Minimize External Resources3.4.5.1 What it meansA Web application typically requires a number of resources (style sheets,scripts, image, etc) each of which requires an HTTP request. As above, HTTPrequests are particularly expensive on a mobile network and so fewer, largerrequests should be favored over a larger number of smaller requests.3.4.5.2 How to do itAs far as makes sense after taking into accounthref="#bp-presentation-perceived">3.5.2 Minimize Perceived Latency combineall style sheets into a single resource and all scripts into a single resource.If multiple scripts and style sheets are required as part of the authoringprocess, then try to arrange that they are merged before the page is served.3.4.6 AggregateStatic Images into a Single Composite Resource (Sprites)3.4.6.1 What it meansWeb applications often depend on a number of static images to provide icons,buttons, etc. If served as a separate image each one incurs an additional HTTPrequest which is detrimental to performance.3.4.6.2 How to do itDefine candidate images as CSS background images and combine them into asingle image for transfer (spriting). To optimize efficiency combine images ofsimilar sizes and color palettes. Also, combine images that do not changeoften, since if one of the component images changes the entire combinationimage will need to be refreshed. To render individual components of a resourceuse CSS positioning and clipping.Note that this technique should only be applied to decorativeimages (e.g. those that don't require an alt text). Spritinginformational images leads to an undesirable coupling of content and layout andis detrimental to accessibility.[ CSS ] Requires: CSS2 Clipping and Positioning Support3.4.7 IncludeBackground Images Inline in CSS Style Sheets3.4.7.1 What it meansVisual effects (e.g. background images and gradients) are often used toimprove the look and feel of an application. These can be included in CSS asbase64 encoded strings in order to avoid an additional HTTP requestNote that base64 encoding adds around 10% to the image size after gzipcompression and this additional cost should be weighed against the benefits offewer requests.3.4.7.2 How to do itBackground images can be encoded using the data URI scheme:url('data:image/png;base64, [data])[ CSS ] Requires:href="http://tools.ietf.org/html/rfc2397">RFC2397 [RFC2397] data uri support.3.4.8 CacheResources By Fingerprinting Resource References3.4.8.1. What it meansDynamic resources that change occasionally (e.g. a user's avatar) can stillbe cached by identifying them with a URI that includes a hash of the resourcecontent. Using this technique means that the browser does not need to check theresource headers in order to validate its cache, instead, any change in theresource will lead naturally to a corresponding change in the resourcereference.For example,<imgsrc="http://www.example.com/userimages/joeblogs-67f90da089da">Where the actual resource at joeblogs-[xxx] could be either generated insome offline process or served dynamically.3.4.8.2 How to do itSet the resource caching policy to "never expire" by setting theExpires header to a date in the far future.Reference the resource using a URI that contains a Hash of the content.If the content changes, this reference will change and the browser willfetch the updated data.3.4.9 Cache AJAXData3.4.9.1 What it meansIf possible, data designed to be accessed by AJAX requests from the clientshould be cached in the same way as primary content.3.4.9.2 How to do itThe standard caching techniques (Expires header andCache-Control header), as well as resource fingerprinting (seehref="#bp-conserve-fingerprint">3.4.8) can be used on AJAX data as readilyas primary content pages.3.4.10 Do not SendCookie Information Unnecessarily3.4.10.1 What it meansStatic resources do not need cookie information and so performance can beimproved by serving them from a path or sub-domain for which the application'scookies are out of scope.3.4.10.2 How to do itUse a different domain, sub-domain, or path name for static resources to themain application, and restrict the valid path of cookies such that they willnot be exchanged when they are not needed.For example:Set-Cookie:somePreferenceInformation=purple; path=/myapp/Application data served from /myapp will receivecookie information.Static data served from /static will notreceive unneeded cookie information.3.4.11 Keep DOM SizeReasonable3.4.11.1 What itmeansThe in-memory size of the Document Object Model (DOM) may be limited onmobile devices. Large / complex pages may exceed this limit and causeunpredictable errors.3.4.11.2 How to doitLimit the amount of information in the DOM at a single time using paginationor other appropriate techniques.3.5 User ExperienceGiven the additional complexities of interacting with an application on amobile device, special consideration should be given to the overall userexperience. User experience is influenced by a number of factors, including:latency, interaction method, and data consistency.3.5.1Optimize For Application Start-up Timename="bp-presentation-startup-what">3.5.1.1 What it meansUser experience is strongly influenced by the initial start-up time of anapplication.Offline Web application technologies like HTML5 AppCache [href="#HTML5-OFFLINE">HTML5-OFFLINE] bring Web applications into paritywith native applications in terms of their start-up time and their ability tobe used even where network coverage is intermittent. The following steps shouldbe considered to minimize the start time of a Web application.name="bp-presentation-startup-how">3.5.1.2 How to do itConsider the following techniques to help minimize application starttime:Use Offline Technology: Offline Web technologies (forexample, AppCache) allow the resources of a Web application (its HTML,JavaScript, and CSS files) to be specified and stored locally so that theapplication can start without requiring a round-trip to the server.Consider Partitioning Large Scripts: In complex Webapplications, JavaScript parsing can contribute a significant portion ofstart time. If some functionality is rarely used it should be moved intoseparate scripts that can be loaded on demand, lowering the amount of corecode that needs to be parsed at start-up.Use Local Storage: Where appropriate, store a snapshotof the last application state so it can be displayed immediately onstart-up without requiring a server roundtrip.Minimize Number of Local Storage Queries: The number oflocal storage queries required to generate the initial view is asignificant contribution to start-up latency. Try to minimize the number oflocal storage queries required before the first view can be displayed.>3.5.2 Minimize Perceived Latencyname="bp-presentation-perceived-meaning">3.5.2.1 What it meansLowering perceived latency is an important factor in improving the overallusability of a Web application.name="bp-presentation-perceived-howto">3.5.2.2 How to do itA number of techniques can be used to lower perceived latency:Enable Incremental Rendering: Place JavaScript at thebottom of the page (since browsers rendering halts while parsingJavaScript) and configure the page so that any useful information thatmight be available is viewable while the main content of the application isstill loading.Keep the User Informed of Activity: Use spinnersprogress bars to keep the user informed during network and device APIaccesses so that they do not think the application is halted.Avoid Page Reloads: To reflect changes in state or showdifferent views within an application, update pages dynamically (bymanipulating the DOM) rather than reloading them.Preload Probable Next Views: Preload data for frequentlytraversed paths in the application so it can be displayed more quickly whenthe user requests it.name="bp-presentation-interaction">3.5.3 Design for Multiple InteractionMethodsname="bp-presentation-interaction-what">3.5.3.1 What it meansInteraction methods vary across devices. Three main interaction methodsshould be considered when designing the UI:Focus Based: The browser focus "jumps" from element to element;Pointer Based: Key-based navigation controls a pointer that can cover anypart of the screen;Touch Based: Events are related directly to a finger or stylus touchposition on the screen.The optimum configuration of UI elements varies depending on the interactionmethod used by the device. Ideally, the UI should be adapted based on aknowledge of the interaction methods supported by the target device. If this isnot possible, then the UI should be designed to provide a good experience foreach of these different interaction methods.Additionally note that (as always) new interaction methods are likely toemerge in the future, particularly in the fields of voice and assistivetechnology. For additional, non-mobile specific, guidelines on accessibilityand designing for assistive technologies, see Web Content Accessibility Guidelines (WCAG) 2.0 [WCAG20].name="bp-presentation-interaction-how">3.5.3.2 How to do itParticularly where navigation of content requires multiple links (i.e.back/forward in a carousel) the following factors should be considered:Focus Based:The current focus of the page is easily determined because the focuselement will be highlighted;Focus area will jump automatically from one selectable element to another(e.g. from link to link) without affecting usability even when widelyspaced.Pointer Based:Selectable elements that are associated with each other need to be closeas moving the pointer can be slow;Selectable elements need to be large enough to be easily selected --since the pointer often moves in steps of between 5 - 10 pixels;Selectable elements should have rollovers to make it clear when thepointer has entered their active area.Touch Based:Selectable elements may be (but don't have to be) widely spaced since theuser can select them directly;Selectable elements must be large enough to be easily selected (e.g. listitems should have a screen height of at least around 1cm);No elements are in focus until they are selected so extra informationcannot be passed to the user (e.g. rollovers will not work).>3.5.4 Preserve Focus on Dynamic Page Updates3.5.4.1 What it meansThe JavaScript focus method can be used to move the focus tothe part of a page that has changed. However, if unexpected, this can confuseor irritate the user, especially if returning to the previous focus is noteasy.3.5.4.2 How to do itUse the JavaScript focus method only if it is essential to theuse of the application, and does not inhibit user control/interaction.3.5.5 UseFragment IDs to Drive Application View3.5.5.1 What it meansWeb applications can switch views without a full page reload by showing andhiding sections of content. However, this means that the browser <back>button doesn't work by default, and it is not possible to link directly tospecific views within an application. Usability is enhanced by enabling both ofthese features:Enabling deep links (e.g. to the content of a specific email) means theuser can bookmark this view and return to it quickly;Enabling the browser history provides a natural method to navigateapplication views that is natively supported by the browser.3.5.5.2 How to do itAssign a URI with a distinguishing fragment identifier (e.g.http://myapp.example.org/myapp#view). Use JavaScript tointerrogate the browser location in order to determine which view todisplay.For further discussion on this topic see: Unique URLs pattern [AJAX-UNIQUE] on the Ajax Design Patterns Web site.Note that showing and hiding content in this way can have adverse affects onaccessibility if not carefully handled. See WAI-ARIA [ARIA] for more information on writing accessible rich Web applications.>3.5.6 Make Telephone Numbers "Click-to-Call"3.5.6.1 What it meansStandardized URI schemes have been defined for some common device functions,e.g. making phone calls, sending an SMS, and managing address books. These URIschemes, if supported, can enable users to easily use these functions from Webapplications.3.5.6.2 How to do itThe most broadly supported scheme is tel: as described in RFC3966 [RFC3966]. Code such as the following can be used to enable"Click-to-Call":<ahref="tel:[PHONE-NUMBER]">[PHONE-NUMBER]</a>Note that [PHONE-NUMBER] should always be entered using the fullinternational prefix (e.g. +1-201-555-0111) to ensure that it works outside ofits home country.Similarly RFC5724 [RFC5724] can be used to send a GSM SMS (text message) as follows:<ahref="sms:[PHONE-NUMBER]?body=[MESSAGE]">[PHONE-NUMBER]</a>Note that at the time of writing support for this RFC is limited and devicecompatibility should be verified before deployment.3.5.7 EnsureParagraph Text Flows3.5.7.1 What it meansOn small screens it is important that paragraph text flows both so that itdoesn't require horizontal scrolling and so that it will re-flow if the vieworientation is changed. See>BP1 [MEASURES] for more details.3.5.7.2 How to do itDo not use absolute or pixel measures. Use percentage and RELATIVE measuresfor containers so that text can re-flow automatically.3.5.8 Ensure Consistency OfState Between Devices3.5.8.1 What it meansThis recommendation builds on the recommendation in BP1 (href="http://www.w3.org/TR/mobile-bp/#tc">5.5.1 Thematic Consistency) andexpands it to consider the application preferences,personalization data, and state that form part of the overallexperience on a mobile Web application.User credentials valid on one device should be valid on other devices. Userpreferences captured on one device should be accessible on other devices. Dataupdated on one device should be viewable consistently on other devices.An important example of this is offering a consistent experience where dataentered on a desktop is available on a mobile and vice versa.3.5.8.2 How to do itFor any application data that is not exclusively relevant to the currentdevice, favor storing it on the server so it can be shared by other devices.See 3.1 Application Data for more details.3.5.9 ConsiderMobile Specific Technologies for Initiating Web Applications3.5.9.1 What it meansNetwork-initiated content delivery ("push") methods allow notifications andupdates to be sent to the user even when they are outside of the applicationcontext.3.5.9.2 How to do itPush method support may be disclosed through a User Agent Profile [UAPROF] document if published by the device vendor, or through a device classification repository.If supported by the user agent, options for Push methods include:OMA Push: a widely supported enabler providing methods for user-confirmed and automatic content push, directed to mobile browsers and other user-agents. See OMA Push specifications [OMA-PUSH] for more details;SMS;QR Codes;Alternative vendor-specific initiatives.3.5.10 Use Meta Viewport Element ToIdentify Desired Screen Size3.5.10.1 What it meansCertain classes of browser attempt to display desktop pages on a smallscreen by automatically zooming the display. This can be problematic forapplications that have already been optimized for a small screen. The viewportmeta tag tells the device at what scale to render the page.3.5.10.2 How to do itA typical viewport setting looks like this:<meta name="viewport"content="width=device-width, initial-scale=1.0"/> ,and is inserted into the <head> elementof the HTML document. This setting informs the browser to always render thepage at 100% (e.g. no browser based scaling) and is appropriate for pagesspecifically designed for the target screen-size.3.6 Handling Variation in the DeliveryContextVariations in the Delivery Context (such as different device capabilities)is a prominent feature of the mobile Web. Web applications should adapt toknown or discoverable properties of the Delivery Context by adjusting thecontent, navigation or page flow, with a view to offering a good userexperience on as broad a range of devices as possible.3.6.1 PreferServer-Side Detection Where Possible3.6.1.1 What it meansWhere possible, use the evidence available on the server to determine theproperties of the Delivery Context, and adapt the responses to the clientbefore transfer, thus improving the user experience and avoiding transfer ofunnecessary or incompatible data.3.6.1.2 How to do itIn its most basic form, the minimum evidence from the requesting device isthe HTTP request header fields. Typically, the following header fields provideevidence of device capabilities:Accept: this list of MIME types can aid in the selectionor creation of alternative content representations to suit the requestingdevice. This field is not always reliable however, and its value oftenincludes "*/*", suggesting that clients can accept every MIME type.User-Agent: as a generally unique (albeit opaque) stringit can be used as a key into a device description repository [href="#DDR">DDR]. The set of properties recorded in these repositoriesvaries from implementation to implementation. The W3C DDR Simple APIdefines a common interface and a means of expressing the vocabulary ofproperties for such repositories.X-Wap-Profile: this is a reference to the User AgentProfile [UAPROF] for the requesting device. Inpractice, the referenced profile is not always guaranteed to be available,valid or up-to-date, so the value of this field is sometimes used with aDDR where corrections to the profiles are stored. Some devices may send anadditional field X-Wap-Profile-Diff advertising temporaryor permanent variations of a specific device with respect to its standardprofile.3.6.2 UseClient-Side Capability Detection Where Necessary3.6.2.1 What it meansWhere it is not possible to determine certain properties of the DeliveryContext from the server, this information may be available at the client. Onceobtained at the client, the information can be used directly to adapt thepresentation, or it can used to request alternative, adapted content from theserver.3.6.2.2 How to do itThere are a few client-side solutions available to the developer:JavaScript: this is the mostcommon solution. A script determines the device / browser properties andmanipulates the content and behaviour of the application accordingly. This canbe done in two ways:By encapsulating the differingbehaviors in the control logic of the application (e.g. if (some_api_exists) {...). Typically the Delivery Context information is gathered at thestart of the session, though dynamic information (e.g. current screenorientation) should be refreshed during the session.By passing the gathered information back to theserver and requesting alternative content (e.g. either by dynamicallyadding a new <script>element to the DOM or by an XHR request).CSS Media Types: CSS Media Typesallow different stylesheets to be associated with different media types (e.g.print, screen, mobile) and are traditionally used to repurpose content forthese destinations. Since the list of recognized media types is limited,however, and devices are notoriously idiosyncratic in their interpretation oftypes, it is in general not a helpful technology in this context. See MediaTypes [CSSMT] for more details.CSS Media Queries: Media queriesare an extension to the "media-types" paradigm that allow developers to applyspecific style rules based on the device display characteristics (e.g. screenwidth, orientation, or resolution). At the time of writing this specificationis not fully supported, but can provide a useful way to modify the page layout(for example to re-flow sections of text) in a more maintainable, declarativeway than is possible with script. See Media Queries [href="#CSSMQ">CSSMQ] for more details.3.6.3 Use DeviceClassification to Simplify Content Adaptation3.6.3.1 What it meansIf a large number of devices are being targeted, or if the application issensitive to the permutations of a large number of configuration properties,the number of application variants required might quickly becomeunmanageable.To combat this, classify target devices and build a single applicationvariant for each class. This allows you to exploit device capabilities with amanageable code base.3.6.3.2 How to do itIdentify the target devices for the application and assign these to deviceclasses of varying capability. Focus on application variants that work in eachclass rather than building device-specific exceptions for every variation indevice configuration.Device classes should be defined on an application by application basis, sothat the variants can be tailored accordingly.Example 1: Possible definition of application classes based on rendering anddevice API capabilities:Class 1: Basic XHTML support, noor very basic scripting. No XHR support. (Even if these kind of devices are notbeing explicitly supported, it is often advisable to support a non-XHR versionin case JavaScript has been disabled on the device).Class 2: Full AJAX and JavaScriptsupport.Class 3: Advanced device APIs, forexample: access to location API, device PIM data, or application cache.Example 2: Possible definition of application classes based on supporteduser-interaction modes:Class 1: Pointer Based.Class 2: Touch Based.>3.6.4 Support a non-JavaScript Variant if Appropriate3.6.4.1 What it meansScripted and XHR based applications are not supported on all browsers. Ifbroadest reach is a primary concern then consider providing a variant of theapplication that uses synchronous FORM posts in place of XHR requests. ThisBest Practice is related (albeit with a differing focus) tohref="http://www.w3.org/TR/mobile-bp/#OBJECTS_OR_SCRIPT">BP 1 [OBJECTS_OR_SCRIPT].3.6.4.2 How to do itEssentially this BP states that it is favorable to support "Class 1" devicesas defined in the first example above if appropriate. Doing this will ensurethat the application can be used across as broad a range of devices aspossible. Furthermore, in some cases a non-JavaScript version can be useful forsimple operations in low-bandwidth situations.In some cases, however, a particular application simply has nonon-JavaScript counterpart (e.g. a Web based game, an Instant Messaging client)in which case the server should return a response with human readable contentexplaining the situation in more detail.Ideally, content should be adapted before transfer by checking whether ornot the device supports JavaScript using a DDR or local index. However, in somecases (e.g. if the device has disabled JavaScript) JavaScript may still be sentto a device that can't process it. To cover this case, a <noscript>element should always be included and contain a suitably informativemessage.3.6.5 OfferUsers a Choice of Interfaces3.6.5.1 What it meansNot only is device characteristic detection imperfect, it cannot alwaysaccount for the differing use cases of an application. Therefore automaticdetection is not sufficient as the only mechanism for determining which versionis appropriate.3.6.5.2 How to do itWhere multiple versions of an application exist (e.g. to support the variousdevice classifications) always offer the user the opportunity to change theselection.Always attempt to default to the most appropriate UI on first use.Always remember the user's preference for future visits in a cookie or localdata store.3.7 Further ConsiderationsThe Mobile Web Best Practices Working Group would like to draw the attentionof Web application developers on the following considerations. Theseconsiderations should not be viewed as best practices, because they are notprevalent in the development community at the time of writing. They arepublished as advisory notes.3.7.1 Consider Use of Canvas Element orSVG For Dynamic Graphics3.7.1.1 What itmeansCanvas and SVG provide alternative options for incorporating graphics in aWeb application. Support for these technologies varies across devices so inmany cases the choice of which technology to use will depend on the targetdevices for a given application.The canvas element specifies a display region where JavaScript can be usedto draw simple graphics. In contrast, SVG is an XML language for definingvector graphic elements that are added to a DOM which can be modified usingJavaScript.SVG is well-suited for graphics that must be scalable and whose componentsneed to be modified (e.g. panning and zooming a map) whereas canvas is bettersuited where a static bitmap is sufficient (e.g. drawing a scatter-chart orcreating visual effects).If speed is important, canvas may be more effective. However since Canvasgenerates a flat bitmap it is not inherently accessible and so should not beused as the sole means of conveying information.3.7.1.2 How to do itSee the Canvas Element in the HTML5 specification [HTML5, section 4.8.10] for information on how to use the Canvas element.See W3C Scalable Vector Graphics (SVG) home page [SVG] for information on how to use SVG.3.7.2 Inform theUser About Automatic Network Access3.7.2.1 What it meansNetwork traffic on a mobile device depletes the battery and may incurexpense -- so it is important to inform the user when accessing the network.Whenever an application makes asynchronous XHR data requests, whether inresponse to a user action or automatically, this should be indicated in anappropriate manner so that the user remains informed and in control.3.7.2.2 How to do itApplications should disclose how they use network resources. A simple iconindicating background activity is usually sufficient and does not interrupt theflow of the application. If extensive background network activity is requiredthe user should be informed when they first visit the site, when they firstsign-in, or in associated help pages.The kinds of detailed information that could be disclosed in associated helppages or terms of service are:how often the application will interact with the Internet - e.g. every 5minutes, hourly, daily;for how long the automatic behavior will continue;how heavy the overall usage is expected to be or the type of service planrecommended.3.7.3 Provide SufficientMeans to Control Automatic Network Access3.7.3.1 What it meansIf an application makes automatic network requests (e.g. to poll the serverfor updates or to automatically store an updated client state) a means tocontrol this activity should be provided.3.7.3.2 How to do itAll applications that access the network automatically should provide ameans for the user to disable that activity. When automatic network activity isdisabled, periodically prompt the user to make network requests.Consider allowing the user to adjust the polling schedule and to controlwhich activities are allowed to initiate network requests.>Appendix 1: Best Practice Dependent Device PropertiesThe following device properties included in the DDR Core Vocabulary [href="#DDR-VOCAB">DDR-VOCAB] are of particular value in supporting bestpractices recommended in this document. They should be available in any DDRsupporting the W3C's DDR Core Vocabulary:Display Width, Display Height, Display Color DepthInput DevicesMarkup SupportStylesheet SupportImage Format SupportInput Mode SupportCookie SupportScript SupportAppendix 2: References2.1 MWI ReferencesMWBPMobile Web Best Practices 1.0, Jo Rabin, Editor,W3C Recommendation, 29 July 2008 (seehref="http://www.w3.org/TR/mobile-bp/">http://www.w3.org/TR/mobile-bp/)2.2 Device IndependenceDCODIDelivery Context Overview for Device Independence, , R. Gimson, R.Lewis, S. Sathish, Editors, W3C Working Group Note, 20 March 2006 (Seehref="http://www.w3.org/TR/di-dco/">http://www.w3.org/TR/di-dco/)DIGLOSSGlossary of Terms for Device Independence, R. Lewis, Editor, W3CWorking Draft (work in progress), 18 January 2005 (Seehref="http://www.w3.org/TR/2005/WD-di-gloss-20050118/">http://www.w3.org/TR/2005/WD-di-gloss-20050118/)DIPDevice Independence Principles, R. Gimson, Editor, W3C Working GroupNote, 1 September 2003 (Seehref="http://www.w3.org/TR/2003/NOTE-di-princ-20030901/">http://www.w3.org/TR/2003/NOTE-di-princ-20030901/)2.3 Web, Protocols and LanguagesCSSCascading Style Sheets (CSS1) Level 1 Specification, Håkon Wium Lie,Bert Bos, Editors, W3C Recommendation, 11 January 1999, revised 11 April2008 (Seehref="http://www.w3.org/TR/2008/REC-CSS1-20080411/">http://www.w3.org/TR/2008/REC-CSS1-20080411/)CSS2Cascading Style Sheets, level 2 CSS2 Specification, Bert Bos, HåkonWium Lie, Chris Lilley, Ian Jacobs, Editors, W3C Recommendation, 12 May1998, revised 11 April 2008 (Seehref="http://www.w3.org/TR/2008/REC-CSS2-20080411/">http://www.w3.org/TR/2008/REC-CSS2-20080411/)HTTP1.0Hypertext Transfer Protocol -- HTTP/1.0 Request for Comments: 1945, T.Berners-Lee, R. Fielding, H. Frystyk, May 1996 (Seehref="http://www.w3.org/Protocols/rfc1945/rfc1945">http://www.w3.org/Protocols/rfc1945/rfc1945)HTTP1.1Hypertext Transfer Protocol -- HTTP/1.1 Request for Comments: 2616, R.Fielding, J. Gettys, J. Mogul, H. Frystyk, L. Masinter, P. Leach, T.Berners-Lee, June 1999 (Seehref="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http://www.w3.org/Protocols/rfc2616/rfc2616.html)XMLExtensible Markup Language (XML) 1.0 (Fifth Edition), Tim Bray, JeanPaoli, C. M. Sperberg-McQueen, Eve Maler, François Yergeau, Editors, W3CRecommendation, 26 November 2008 (Seehref="http://www.w3.org/TR/2008/REC-xml-20081126/">http://www.w3.org/TR/2008/REC-xml-20081126/)2.4 Other ReferencesAJAX-UNIQUEUnique URLs pattern on Ajax Design Patterns Web site (See http://ajaxpatterns.org/Unique_URLs)ARIAAccessible Rich Internet Applications (WAI-ARIA) 1.0, James Craig etal, W3C Working Draft, 16 September 2010 (Seehref="http://www.w3.org/TR/wai-aria/">http://www.w3.org/TR/wai-aria/)BONDIOMTP Reference Implementation (seehref="http://bondi.omtp.org/">http://bondi.omtp.org/)CSSMQMedia Queries, Håkon Wium Lie, Tantek elik, Daniel Glazman, Anne vanKesteren, W3C Candidate Recommendation, 27 July 2010 (seehref="http://www.w3.org/TR/css3-mediaqueries/">http://www.w3.org/TR/css3-mediaqueries/)CSSMTCascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification, BertBos et al, W3C Candidate Recommendation, 08 September 2009 (seehref="http://www.w3.org/TR/CSS21/media.html">http://www.w3.org/TR/CSS21/media.html)DAPW3C Device APIs Working Group (seehref="http://www.w3.org/2009/dap/">http://www.w3.org/2009/dap/)DDRDevice Description Repository Simple API, Jo Rabin et al, W3CRecommendation, 05 December 2008 (seehref="http://www.w3.org/TR/DDR-Simple-API/">http://www.w3.org/TR/DDR-Simple-API/)DDR-VOCABDevice Description Repository Core Vocabulary, Jo Rabin et al, W3CWorking Group Note, 14 April 2008 (seehref="http://www.w3.org/TR/ddr-core-vocabulary/">http://www.w3.org/TR/ddr-core-vocabulary/)EXIEfficient XML Interchange, W3C Candidate Recommendation, John Schneiderand Takuki Kamiya, 08 December 2009 (seehref="http://www.w3.org/TR/exi/">http://www.w3.org/TR/exi/)HTML5HTML5, Ian Hickson and David Hyatt, W3C Working Draft, 19 October 2010(seehref="http://www.w3.org/TR/html5/">http://www.w3.org/TR/html5/)id="HTML5-OFFLINE">HTML5-OFFLINEHTML5, Ian Hickson and David Hyatt, W3C Working Draft, 19 October 2010(seehref="http://www.w3.org/TR/html5/offline.html#offline">http://www.w3.org/TR/html5/offline.html#offline)JSCOMPThe JavaScript CompressorRater (see http://compressorrater.thruhere.net)JSON-PARSEImplementation of a secure JSON parser in JavaScript (see https://github.com/douglascrockford/JSON-js/raw/master/json_parse.js)OFFLINEOffline Web Applications, Anne Van Kesteren and Ian Hickson, W3CWorking Group Note, 30 May 2008 (seehref="http://www.w3.org/TR/offline-webapps/">http://www.w3.org/TR/offline-webapps/)OMA-PUSHOMA Push (see http://www.openmobilealliance.org/Technical/wapindex.aspx)OPERAOpera Web Widget API (seehref="http://dev.opera.com/libraries/widgetobject/">http://dev.opera.com/libraries/widgetobject/)OWASPOpen Web Application Security Project (seehref="http://www.owasp.org/index.php/Main_Page">http://www.owasp.org/index.php/Main_Page)RFC2397The "data" URL scheme, L.Masinter. IETF, August 1998(See http://www.ietf.org/rfc/rfc2397.txt)RFC3966The tel URI for Telephone Numbers, H. Schulzrinne. IETF, December 2004(Seehref="http://www.ietf.org/rfc/rfc3966.txt">http://www.ietf.org/rfc/rfc3966.txt)RFC4627The application/json Media Type for JavaScript Object Notation (JSON),D. Crockford, July 2006 (seehref="http://www.ietf.org/rfc/rfc4627">http://www.ietf.org/rfc/rfc4627)RFC5724URI Scheme for Global System for Mobile Communications (GSM) ShortMessage Service (SMS), E. Wilde and A. Vaha-Sipila. IETF, January 2010(Seehref="http://www.ietf.org/rfc/rfc5724.txt">http://www.ietf.org/rfc/rfc5724.txt)SVGW3C Scalable Vector Graphics (SVG) home page (see http://www.w3.org/Graphics/SVG/)UAPROFOpen Mobile Alliance OMA-TS-UAProf-V2_0-20060206-A User Agent ProfileApproved Version 2.0 06 Feb 2006 (Seehref="http://www.openmobilealliance.org/technical/release_program/docs/UAProf/V2_0-20060206-A/OMA-TS-UAProf-V2_0-20060206-A.pdf">http://www.openmobilealliance.org/technical/release_program/docs/UAProf/V2_0-20060206-A/OMA-TS-UAProf-V2_0-20060206-A.pdf)WCAG20Web Content Accessibility Guidelines 2.0, B. Caldwell, M. Cooper, L. Guarino Reid, G. Vanderheiden et al, W3C Recommendation 11 December 2008 (seehref="http://www.w3.org/TR/WCAG20/">http://www.w3.org/TR/WCAG20/)WEBAPPSW3C WebApps Working Group (seehref="http://www.w3.org/2008/webapps/">http://www.w3.org/2008/webapps/)WIDGETSWidget Packaging and Configuration, Marcos Cáceres, W3C Working Draft, 5 October 2010 (see http://www.w3.org/TR/widgets/)WTAIWAP Forum wap-268-wtai-20010908-a Wireless Telephony ApplicationInterface Specification (Seehref="http://www.openmobilealliance.org/tech/affiliates/LicenseAgreement.asp?DocName=/wap/wap-268-wtai-20010908-a.pdf">http://www.openmobilealliance.org/tech/affiliates/LicenseAgreement.asp?DocName=/wap/wap-268-wtai-20010908-a.pdf)XHTML-BasicXHTML Basic 1.1 - Second Edition, Shane McCarron, Masayasu Ishikawa, Editors, W3C Recommendation, 23 November 2010 (Seehref="http://www.w3.org/TR/2010/REC-xhtml-basic-20101123/">http://www.w3.org/TR/2010/REC-xhtml-basic-20101123/)Appendix 3:AcknowledgmentsThe editors would like to thank members of the BPWG for contributions ofvarious kinds. The editors would also like to thank contributors to the publiclist, and contributors of Last Call comments whose comments have been takeninto account in the creation of this document.The editors acknowledge significant written contributions from:* Daniel Appelquist, Vodafone* Jo Rabin, mTLD Mobile Top Level Domain (dotMobi)* Phil Archer, W3C* Jeff Sonstein, Rochester Institute of Technology* François Daoust, W3C* Scott Hughes, Vodafone